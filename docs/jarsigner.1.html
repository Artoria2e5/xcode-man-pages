<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   t
   @(#)jarsigner.1 1.7 00/06/13 SMI;
   Copyright 2004 Sun Microsystems, Inc. All rights reserved.
   Copyright 2004 Sun Microsystems, Inc. Tous droits r\351serv\351s.
   -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>jarsigner(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">jarsigner(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">jarsigner(1)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
jarsigner - JAR signing and verification tool
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>jarsigner</b> [ <i>options</i> ] <i>jar-file alias</i>
<br/>
<b>jarsigner</b> <b>-verify</b> [ <i>options</i> ] <i>jar-file alias</i>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <b>jarsigner</b> tool is used for two purposes:
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>to sign Java ARchive (JAR) files, and</dd>
  <dt>2.</dt>
  <dd>to verify the signatures and integrity of signed JAR files.</dd>
</dl>
<p class="Pp">The JAR feature enables the packaging of class files, images,
    sounds, and other digital data in a single file for faster and easier
    distribution. A tool named <b>jar</b> enables developers to produce JAR
    files.</p>
<p class="Pp">A digital signature is a string of bits that is computed from some
    data (the data being &quot;signed&quot;) and the private key of an entity (a
    person, company, etc.). Like a handwritten signature, a digital signature
    has many useful characteristics:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>Its authenticity can be verified, via a computation that uses the public
      key corresponding to the private key used to generate the signature.</dd>
  <dt>&#x2022;</dt>
  <dd>It cannot be forged, assuming the private key is kept secret.</dd>
  <dt>&#x2022;</dt>
  <dd>It is a function of the data signed and thus can't be claimed to be the
      signature for other data as well.</dd>
  <dt>&#x2022;</dt>
  <dd>The signed data cannot be changed; if it is, the signature will no longer
      verify as being authentic.</dd>
</dl>
<p class="Pp">In order for an entity's signature to be generated for a file, the
    entity must first have a public/private key pair associated with it, and
    also one or more certificates authenticating its public key. A certificate
    is a digitally signed statement from one entity, saying that the public key
    of some other entity has a particular value.</p>
<p class="Pp"><b>jarsigner</b> uses key and certificate information from a
    keystore to generate digital signatures for JAR files. A keystore is a
    database of private keys and their associated X.509 certificate chains
    authenticating the corresponding public keys. The <b>keytool</b> utility is
    used to create and administer keystores.</p>
<p class="Pp"><b>jarsigner</b> uses an entity's private key to generate a
    signature. The signed JAR file contains, among other things, a copy of the
    certificate from the keystore for the public key corresponding to the
    private key used to sign the file. <b>jarsigner</b> can verify the digital
    signature of the signed JAR file using the certificate inside it (in its
    signature block file).</p>
<p class="Pp">At this time, <b>jarsigner</b> can only sign JAR files created by
    the JDK <b>jar</b> tool or zip files. (JAR files are the same as zip files,
    except they also have a <b>META-INF/MANIFEST.MF</b> file. Such a file will
    automatically be created when <b>jarsigner</b> signs a zip file.)</p>
<p class="Pp">The default <b>jarsigner</b> behavior is to sign a JAR file. Use
    the <b>-verify</b> option to instead have it verify a signed JAR file.</p>
<section class="Ss">
<h2 class="Ss" id="Compatibility_with_JDK_1.1"><a class="permalink" href="#Compatibility_with_JDK_1.1">Compatibility
  with JDK 1.1</a></h2>
The <b>keytool</b> and <b>jarsigner</b> tools completely replace the
  <b>javakey</b> tool provided in JDK 1.1. These new tools provide more features
  than <b>javakey</b>, including the ability to protect the keystore and private
  keys with passwords, and the ability to verify signatures in addition to
  generating them.
<p class="Pp">The new keystore architecture replaces the identity database that
    <b>javakey</b> created and managed. There is no backwards compatibility
    between the keystore format and the database format used by <b>javakey</b>
    in 1.1. However:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>It is possible to import the information from an identity database into a
      keystore, via the <b>keytool -identitydb</b> command</dd>
  <dt>&#x2022;</dt>
  <dd><b>jarsigner</b> can sign JAR files also previously signed using
      <b>javakey</b></dd>
  <dt>&#x2022;</dt>
  <dd><b>jarsigner</b> can verify JAR files signed using <b>javakey</b> Thus, it
      recognizes and can work with signer aliases that are from a JDK 1.1
      identity database rather than a JDK 1.2 keystore.</dd>
</dl>
<p class="Pp">The following table explains how JAR files that were signed in JDK
    1.1.x are treated in the Java 2 Platform.</p>
<p class="Pp"></p>
<pre>
<b></b>
<b>                         Trusted</b>
<b>                        Identity</b>
<b>                        imported     Policy File</b>
<b>JAR File  Identity in   into 1.2       grants        Privileges</b>
<b>  Type   1.1 database   keystore    privileges to     Granted</b>
<b>                        from 1.1   Identity/Alias</b>
<b>                        database</b>
<b>                           (4)</b>
<b>Signed                                             Default</b>
<b>JAR      NO            NO         NO               privaleges</b>
<b>                                                   granted to</b>
<b>                                                   all code.</b>
<b>												   </b>
<b>Unsigned                                           Default</b>
<b>JAR      NO            NO         NO               privileges</b>
<b>                                                   granted to</b>
<b>                                                   all code.</b>
<b>Signed                                             Default</b>
<b>JAR      NO            YES        NO               privileges</b>
<b>                                                   granted to</b>
<b>                                                   all code.</b>
<b>Signed                                             Default</b>
<b>JAR      YES/Untrusted NO         NO               privileges</b>
<b>                                                   granted to</b>
<b>                                                   all code. (3)</b>
<b>Signed                                             Default</b>
<b>JAR      YES/Untrusted NO         YES              privileges</b>
<b>                                                   granted to</b>
<b>                                                   all code.</b>
<b>                                                   (1,3)</b>
<b>Signed                                             Default </b>
<b>JAR      NO            YES        YES              privileges</b>
<b>                                                   granted to</b>
<b>                                                   all code plus</b>
<b>                                                   privileges</b>
<b>                                                   granted in</b>
<b>                                                   policy file.</b>
<b>												   </b>
<b>Signed                                             Default </b>
<b>JAR      YES/Trusted   YES        YES              privileges</b>
<b>                                                   granted to</b>
<b>                                                   all code plus</b>
<b>                                                   privileges</b>
<b>                                                   granted in</b>
<b>                                                   policy file.</b>
<b>                                                   (2)</b>
<b>Signed                                             All</b>
<b>JAR      YES/Trusted   NO         NO               privileges</b>
<b>Signed                                             All</b>
<b>JAR      YES/Trusted   YES        NO               privileges</b>
<b>                                                   (1)</b>
<b>Signed                                             All</b>
<b>JAR      YES/Trusted   NO         YES              privileges</b>
<b>                                                   (1)</b>
</pre>
<p class="Pp">Notes:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>If an identity/alias is mentioned in the policy file, it must be imported
      into the keystore for the policy file to have any effect on privileges
      granted.</dd>
  <dt>1.</dt>
  <dd>If an identity/alias is mentioned in the policy file, it must be imported
      into the keystore for the policy file to have any effect on privileges
      granted.</dd>
  <dt>2.</dt>
  <dd>The policy file/keystore combination has precedence over a trusted
      identity in the identity database.</dd>
  <dt>3.</dt>
  <dd>Untrusted identities are ignored in the Java 2 platform.</dd>
  <dt>4.</dt>
  <dd>Only trusted identities can be imported into Java 2 SDK keystores.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Keystore_Aliases"><a class="permalink" href="#Keystore_Aliases">Keystore
  Aliases</a></h2>
All keystore entities are accessed via unique aliases.
<p class="Pp">When using <b>jarsigner</b> to sign a JAR file, you must specify
    the alias for the keystore entry containing the private key needed to
    generate the signature. For example, the following will sign the JAR file
    named <b>MyJARFile.jar</b>, using the private key associated with the alias
    <b>duke</b> in the keystore named <b>mystore</b> in the &quot;working&quot;
    directory. Since no output file is specified, it overwrites
    <b>MyJARFile.jar</b> with the signed JAR file.</p>
<p class="Pp"><b></b></p>
<pre>
jarsigner -keystore /working/mystore -storepass 
   myspass -keypass dukekeypasswd MyJARFile.jar duke
</pre>
<p class="Pp">Keystores are protected with a password, so the store password (in
    this case <b>myspass</b>) must be specified. You will be prompted for it if
    you don't specify it on the command line. Similarly, private keys are
    protected in a keystore with a password, so the private key's password (in
    this case <b>dukekeypasswd</b>) must be specified, and you will be prompted
    for it if you don't specify it on the command line and it isn't the same as
    the store password.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Keystore_Location"><a class="permalink" href="#Keystore_Location">Keystore
  Location</a></h2>
<b>jarsigner</b> has a <b>-keystore</b> option for specifying the name and
  location of the keystore to be used. The keystore is by default stored in a
  file named <b>.keystore</b> in the user's home directory, as determined by the
  <b>user.home</b> system property.
<p class="Pp">Note that the input stream from the -keystore option is passed to
    the <b>KeyStore.load</b> method. If NONE is specified as the URL, then a
    null stream is passed to the <b>KeyStore.load</b> method. NONE should be
    specified if the KeyStore is not file-based, for example, if it resides on a
    hardware token device.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Keystore_Implementation"><a class="permalink" href="#Keystore_Implementation">Keystore
  Implementation</a></h2>
The KeyStore class provided in the <b>java.security</b> package supplies
  well-defined interfaces to access and modify the information in a keystore. It
  is possible for there to be multiple different concrete implementations, where
  each implementation is that for a particular type of keystore.
<p class="Pp">Currently, there are two command-line tools that make use of
    <b>KeyStore</b>: <b>keytool</b> and <b>jarsigner</b>, and also a GUI-based
    tool named <b>policytool</b>. Since <b>KeyStore</b> is publicly available,
    JDK users can write additional security applications that use it.</p>
<p class="Pp">There is a built-in default implementation, provided by Sun
    Microsystems. It implements the keystore as a file, utilizing a proprietary
    keystore type (format) named &quot;JKS&quot;. It protects each private key
    with its individual password, and also protects the integrity of the entire
    keystore with a (possibly different) password.</p>
<p class="Pp">Keystore implementations are provider-based. More specifically,
    the application interfaces supplied by <b>KeyStore</b> are implemented in
    terms of a &quot;Service Provider Interface&quot; (SPI). That is, there is a
    corresponding abstract <b>KeystoreSpi</b> class, also in the
    <b>java.security</b> package, which defines the Service Provider Interface
    methods that &quot;providers&quot; must implement. (The term
    &quot;provider&quot; refers to a package or a set of packages that supply a
    concrete implementation of a subset of services that can be accessed by the
    Java Security API.) Thus, to provide a keystore implementation, clients must
    implement a provider and supply a <b>KeystoreSpi</b> subclass
    implementation, as described in <i>How to Implement a Provider for the Java
    Cryptography Architecture</i>.</p>
<p class="Pp">Applications can choose different types of keystore
    implementations from different providers, using the <b>getInstance</b>
    factory method supplied in the <b>KeyStore</b> class. A keystore type
    defines the storage and data format of the keystore information, and the
    algorithms used to protect private keys in the keystore and the integrity of
    the keystore itself. Keystore implementations of different types are not
    compatible.</p>
<p class="Pp"><b>keytool</b> works on any file-based keystore implementation.
    (It treats the keytore location that is passed to it at the command line as
    a filename and converts it to a <b>FileInputStream</b>, from which it loads
    the keystore information.) The <b>jarsigner</b> and <b>policytool</b> tools,
    on the other hand, can read a keystore from any location that can be
    specified using a URL.</p>
<p class="Pp">For <b>jarsigner</b> and <b>keytool</b>, you can specify a
    keystore type at the command line, via the <b>-storetype</b> option. For
    <b>policytool</b>, you can specify a keystore type via the &quot;Change
    Keystore&quot; command in the Edit menu.</p>
<p class="Pp">If you don't explicitly specify a keystore type, the tools choose
    a keystore implementation based simply on the value of the
    <b>keystore.type</b> property specified in the security properties file. The
    security properties file is called <b>java.security</b>, and it resides in
    the security properties directory, <b>java.home/lib/security</b>, where
    <b>java.home</b> is the runtime environment's directory (the jre directory
    in the SDK or the top-level directory of the Java 2 Runtime
  Environment).</p>
<p class="Pp">Each tool gets the <b>keystore.type</b> value and then examines
    all the currently-installed providers until it finds one that implements
    keystores of that type. It then uses the keystore implementation from that
    provider.</p>
<p class="Pp">The <b>KeyStore</b> class defines a static method named
    <b>getDefaultType</b> that lets applications and applets retrieve the value
    of the <b>keystore.type</b> property. The following line of code creates an
    instance of the default keystore type (as specified in the
    <b>keystore.type</b> property):</p>
<p class="Pp"></p>
<div class="Bd-indent"><b>KeyStore keyStore =
  KeyStore.getInstance(KeyStore.getDefaultType());</b></div>
<p class="Pp">The default keystore type is &quot;jks&quot; (the proprietary type
    of the keystore implementation provided by Sun). This is specified by the
    following line in the security properties file:</p>
<p class="Pp"></p>
<div class="Bd-indent"><b>keystore.type=jks</b></div>
<p class="Pp">To have the tools utilize a keystore implementation other than the
    default, change that line to specify a different keystore type.</p>
<p class="Pp">For example, if you have a provider package that supplies a
    keystore implementation for a keystore type called &quot;pkcs12&quot;,
    change the line to</p>
<p class="Pp"><b>keystore.type=pkcs12</b></p>
<p class="Pp">Note: case doesn't matter in keystore type designations. For
    example, &quot;JKS&quot; would be considered the same as
  &quot;jks&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Supported_Algorithms_and_Key_Sizes"><a class="permalink" href="#Supported_Algorithms_and_Key_Sizes">Supported
  Algorithms and Key Sizes</a></h2>
At this time, <b>jarsigner</b> can sign a JAR file using either
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>DSA (Digital Signature Algorithm) with the SHA-1 digest algorithm, or</dd>
  <dt>&#x2022;</dt>
  <dd>the RSA algorithm with the MD5 digest algorithm.</dd>
</dl>
<p class="Pp">That is, if the signer's public and private keys are DSA keys,
    <b>jarsigner</b> will attempt to sign the JAR file using the SHA-1/DSA
    algorithm. If the signer's keys are RSA keys, <b>jarsigner</b> will sign the
    JAR file using the MD5/RSA algorithm. This is only possible if there is a
    statically installed provider supplying an implementation for the MD5/RSA
    algorithm. (There is always a SHA-1/DSA algorithm available, from the
    default &quot;SUN&quot; provider.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_Signed_JAR_File"><a class="permalink" href="#The_Signed_JAR_File">The
  Signed JAR File</a></h2>
When <b>jarsigner</b> is used to sign a JAR file, the output signed JAR file is
  exactly the same as the input JAR file, except that it has two additional
  files placed in the <b>META-INF</b> directory:
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>a signature file, with a <b>.SF</b> extension, and</dd>
  <dt>&#x2022;</dt>
  <dd>a signature block file, with a <b>.DSA</b> extension.</dd>
</dl>
<p class="Pp">The base file names for these two files come from the value of the
    <b>-sigFile</b> option. For example, if the option appears as</p>
<p class="Pp"><b>-sigFile MKSIGN</b></p>
<p class="Pp">the files are named <b>MKSIGN.SF</b> and <b>MKSIGN.DSA</b>.</p>
<p class="Pp">If no <b>-sigfile</b> option appears on the command line, the base
    file name for the <b>.SF</b> and <b>.DSA</b> files will be the first 8
    characters of the alias name specified on the command line, all converted to
    upper case. If the alias name has fewer than 8 characters, the full alias
    name is used. If the alias name contains any characters that are not allowed
    in a signature file name, each such character is converted to an underscore
    (&quot;_&quot;) character in forming the file name. Legal characters include
    letters, digits, underscores, and hyphens.</p>
<p class="Pp">The Signature (<b>.SF</b>) File</p>
<p class="Pp">A signature file (the <b>.SF</b> file) looks similar to the
    manifest file that is always included in a JAR file generated by the
    <b>jar</b> tool. That is, for each source file included in the JAR file, the
    <b>.SF</b> file has three lines, just as in the manifest file, listing the
    following:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>the file name,</dd>
  <dt>&#x2022;</dt>
  <dd>the name of the digest algorithm used (SHA), and</dd>
  <dt>&#x2022;</dt>
  <dd>a SHA digest value.</dd>
</dl>
<p class="Pp">In the manifest file, the SHA digest value for each source file is
    the digest (hash) of the binary data in the source file. In the <b>.SF</b>
    file, on the other hand, the digest value for a given source file is the
    hash of the three lines in the manifest file for the source file.</p>
<p class="Pp">The signature file also, by default, includes a header containing
    a hash of the whole manifest file. The presence of the header enables
    verification optimization, as described in JAR File Verification.</p>
<p class="Pp">The Signature Block (<b>.DSA</b>) File</p>
<p class="Pp">The <b>.SF</b> file is signed and the signature is placed in the
    <b>.DSA</b> file. The <b>.DSA</b> file also contains, encoded inside it, a
    certificate authenticating the public key corresponding to the private key
    used for signing.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="JAR_File_Verification"><a class="permalink" href="#JAR_File_Verification">JAR
  File Verification</a></h2>
A successful JAR file verification occurs if the signature(s) are valid, and
  none of the files that were in the JAR file when the signatures were generated
  have been changed since then. JAR file verification involves the following
  steps:
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Verify the signature of the <b>.SF</b> file itself.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">That is, the verification ensures that the signature stored in
    each signature block (<b>.DSA</b>) file was in fact generated using the
    private key corresponding to the public key whose certificate also appears
    in the <b>.DSA</b> file. It also ensures that the signature is a valid
    signature of the corresponding signature (<b>.SF</b>) file, and thus the
    <b>.SF</b> file has not been tampered with.</p>
</div>
<dl class="Bl-tag">
  <dt>2.</dt>
  <dd>Verify the digest listed in each entry in the <b>.SF</b> file with each
      corresponding section in the manifest.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">The <b>.SF</b> file by default includes a header containing a hash
    of the entire manifest file. When the header is present, then the
    verification can check to see whether or not the hash in the header indeed
    matches the hash of the manifest file. If that is the case, verification
    proceeds to the next step.</p>
<p class="Pp">If that is not the case, a less optimized verification is required
    to ensure that the hash in each source file information section in the
    <b>.SF</b> file equals the hash of its corresponding section in the manifest
    file (see The Signature (<b>.SF</b>) File).</p>
<p class="Pp">One reason the hash of the manifest file that is stored in the
    <b>.SF</b> file header may not equal the hash of the current manifest file
    would be because one or more files were added to the JAR file (using the
    <b>jar</b> tool) after the signature (and thus the <b>.SF</b> file) was
    generated. When the <b>jar</b> tool is used to add files, the manifest file
    is changed (sections are added to it for the new files), but the <b>.SF</b>
    file is not. A verification is still considered successful if none of the
    files that were in the JAR file when the signature was generated have been
    changed since then, which is the case if the hashes in the non-header
    sections of the <b>.SF</b> file equal the hashes of the corresponding
    sections in the manifest file.</p>
</div>
<dl class="Bl-tag">
  <dt>3.</dt>
  <dd>Read each file in the JAR file that has an entry in the <b>.SF</b> file.
      While reading, compute the file's digest, and then compare the result with
      the digest for this file in the manifest section. The digests should be
      the same, or verification fails.</dd>
</dl>
<p class="Pp">If any serious verification failures occur during the verification
    process, the process is stopped and a security exception is thrown. It is
    caught and displayed by <b>jarsigner</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Multiple_Signatures_for_a_JAR_File"><a class="permalink" href="#Multiple_Signatures_for_a_JAR_File">Multiple
  Signatures for a JAR File</a></h2>
A JAR file can be signed by multiple people simply by running the
  <b>jarsigner</b> tool on the file multiple times, specifying the alias for a
  different person each time, as in:
<p class="Pp"><b></b></p>
<pre>
jarsigner myBundle.jar susan
jarsigner myBundle.jar kevin
</pre>
<p class="Pp">When a JAR file is signed multiple times, there are multiple
    <b>.SF</b> and <b>.DSA</b> files in the resulting JAR file, one pair for
    each signature. Thus, in the example above, the output JAR file includes
    files with the following names:</p>
<p class="Pp"><b></b></p>
<pre>
SUSAN.SF
SUSAN.DSA
KEVIN.SF
KEVIN.DSA
</pre>
<p class="Pp">Note: It is also possible for a JAR file to have mixed signatures,
    some generated by the JDK 1.1 javakey tool and others by jarsigner. That is,
    jarsigner can be used to sign JAR files already previously signed using
    javakey.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
The various <b>jarsigner</b> options are listed and described below. Note:
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>All option names are preceded by a minus sign (-).</dd>
  <dt>&#x2022;</dt>
  <dd>The options may be provided in any order.</dd>
  <dt>&#x2022;</dt>
  <dd>Items in italics (option values) represent the actual values that must be
      supplied.</dd>
  <dt>&#x2022;</dt>
  <dd>The <b>-keystore</b>, <b>-storepass</b>, <b>-keypass</b>, <b>-sigfile</b>,
      and <b>-signedjar</b> options are only relevant when signing a JAR file,
      not when verifying a signed JAR file. Similarly, an alias is only
      specified on the command line when signing a JAR file.</dd>
  <dt><b>-keystore</b><i> url</i></dt>
  <dd>Specifies the URL that tells the keystore location. This defaults to the
      file <b>.keystore</b> in the user's home directory, as determined by the
      <b>user.home</b> system property.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">A keystore is required when signing, so you must explicitly
    specify one if the default keystore does not exist (or you want to use one
    other than the default).</p>
<p class="Pp">A keystore is not required when verifying, but if one is
    specified, or the default exists, and the <b>-verbose</b> option was also
    specified, additional information is output regarding whether or not any of
    the certificates used to verify the JAR file are contained in that
  keystore.</p>
<p class="Pp">Note: the <b>-keystore</b> argument can actually be a file name
    (and path) specification rather than a URL, in which case it will be treated
    the same as a &quot;file:&quot; URL. That is,</p>
<p class="Pp"><b>-keystore filePathAndName</b></p>
<p class="Pp">is treated as equivalent to</p>
<p class="Pp"><b>-keystore file:filePathAndName</b></p>
</div>
<dl class="Bl-tag">
  <dt><b>-storetype</b><i> storetype</i></dt>
  <dd>Specifies the type of keystore to be instantiated. The default keystore
      type is the one that is specified as the value of the
      &quot;keystore.type&quot; property in the security properties file, which
      is returned by the static <b>getDefaultType</b> method in
      <b>java.security.KeyStore</b>.</dd>
  <dt><b>-storepass</b><i> password</i></dt>
  <dd>Specifies the password which is required to access the keystore. This is
      only needed when signing (not verifying) a JAR file. In that case, if a
      <b>-storepass</b> option is not provided at the command line, the user is
      prompted for the password.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">Note: The password shouldn't be specified on the command line or
    in a script unless it is for testing purposes, or you are on a secure
    system. Also, when typing in a password at the password prompt, the password
    is echoed (displayed exactly as typed), so be careful not to type it in
    front of anyone.</p>
</div>
<dl class="Bl-tag">
  <dt><b>-keypass</b><i> password</i></dt>
  <dd>Specifies the password used to protect the private key of the keystore
      entry addressed by the alias specified on the command line. The password
      is required when using <b>jarsigner</b> to sign a JAR file. If no password
      is provided on the command line, and the required password is different
      from the store password, the user is prompted for it.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">Note: The password shouldn't be specified on the command line or
    in a script unless it is for testing purposes, or you are on a secure
    system. Also, when typing in a password at the password prompt, the password
    is echoed (displayed exactly as typed), so be careful not to type it in
    front of anyone.</p>
</div>
<dl class="Bl-tag">
  <dt><b>-sigfile</b><i> file</i></dt>
  <dd>Specifies the base file name to be used for the generated <b>.SF</b> and
      <b>.DSA</b> files. For example, if file is <b>DUKESIGN</b>, the generated
      <b>.SF</b> and <b>.DSA</b> files will be named <b>DUKESIGN.SF</b> and
      <b>DUKESIGN.DSA</b>, and will be placed in the <b>META-INF</b> directory
      of the signed JAR file.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">The characters in file must come from the set
    &quot;a-zA-Z0-9_-&quot;. That is, only letters, numbers, underscore, and
    hyphen characters are allowed. Note: All lowercase characters will be
    converted to uppercase for the <b>.SF</b> and <b>.DSA</b> file names.</p>
<p class="Pp">If no <b>-sigfile</b> option appears on the command line, the base
    file name for the <b>.SF</b> and <b>.DSA</b> files will be the first 8
    characters of the alias name specified on the command line, all converted to
    upper case. If the alias name has fewer than 8 characters, the full alias
    name is used. If the alias name contains any characters that are not legal
    in a signature file name, each such character is converted to an underscore
    (&quot;_&quot;) character in forming the file name.</p>
</div>
<dl class="Bl-tag">
  <dt><b>-signedjar</b><i> file</i></dt>
  <dd>Specifies the name to be used for the signed JAR file.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">If no name is specified on the command line, the name used is the
    same as the input JAR file name (the name of the JAR file to be signed); in
    other words, that file is overwritten with the signed JAR file.</p>
</div>
<dl class="Bl-tag">
  <dt><b>-verify</b></dt>
  <dd>If this appears on the command line, the specified JAR file will be
      verified, not signed. If the verification is successful, &quot;jar
      verified&quot; will be displayed. If you try to verify an unsigned JAR
      file, or a JAR file signed with an unsupported algorithm (for example, RSA
      when you don't have an RSA provider installed), the following is
      displayed: &quot;jar is unsigned. (signatures missing or not
      parsable)&quot;</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">It is possible to verify JAR files signed using either
    <b>jarsigner</b> or the JDK 1.1 <b>javakey</b> tool, or both.</p>
<p class="Pp">For further information on verification, see JAR File
    Verification.</p>
</div>
<dl class="Bl-tag">
  <dt><b>-certs</b></dt>
  <dd>If this appears on the command line, along with the <b>-verify</b> and
      <b>-verbose</b> options, the output includes certificate information for
      each signer of the JAR file. This information includes:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>the name of the type of certificate (stored in the <b>.DSA</b> file) that
      certifies the signer's public key</dd>
  <dt>&#x2022;</dt>
  <dd>if the certificate is an X.509 certificate (more specifically, an instance
      of java.security.cert.X509Certificate): the distinguished name of the
      signer</dd>
</dl>
<p class="Pp">The keystore is also examined. If no keystore value is specified
    on the command line, the default keystore file (if any) will be checked. If
    the public key certificate for a signer matches an entry in the keystore,
    then the following information will also be displayed:</p>
<dl class="Bl-tag">
  <dt>&#x2022;</dt>
  <dd>in parentheses, the alias name for the keystore entry for that signer. If
      the signer actually comes from a JDK 1.1 identity database instead of from
      a keystore, the alias name will appear in brackets instead of
    parentheses.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>-verbose</b></dt>
  <dd>If this appears on the command line, it indicates &quot;verbose&quot;
      mode, which causes <b>jarsigner</b> to output extra information as to the
      progress of the JAR signing or verification.</dd>
  <dt><b>-internalsf</b></dt>
  <dd>In the past, the <b>.DSA</b> (signature block) file generated when a JAR
      file was signed used to include a complete encoded copy of the <b>.SF</b>
      file (signature file) also generated. This behavior has been changed. To
      reduce the overall size of the output JAR file, the <b>.DSA</b> file by
      default doesn't contain a copy of the <b>.SF</b> file anymore. But if
      <b>-internalsf</b> appears on the command line, the old behavior is
      utilized. This option is mainly useful for testing; in practice, it should
      not be used, since doing so eliminates a useful optimization.</dd>
  <dt><b>-sectionsonly</b></dt>
  <dd>If this appears on the command line, the <b>.SF</b> file (signature file)
      generated when a JAR file is signed does not include a header containing a
      hash of the whole manifest file. It just contains information and hashes
      related to each individual source file included in the JAR file, as
      described in The Signature (<b>.SF</b>) File .</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">By default, this header is added, as an optimization. When the
    header is present, then whenever the JAR file is verified, the verification
    can first check to see whether or not the hash in the header indeed matches
    the hash of the whole manifest file. If so, verification proceeds to the
    next step. If not, it is necessary to do a less optimized verification that
    the hash in each source file information section in the <b>.SF</b> file
    equals the hash of its corresponding section in the manifest file.</p>
<p class="Pp">For further information, see JAR File Verification.</p>
<p class="Pp">This option is mainly useful for testing; in practice, it should
    not be used, since doing so eliminates a useful optimization.</p>
</div>
<dl class="Bl-tag">
  <dt><b>-provider</b><i> provider_class_name</i></dt>
  <dd>Used to specify the name of the cryptographic service provider's master
      class file when the service provider is not listed in the security
      properties file.</dd>
  <dt><b>-J</b><i>javaoption</i></dt>
  <dd>Passes the specified javaoption string directly to the runtime system.
      (<b>jarsigner</b> is actually a &quot;wrapper&quot; around the
      interpreter.) This option should not contain any spaces. It is useful for
      adjusting the execution environment or memory usage. For a list of
      possible flags, type <b>java -h</b> or <b>java -X</b> at the command
    line.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Signing_a_JAR_File"><a class="permalink" href="#Signing_a_JAR_File">Signing
  a JAR File</a></h2>
Suppose you have a JAR file named <b>bundle.jar</b> and you'd like to sign it
  using the private key of the user whose keystore alias is &quot;jane&quot; in
  the keystore named &quot;mystore&quot; in the &quot;working&quot; directory.
  Suppose the keystore password is &quot;myspass&quot; and the password for
  jane's private key is &quot;j638klm&quot;. You can use the following to sign
  the JAR file and name the signed JAR file &quot;sbundle.jar&quot;:
<p class="Pp"><b></b></p>
<pre>
jarsigner -keystore &quot;/working/mystore&quot; -storepass myspass
   -keypass j638klm -signedjar sbundle.jar bundle.jar jane
</pre>
<p class="Pp">Note that there is no <b>-sigfile</b> specified in the command
    above, so the generated <b>.SF</b> and <b>.DSA</b> files to be placed in the
    signed JAR file will have default names based on the alias name. That is,
    they will be named <b>JANE.SF</b> and <b>JANE.DSA</b>.</p>
<p class="Pp">If you want to be prompted for the store password and the private
    key password, you could shorten the above command to</p>
<p class="Pp"><b></b></p>
<pre>
jarsigner -keystore /working/mystore
   -signedjar sbundle.jar bundle.jar jane
</pre>
<p class="Pp">If the keystore to be used is the default keystore (the one named
    <b>.keystore</b> in your home directory), you don't need to specify a
    keystore, as in:</p>
<p class="Pp"><b></b></p>
<pre>
jarsigner -signedjar sbundle.jar bundle.jar jane
</pre>
<p class="Pp">Finally, if you want the signed JAR file to simply overwrite the
    input JAR file (bundle.jar), you don't need to specify a <b>-signedjar</b>
    option:</p>
<p class="Pp"><b></b></p>
<pre>
jarsigner bundle.jar jane
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Verifying_a_Signed_JAR_File"><a class="permalink" href="#Verifying_a_Signed_JAR_File">Verifying
  a Signed JAR File</a></h2>
To verify a signed JAR file, that is, to verify that the signature is valid and
  the JAR file has not been tampered with, use a command such as the following:
<p class="Pp"><b></b></p>
<pre>
jarsigner -verify sbundle.jar
</pre>
<p class="Pp">If the verification is successful,</p>
<p class="Pp"><b></b></p>
<pre>
jar verified.
</pre>
<p class="Pp">is displayed. Otherwise, an error message appears.</p>
<p class="Pp">You can get more information if you use the <b>-verbose</b>
    option. A sample use of <b>jarsigner</b> with the <b>-verbose</b> option is
    shown below, along with sample output:</p>
<p class="Pp"><b></b></p>
<pre>
jarsigner -verify -verbose sbundle.jar
             198 Fri Sep 26 16:14:06 PDT 1997 META-INF/MANIFEST.MF
             199 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.SF
            1013 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.DSA
      smk   2752 Fri Sep 26 16:12:30 PDT 1997 AclEx.class
      smk    849 Fri Sep 26 16:12:46 PDT 1997 test.class
        s = signature was verified
        m = entry is listed in manifest
        k = at least one certificate was found in keystore
      jar verified.
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Verification_with_Certificate_Information"><a class="permalink" href="#Verification_with_Certificate_Information">Verification
  with Certificate Information</a></h2>
If you specify the <b>-certs</b> option when verifying, along with the
  <b>-verify</b> and <b>-verbose</b> options, the output includes certificate
  information for each signer of the JAR file, including the certificate type,
  the signer distinguished name information (if it's an X.509 certificate), and,
  in parentheses, the keystore alias for the signer if the public key
  certificate in the JAR file matches that in a keystore entry. For example,
<p class="Pp"><b></b></p>
<pre>
example% jarsigner -keystore /working/mystore -verify -verbose -certs myTest.jar
      198 Fri Sep 26 16:14:06 PDT 1997 META-INF/MANIFEST.MF
      199 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.SF
     1013 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.DSA
      208 Fri Sep 26 16:23:30 PDT 1997 META-INF/JAVATEST.SF
     1087 Fri Sep 26 16:23:30 PDT 1997 META-INF/JAVATEST.DSA
smk   2752 Fri Sep 26 16:12:30 PDT 1997 Tst.class
 X.509, CN=Test Group, OU=Java Software, O=Sun Microsystems, L=CUP, S=CA, C=US (javatest)
 X.509, CN=Jane Smith, OU=Java Software, O=Sun, L=cup, S=ca, C=us (jane)
 s = signature was verified
 m = entry is listed in manifest
 k = at least one certificate was found in keystore
jar verified.
</pre>
<p class="Pp">If the certificate for a signer is not an X.509 certificate, there
    is no distinguished name information. In that case, just the certificate
    type and the alias are shown. For example, if the certificate is a PGP
    certificate, and the alias is &quot;bob&quot;, you'd get</p>
<p class="Pp"><b></b></p>
<pre>
PGP, (bob)
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Verification_of_a_JAR_File_that_Includes_Idnetity_Database_Signers"><a class="permalink" href="#Verification_of_a_JAR_File_that_Includes_Idnetity_Database_Signers">Verification
  of a JAR File that Includes Idnetity Database Signers</a></h2>
If a JAR file has been signed using the JDK 1.1 <b>javakey</b> tool, and thus
  the signer is an alias in an identity database, the verification output
  includes an &quot;i&quot; symbol. If the JAR file has been signed by both an
  alias in an identity database and an alias in a keystore, both &quot;k&quot;
  and &quot;i&quot; appear.
<p class="Pp">When the <b>-certs</b> option is used, any identity database
    aliases are shown in square brackets rather than the parentheses used for
    keystore aliases. For example:</p>
<p class="Pp"><b></b></p>
<pre>
jarsigner -keystore /working/mystore -verify -verbose -certs writeFile.jar
      198 Fri Sep 26 16:14:06 PDT 1997 META-INF/MANIFEST.MF
      199 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.SF
     1013 Fri Sep 26 16:22:10 PDT 1997 META-INF/JANE.DSA
      199 Fri Sep 27 12:22:30 PDT 1997 META-INF/DUKE.SF
     1013 Fri Sep 27 12:22:30 PDT 1997 META-INF/DUKE.DSA
smki   2752 Fri Sep 26 16:12:30 PDT 1997 writeFile.html
 X.509, CN=Jane Smith, OU=Java Software, O=Sun, L=cup, S=ca, C=us (jane)
 X.509, CN=Duke, OU=Java Software, O=Sun, L=cup, S=ca, C=us [duke]
 s = signature was verified
 m = entry is listed in manifest
 k = at least one certificate was found in keystore
 i = at least one certificate was found in identity scope
jar verified.
</pre>
<p class="Pp">Note that the alias &quot;duke&quot; is in brackets to denote that
    it is an identity database alias, not a keystore alias.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>jar</b>(1), <b>keytool</b>(1)
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">23 Jun 2004</td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
