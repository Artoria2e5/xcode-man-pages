<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2003 Donal K. Fellows
  
   See the file "license.terms" for information on usage and redistribution
   of this file, and for a DISCLAIMER OF ALL WARRANTIES.
  
   RCS: @(#) $Id: dict.n,v 1.18.2.2 2010/08/29 15:40:57 dkf Exp $
  
   The -*- nroff -*- definitions below are for supplemental macros used
   in Tcl/Tk manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO ?manpage?
  	Start of list of standard options for a Tk widget. The manpage
  	argument defines where to look up the standard options; if
  	omitted, defaults to "options". The options follow on successive
  	lines, in three columns separated by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   .QW arg1 ?arg2?
  	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
  
   .PQ arg1 ?arg2?
  	Print an open parenthesis, arg1 in quotes, then arg2 normally
  	(for trailing punctuation) and then a closing parenthesis.
  
   RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
  	# Start an argument description
  .b
  	# define tabbing values for .AP
  
  	# BS - start boxed text
  	# ^y = starting y location
  	# ^b = 1
  	# BE - end boxed text (draw box now)
  	Draw four-sided box normally, but don't draw top of
  	box if the box started on an earlier page.
  	# VS - start vertical sidebar
  	# ^Y = starting y location
  	# ^v = 1 (for troff;  for nroff this doesn't matter)
  	# VE - end of vertical sidebar
  	# Special macro to handle page bottom:  finish off current
  	# box/sidebar if in box/sidebar mode, then invoked standard
  	# page bottom macro.
  	Draw three-sided box if this is the box's first page,
  	draw two sides but no top otherwise.
  	# DS - begin display
  	# DE - end display
  	# SO - start of list of standard options
  	# SE - end of list of standard options
  	# OP - start of full description for a single option
  	# CS - begin code excerpt
  	# CE - end code excerpt
  	# UL - underline word
  	# QW - apply quotation marks to word
  " fix emacs highlighting
  	# PQ - apply parens and quotation marks to word
  " fix emacs highlighting
  	# QR - quoted range
  " fix emacs highlighting
  	# MT - "empty" string
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>dict(n)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">dict(n)</td>
    <td class="head-vol">Tcl Built-In Commands</td>
    <td class="head-rtitle">dict(n)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
dict - Manipulate dictionaries
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>dict </b><i>option arg </i>?<i>arg ...</i>?
<pre>

</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Performs one of several operations on dictionary values or variables containing
  dictionary values (see the <b>DICTIONARY VALUES</b> section below for a
  description), depending on <i>option</i>. The legal <i>option</i>s (which may
  be abbreviated) are:
<dl class="Bl-tag">
  <dt><b>dict append </b><i>dictionaryVariable key </i>?<i>string ...</i>?</dt>
  <dd>This appends the given string (or strings) to the value that the given key
      maps to in the dictionary value contained in the given variable, writing
      the resulting dictionary value back to that variable. Non-existent keys
      are treated as if they map to an empty string.</dd>
  <dt><b>dict create </b>?<i>key value ...</i>?</dt>
  <dd>Create a new dictionary that contains each of the key/value mappings
      listed as arguments (keys and values alternating, with each key being
      followed by its associated value.)</dd>
  <dt><b>dict exists </b><i>dictionaryValue key </i>?<i>key ...</i>?</dt>
  <dd>This returns a boolean value indicating whether the given key (or path of
      keys through a set of nested dictionaries) exists in the given dictionary
      value. This returns a true value exactly when <b>dict</b> <b>get</b> on
      that path will succeed.</dd>
  <dt><b>dict filter </b><i>dictionaryValue filterType arg </i>?<i>arg
    ...</i>?</dt>
  <dd>This takes a dictionary value and returns a new dictionary that contains
      just those key/value pairs that match the specified filter type (which may
      be abbreviated.) Supported filter types are:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>dict filter </b><i>dictionaryValue </i><b>key
    </b><i>globPattern</i></dt>
  <dd>The key rule only matches those key/value pairs whose keys match the given
      pattern (in the style of <b>string match</b>.)</dd>
  <dt><b>dict filter </b><i>dictionaryValue </i><b>script {</b><i>keyVar
    valueVar</i><b>} </b><i>script</i></dt>
  <dd>The script rule tests for matching by assigning the key to the
      <i>keyVar</i> and the value to the <i>valueVar</i>, and then evaluating
      the given script which should return a boolean value (with the key/value
      pair only being included in the result of the <b>dict</b> <b>filter</b>
      when a true value is returned.) Note that the first argument after the
      rule selection word is a two-element list. If the <i>script</i> returns
      with a condition of <b>TCL_BREAK</b>, no further key/value pairs are
      considered for inclusion in the resulting dictionary, and a condition of
      <b>TCL_CONTINUE</b> is equivalent to a false result. The key/value pairs
      are tested in the order in which the keys were inserted into the
      dictionary.</dd>
  <dt><b>dict filter </b><i>dictionaryValue </i><b>value
    </b><i>globPattern</i></dt>
  <dd>The value rule only matches those key/value pairs whose values match the
      given pattern (in the style of <b>string match</b>.)</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>dict for {</b><i>keyVar valueVar</i><b>} </b><i>dictionaryValue
    body</i></dt>
  <dd>This command takes three arguments, the first a two-element list of
      variable names (for the key and value respectively of each mapping in the
      dictionary), the second the dictionary value to iterate across, and the
      third a script to be evaluated for each mapping with the key and value
      variables set appropriately (in the manner of <b>foreach</b>.) The result
      of the command is an empty string. If any evaluation of the body generates
      a <b>TCL_BREAK</b> result, no further pairs from the dictionary will be
      iterated over and the <b>dict for</b> command will terminate successfully
      immediately. If any evaluation of the body generates a <b>TCL_CONTINUE</b>
      result, this shall be treated exactly like a normal <b>TCL_OK</b> result.
      The order of iteration is the order in which the keys were inserted into
      the dictionary.</dd>
  <dt><b>dict get </b><i>dictionaryValue </i>?<i>key ...</i>?</dt>
  <dd>Given a dictionary value (first argument) and a key (second argument),
      this will retrieve the value for that key. Where several keys are
      supplied, the behaviour of the command shall be as if the result of
      <b>dict get $dictVal $key</b> was passed as the first argument to <b>dict
      get</b> with the remaining arguments as second (and possibly subsequent)
      arguments. This facilitates lookups in nested dictionaries. For example,
      the following two commands are equivalent:</dd>
</dl>
<div class="Bd-indent">
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
dict get $dict foo bar spong
dict get [dict get [dict get $dict foo] bar] spong
</pre>
</div>
<p class="Pp">If no keys are provided, <b>dict get</b> will return a list
    containing pairs of elements in a manner similar to <b>array get</b>. That
    is, the first element of each pair would be the key and the second element
    would be the value for that key.</p>
<p class="Pp">It is an error to attempt to retrieve a value for a key that is
    not present in the dictionary.</p>
</div>
<dl class="Bl-tag">
  <dt><b>dict incr </b><i>dictionaryVariable key </i>?<i>increment</i>?</dt>
  <dd>This adds the given increment value (an integer that defaults to 1 if not
      specified) to the value that the given key maps to in the dictionary value
      contained in the given variable, writing the resulting dictionary value
      back to that variable. Non-existent keys are treated as if they map to 0.
      It is an error to increment a value for an existing key if that value is
      not an integer.</dd>
  <dt><b>dict info </b><i>dictionaryValue</i></dt>
  <dd>This returns information (intended for display to people) about the given
      dictionary though the format of this data is dependent on the
      implementation of the dictionary. For dictionaries that are implemented by
      hash tables, it is expected that this will return the string produced by
      <b>Tcl_HashStats</b>, similar to <b>array statistics</b>.</dd>
  <dt><b>dict keys </b><i>dictionaryValue </i>?<i>globPattern</i>?</dt>
  <dd>Return a list of all keys in the given dictionary value. If a pattern is
      supplied, only those keys that match it (according to the rules of
      <b>string match</b>) will be returned. The returned keys will be in the
      order that they were inserted into the dictionary.</dd>
  <dt><b>dict lappend </b><i>dictionaryVariable key </i>?<i>value ...</i>?</dt>
  <dd>This appends the given items to the list value that the given key maps to
      in the dictionary value contained in the given variable, writing the
      resulting dictionary value back to that variable. Non-existent keys are
      treated as if they map to an empty list, and it is legal for there to be
      no items to append to the list. It is an error for the value that the key
      maps to to not be representable as a list.</dd>
  <dt><b>dict merge </b>?<i>dictionaryValue ...</i>?</dt>
  <dd>Return a dictionary that contains the contents of each of the
      <i>dictionaryValue</i> arguments. Where two (or more) dictionaries contain
      a mapping for the same key, the resulting dictionary maps that key to the
      value according to the last dictionary on the command line containing a
      mapping for that key.</dd>
  <dt><b>dict remove </b><i>dictionaryValue </i>?<i>key ...</i>?</dt>
  <dd>Return a new dictionary that is a copy of an old one passed in as first
      argument except without mappings for each of the keys listed. It is legal
      for there to be no keys to remove, and it also legal for any of the keys
      to be removed to not be present in the input dictionary in the first
      place.</dd>
  <dt><b>dict replace </b><i>dictionaryValue </i>?<i>key value ...</i>?</dt>
  <dd>Return a new dictionary that is a copy of an old one passed in as first
      argument except with some values different or some extra key/value pairs
      added. It is legal for this command to be called with no key/value pairs,
      but illegal for this command to be called with a key but no value.</dd>
  <dt><b>dict set </b><i>dictionaryVariable key </i>?<i>key ...</i>?
    <i>value</i></dt>
  <dd>This operation takes the name of a variable containing a dictionary value
      and places an updated dictionary value in that variable containing a
      mapping from the given key to the given value. When multiple keys are
      present, this operation creates or updates a chain of nested
    dictionaries.</dd>
  <dt><b>dict size </b><i>dictionaryValue</i></dt>
  <dd>Return the number of key/value mappings in the given dictionary
    value.</dd>
  <dt><b>dict unset </b><i>dictionaryVariable key </i>?<i>key ...</i>?</dt>
  <dd>This operation (the companion to <b>dict set</b>) takes the name of a
      variable containing a dictionary value and places an updated dictionary
      value in that variable that does not contain a mapping for the given key.
      Where multiple keys are present, this describes a path through nested
      dictionaries to the mapping to remove. At least one key must be specified,
      but the last key on the key-path need not exist. All other components on
      the path must exist.</dd>
  <dt><b>dict update </b><i>dictionaryVariable key varName </i>?<i>key varName
    ...</i>? <i>body</i></dt>
  <dd>Execute the Tcl script in <i>body</i> with the value for each <i>key</i>
      (as found by reading the dictionary value in <i>dictionaryVariable</i>)
      mapped to the variable <i>varName</i>. There may be multiple
      <i>key</i>/<i>varName</i> pairs. If a <i>key</i> does not have a mapping,
      that corresponds to an unset <i>varName</i>. When <i>body</i> terminates,
      any changes made to the <i>varName</i>s is reflected back to the
      dictionary within <i>dictionaryVariable</i> (unless
      <i>dictionaryVariable</i> itself becomes unreadable, when all updates are
      silently discarded), even if the result of <i>body</i> is an error or some
      other kind of exceptional exit. The result of <b>dict</b> <b>update</b> is
      (unless some kind of error occurs) the result of the evaluation of
      <i>body</i>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">Each <i>varName</i> is mapped in the scope enclosing the <b>dict
    update</b>; it is recommended that this command only be used in a local
    scope (<b>proc</b>edure or lambda term for <b>apply</b>). Because of this,
    the variables set by <b>dict update</b> will continue to exist after the
    command finishes (unless explicitly <b>unset</b>). Note that the mapping of
    values to variables does not use traces; changes to the
    <i>dictionaryVariable</i>'s contents only happen when <i>body</i>
    terminates.</p>
</div>
<dl class="Bl-tag">
  <dt><b>dict values </b><i>dictionaryValue </i>?<i>globPattern</i>?</dt>
  <dd>Return a list of all values in the given dictionary value. If a pattern is
      supplied, only those values that match it (according to the rules of
      <b>string match</b>) will be returned. The returned values will be in the
      order of that the keys associated with those values were inserted into the
      dictionary.</dd>
  <dt><b>dict with </b><i>dictionaryVariable </i>?<i>key ...</i>?
    <i>body</i></dt>
  <dd>Execute the Tcl script in <i>body</i> with the value for each key in
      <i>dictionaryVariable</i> mapped (in a manner similarly to <b>dict</b>
      <b>update</b>) to a variable with the same name. Where one or more
      <i>key</i>s are available, these indicate a chain of nested dictionaries,
      with the innermost dictionary being the one opened out for the execution
      of <i>body</i>. As with <b>dict update</b>, making
      <i>dictionaryVariable</i> unreadable will make the updates to the
      dictionary be discarded, and this also happens if the contents of
      <i>dictionaryVariable</i> are adjusted so that the chain of dictionaries
      no longer exists. The result of <b>dict with</b> is (unless some kind of
      error occurs) the result of the evaluation of <i>body</i>.</dd>
</dl>
<div class="Bd-indent">
<p class="Pp">The variables are mapped in the scope enclosing the <b>dict
    with</b>; it is recommended that this command only be used in a local scope
    (<b>proc</b>edure or lambda term for <b>apply</b>). Because of this, the
    variables set by <b>dict with</b> will continue to exist after the command
    finishes (unless explicitly <b>unset</b>). Note that the mapping of values
    to variables does not use traces; changes to the <i>dictionaryVariable</i>'s
    contents only happen when <i>body</i> terminates.</p>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="DICTIONARY_VALUES"><a class="permalink" href="#DICTIONARY_VALUES">DICTIONARY
  VALUES</a></h1>
Dictionaries are values that contain an efficient, order-preserving mapping from
  arbitrary keys to arbitrary values. Each key in the dictionary maps to a
  single value. They have a textual format that is exactly that of any list with
  an even number of elements, with each mapping in the dictionary being
  represented as two items in the list. When a command takes a dictionary and
  produces a new dictionary based on it (either returning it or writing it back
  into the variable that the starting dictionary was read from) the new
  dictionary will have the same order of keys, modulo any deleted keys and with
  new keys added on to the end. When a string is interpreted as a dictionary and
  it would otherwise have duplicate keys, only the last value for a particular
  key is used; the others are ignored, meaning that, &#x201C;apple
  banana&#x201D; and &#x201C;apple carrot apple banana&#x201D; are equivalent
  dictionaries (with different string representations).
<p class="Pp">Operations that derive a new dictionary from an old one (e.g.,
    updates like <b>dict set</b> and <b>dict unset</b>) preserve the order of
    keys in the dictionary. The exceptions to this are for any new keys they
    add, which are appended to the sequence, and any keys that are removed,
    which are excised from the order.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
Basic dictionary usage:
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
# Make a dictionary to map extensions to descriptions
set filetypes [<b>dict create</b> .txt &quot;Text File&quot; .tcl &quot;Tcl File&quot;]
# Add/update the dictionary
<b>dict set</b> filetypes .tcl &quot;Tcl Script&quot;
<b>dict set</b> filetypes .tm  &quot;Tcl Module&quot;
<b>dict set</b> filetypes .gif &quot;GIF Image&quot;
<b>dict set</b> filetypes .png &quot;PNG Image&quot;
# Simple read from the dictionary
set ext &quot;.tcl&quot;
set desc [<b>dict get</b> $filetypes $ext]
puts &quot;$ext is for a $desc&quot;
# Somewhat more complex, with existence test
foreach filename [glob *] {
    set ext [file extension $filename]
    if {[<b>dict exists</b> $filetypes $ext]} {
        puts &quot;$filename is a [<b>dict get</b> $filetypes $ext]&quot;
    }
}
</pre>
</div>
<p class="Pp">Constructing and using nested dictionaries:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
# Data for one employee
<b>dict set</b> employeeInfo 12345-A forenames &quot;Joe&quot;
<b>dict set</b> employeeInfo 12345-A surname   &quot;Schmoe&quot;
<b>dict set</b> employeeInfo 12345-A street &quot;147 Short Street&quot;
<b>dict set</b> employeeInfo 12345-A city   &quot;Springfield&quot;
<b>dict set</b> employeeInfo 12345-A phone  &quot;555-1234&quot;
# Data for another employee
<b>dict set</b> employeeInfo 98372-J forenames &quot;Anne&quot;
<b>dict set</b> employeeInfo 98372-J surname   &quot;Other&quot;
<b>dict set</b> employeeInfo 98372-J street &quot;32995 Oakdale Way&quot;
<b>dict set</b> employeeInfo 98372-J city   &quot;Springfield&quot;
<b>dict set</b> employeeInfo 98372-J phone  &quot;555-8765&quot;
# The above data probably ought to come from a database...
# Print out some employee info
set i 0
puts &quot;There are [<b>dict size</b> $employeeInfo] employees&quot;
<b>dict for</b> {id info} $employeeInfo {
   puts &quot;Employee #[incr i]: $id&quot;
   <b>dict with</b> info {
      puts &quot;   Name: $forenames $surname&quot;
      puts &quot;   Address: $street, $city&quot;
      puts &quot;   Telephone: $phone&quot;
   }
}
# Another way to iterate and pick out names...
foreach id [<b>dict keys</b> $employeeInfo] {
   puts &quot;Hello, [<b>dict get</b> $employeeInfo $id forenames]!&quot;
}
</pre>
</div>
<p class="Pp">A localizable version of <b>string toupper</b>:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
# Set up the basic C locale
set capital [<b>dict create</b> C [<b>dict create</b>]]
foreach c [split {abcdefghijklmnopqrstuvwxyz} &quot;&quot;] {
   <b>dict set</b> capital C $c [string toupper $c]
}
# English locales can luckily share the &quot;C&quot; locale
<b>dict set</b> capital en [<b>dict get</b> $capital C]
<b>dict set</b> capital en_US [<b>dict get</b> $capital C]
<b>dict set</b> capital en_GB [<b>dict get</b> $capital C]
# ... and so on for other supported languages ...
# Now get the mapping for the current locale and use it.
set upperCaseMap [<b>dict get</b> $capital $env(LANG)]
set upperCase [string map $upperCaseMap $string]
</pre>
</div>
<p class="Pp">Showing the detail of <b>dict with</b>:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>
proc sumDictionary {varName} {
   upvar 1 $varName vbl
   foreach key [<b>dict keys</b> $vbl] {
      # Manufacture an entry in the subdictionary
      <b>dict set</b> vbl $key total 0
      # Add the values and remove the old
      <b>dict with</b> vbl $key {
         set total [expr {$x + $y + $z}]
         unset x y z
      }
   }
   puts &quot;last total was $total, for key $key&quot;
}
set myDict {
   a {x 1 y 2 z 3}
   b {x 6 y 5 z 4}
}
sumDictionary myDict
#    prints: <i>last total was 15, for key b</i>
puts &quot;dictionary is now \&quot;$myDict\&quot;&quot;
#    prints: <i>dictionary is now &quot;a {total 6} b {total 15}&quot;</i>
</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
append(n), array(n), foreach(n), incr(n), list(n), lappend(n), set(n)
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
dictionary, create, update, lookup, iterate, filter
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">8.5</td>
    <td class="foot-os">Tcl</td>
  </tr>
</table>
</body>
</html>
