<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Text::ParseWords(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Text::ParseWords(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Text::ParseWords(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Text::ParseWords - parse text into an array of tokens or array of arrays
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use Text::ParseWords;
  @lists = nested_quotewords($delim, $keep, @lines);
  @words = quotewords($delim, $keep, @lines);
  @words = shellwords(@lines);
  @words = parse_line($delim, $keep, $line);
  @words = old_shellwords(@lines); # DEPRECATED!
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The &amp;<i>nested_quotewords()</i> and &amp;<i>quotewords()</i> functions
  accept a delimiter (which can be a regular expression) and a list of lines and
  then breaks those lines up into a list of words ignoring delimiters that
  appear inside quotes. &amp;<i>quotewords()</i> returns all of the tokens in a
  single long list, while &amp;<i>nested_quotewords()</i> returns a list of
  token lists corresponding to the elements of <span class="Li">@lines</span>.
  &amp;<i>parse_line()</i> does tokenizing on a single string. The
  &amp;*<i>quotewords()</i> functions simply call &amp;<i>parse_line()</i>, so
  if you're only splitting one line you can call &amp;<i>parse_line()</i>
  directly and save a function call.
<p class="Pp">The <span class="Li">$keep</span> argument is a boolean flag. If
    true, then the tokens are split on the specified delimiter, but all other
    characters (quotes, backslashes, etc.) are kept in the tokens. If
    <span class="Li">$keep</span> is false then the &amp;*<i>quotewords()</i>
    functions remove all quotes and backslashes that are not themselves
    backslash-escaped or inside of single quotes (i.e., &amp;<i>quotewords()</i>
    tries to interpret these characters just like the Bourne shell). NB: these
    semantics are significantly different from the original version of this
    module shipped with Perl 5.000 through 5.004. As an additional feature,
    <span class="Li">$keep</span> may be the keyword &quot;delimiters&quot;
    which causes the functions to preserve the delimiters in each string as
    tokens in the token lists, in addition to preserving quote and backslash
    characters.</p>
<p class="Pp">&amp;<i>shellwords()</i> is written as a special case of
    &amp;<i>quotewords()</i>, and it does token parsing with whitespace as a
    delimiter-- similar to most Unix shells.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
The sample program:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Text::ParseWords;
  @words = quotewords('\s+', 0, q{this   is &quot;a test&quot; of\ quotewords \&quot;for you});
  $i = 0;
  foreach (@words) {
      print &quot;$i: &lt;$_&gt;\n&quot;;
      $i++;
  }
</pre>
<p class="Pp">produces:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  0: &lt;this&gt;
  1: &lt;is&gt;
  2: &lt;a test&gt;
  3: &lt;of quotewords&gt;
  4: &lt;&quot;for&gt;
  5: &lt;you&gt;
</pre>
<p class="Pp">demonstrating:</p>
<dl class="Bl-tag">
  <dt>0</dt>
  <dd>a simple word</dd>
  <dt>1</dt>
  <dd>multiple spaces are skipped because of our
    <span class="Li">$delim</span></dd>
  <dt>2</dt>
  <dd>use of quotes to include a space in a word</dd>
  <dt>3</dt>
  <dd>use of a backslash to include a space in a word</dd>
  <dt>4</dt>
  <dd>use of a backslash to remove the special meaning of a double-quote</dd>
  <dt>5</dt>
  <dd>another simple word (note the lack of effect of the backslashed
      double-quote)</dd>
</dl>
<p class="Pp">Replacing <span class="Li">&quot;quotewords('\s+', 0, q{this
    is...})&quot;</span> with <span class="Li">&quot;shellwords(q{this
    is...})&quot;</span> is a simpler way to accomplish the same thing.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Text::CSV - for parsing CSV files
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Maintainer: Alexandr Ciornii &lt;alexchornyATgmail.com&gt;.
<p class="Pp">Previous maintainer: Hal Pomeranz &lt;pomeranz@netcom.com&gt;,
    1994-1997 (Original author unknown). Much of the code for
    &amp;<i>parse_line()</i> (including the primary regexp) from Joerk Behrends
    &lt;jbehrends@multimediaproduzenten.de&gt;.</p>
<p class="Pp">Examples section another documentation provided by John Heidemann
    &lt;johnh@ISI.EDU&gt;</p>
<p class="Pp">Bug reports, patches, and nagging provided by lots of folks--
    thanks everybody! Special thanks to Michael Schwern
    &lt;schwern@envirolink.org&gt; for assuring me that a
    &amp;<i>nested_quotewords()</i> would be useful, and to Jeff Friedl
    &lt;jfriedl@yahoo-inc.com&gt; for telling me not to worry about
    error-checking (sort of-- you had to be there).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="POD_ERRORS"><a class="permalink" href="#POD_ERRORS">POD
  ERRORS</a></h1>
Hey! <b>The above document had some coding errors, which are explained
  below:</b>
<dl class="Bl-tag">
  <dt>Around line 250:</dt>
  <dd>Expected text after =item, not a number</dd>
  <dt>Around line 254:</dt>
  <dd>Expected text after =item, not a number</dd>
  <dt>Around line 258:</dt>
  <dd>Expected text after =item, not a number</dd>
  <dt>Around line 262:</dt>
  <dd>Expected text after =item, not a number</dd>
  <dt>Around line 266:</dt>
  <dd>Expected text after =item, not a number</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
