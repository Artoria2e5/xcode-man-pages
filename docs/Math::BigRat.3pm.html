<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Math::BigRat(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Math::BigRat(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Math::BigRat(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Math::BigRat - Arbitrary big rational numbers
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use Math::BigRat;

    my $x = Math::BigRat-&gt;new('3/7'); $x += '5/9';

    print $x-&gt;bstr(), &quot;\n&quot;;
    print $x ** 2, &quot;\n&quot;;

    my $y = Math::BigRat-&gt;new('inf');
    print &quot;$y &quot;, ($y-&gt;is_inf ? 'is' : 'is not'), &quot; infinity\n&quot;;

    my $z = Math::BigRat-&gt;new(144); $z-&gt;bsqrt();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Math::BigRat complements Math::BigInt and Math::BigFloat by providing support
  for arbitrary big rational numbers.
<section class="Ss">
<h2 class="Ss" id="_s-1MATH_LIBRARY_s0"><a class="permalink" href="#_s-1MATH_LIBRARY_s0">MATH
  LIBRARY</a></h2>
You can change the underlying module that does the low-level math operations by
  using:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Math::BigRat try =&gt; 'GMP';
</pre>
<p class="Pp">Note: This needs Math::BigInt::GMP installed.</p>
<p class="Pp">The following would first try to find Math::BigInt::Foo, then
    Math::BigInt::Bar, and when this also fails, revert to
  Math::BigInt::Calc:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Math::BigRat try =&gt; 'Foo,Math::BigInt::Bar';
</pre>
<p class="Pp">If you want to get warned when the fallback occurs, replace
    &quot;try&quot; with &quot;lib&quot;:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Math::BigRat lib =&gt; 'Foo,Math::BigInt::Bar';
</pre>
<p class="Pp">If you want the code to die instead, replace &quot;try&quot; with
    &quot;only&quot;:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Math::BigRat only =&gt; 'Foo,Math::BigInt::Bar';
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
Any methods not listed here are derived from Math::BigFloat (or Math::BigInt),
  so make sure you check these two modules for further information.
<dl class="Bl-tag">
  <dt><b>new()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x = Math::BigRat-&gt;new('1/3');
    </pre>
    <p class="Pp">Create a new Math::BigRat object. Input can come in various
        forms:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $x = Math::BigRat-&gt;new(123);                            # scalars
    $x = Math::BigRat-&gt;new('inf');                          # infinity
    $x = Math::BigRat-&gt;new('123.3');                        # float
    $x = Math::BigRat-&gt;new('1/3');                          # simple string
    $x = Math::BigRat-&gt;new('1 / 3');                        # spaced
    $x = Math::BigRat-&gt;new('1 / 0.1');                      # w/ floats
    $x = Math::BigRat-&gt;new(Math::BigInt-&gt;new(3));           # BigInt
    $x = Math::BigRat-&gt;new(Math::BigFloat-&gt;new('3.1'));     # BigFloat
    $x = Math::BigRat-&gt;new(Math::BigInt::Lite-&gt;new('2'));   # BigLite

    # You can also give D and N as different objects:
    $x = Math::BigRat-&gt;new(
            Math::BigInt-&gt;new(-123),
            Math::BigInt-&gt;new(7),
         );                      # =&gt; -123/7
    </pre>
  </dd>
  <dt><b>numerator()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $n = $x-&gt;numerator();
    </pre>
    <p class="Pp">Returns a copy of the numerator (the part above the line) as
        signed BigInt.</p>
  </dd>
  <dt><b>denominator()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $d = $x-&gt;denominator();
    </pre>
    <p class="Pp">Returns a copy of the denominator (the part under the line) as
        positive BigInt.</p>
  </dd>
  <dt><b>parts()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    ($n, $d) = $x-&gt;parts();
    </pre>
    <p class="Pp">Return a list consisting of (signed) numerator and (unsigned)
        denominator as BigInts.</p>
  </dd>
  <dt><b>numify()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    my $y = $x-&gt;numify();
    </pre>
    <p class="Pp">Returns the object as a scalar. This will lose some data if
        the object cannot be represented by a normal Perl scalar (integer or
        float), so use &quot;<b>as_int()</b>&quot; or
        &quot;<b>as_float()</b>&quot; instead.</p>
    <p class="Pp">This routine is automatically used whenever a scalar is
        required:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $x = Math::BigRat-&gt;new('3/1');
    @array = (0, 1, 2, 3);
    $y = $array[$x];                # set $y to 3
    </pre>
  </dd>
  <dt><b>as_int()</b></dt>
  <dd></dd>
  <dt><b>as_number()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x = Math::BigRat-&gt;new('13/7');
    print $x-&gt;as_int(), &quot;\n&quot;;               # '1'
    </pre>
    <p class="Pp">Returns a copy of the object as BigInt, truncated to an
        integer.</p>
    <p class="Pp"><span class="Li">&quot;as_number()&quot;</span> is an alias
        for <span class="Li">&quot;as_int()&quot;</span>.</p>
  </dd>
  <dt><b>as_float()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x = Math::BigRat-&gt;new('13/7');
    print $x-&gt;as_float(), &quot;\n&quot;;             # '1'

    $x = Math::BigRat-&gt;new('2/3');
    print $x-&gt;as_float(5), &quot;\n&quot;;            # '0.66667'
    </pre>
    <p class="Pp">Returns a copy of the object as BigFloat, preserving the
        accuracy as wanted, or the default of 40 digits.</p>
    <p class="Pp">This method was added in v0.22 of Math::BigRat (April
      2008).</p>
  </dd>
  <dt><b>as_hex()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x = Math::BigRat-&gt;new('13');
    print $x-&gt;as_hex(), &quot;\n&quot;;               # '0xd'
    </pre>
    <p class="Pp">Returns the BigRat as hexadecimal string. Works only for
        integers.</p>
  </dd>
  <dt><b>as_bin()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x = Math::BigRat-&gt;new('13');
    print $x-&gt;as_bin(), &quot;\n&quot;;               # '0x1101'
    </pre>
    <p class="Pp">Returns the BigRat as binary string. Works only for
      integers.</p>
  </dd>
  <dt><b>as_oct()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x = Math::BigRat-&gt;new('13');
    print $x-&gt;as_oct(), &quot;\n&quot;;               # '015'
    </pre>
    <p class="Pp">Returns the BigRat as octal string. Works only for
      integers.</p>
  </dd>
  <dt><b>from_hex()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    my $h = Math::BigRat-&gt;from_hex('0x10');
    </pre>
    <p class="Pp">Create a BigRat from a hexadecimal number in string form.</p>
  </dd>
  <dt><b>from_oct()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    my $o = Math::BigRat-&gt;from_oct('020');
    </pre>
    <p class="Pp">Create a BigRat from an octal number in string form.</p>
  </dd>
  <dt><b>from_bin()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    my $b = Math::BigRat-&gt;from_bin('0b10000000');
    </pre>
    <p class="Pp">Create a BigRat from an binary number in string form.</p>
  </dd>
  <dt><b>bnan()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x = Math::BigRat-&gt;bnan();
    </pre>
    <p class="Pp">Creates a new BigRat object representing NaN (Not A Number).
        If used on an object, it will set it to NaN:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $x-&gt;bnan();
    </pre>
  </dd>
  <dt><b>bzero()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x = Math::BigRat-&gt;bzero();
    </pre>
    <p class="Pp">Creates a new BigRat object representing zero. If used on an
        object, it will set it to zero:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $x-&gt;bzero();
    </pre>
  </dd>
  <dt><b>binf()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x = Math::BigRat-&gt;binf($sign);
    </pre>
    <p class="Pp">Creates a new BigRat object representing infinity. The
        optional argument is either '-' or '+', indicating whether you want
        infinity or minus infinity. If used on an object, it will set it to
        infinity:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $x-&gt;binf();
    $x-&gt;binf('-');
    </pre>
  </dd>
  <dt><b>bone()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x = Math::BigRat-&gt;bone($sign);
    </pre>
    <p class="Pp">Creates a new BigRat object representing one. The optional
        argument is either '-' or '+', indicating whether you want one or minus
        one. If used on an object, it will set it to one:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $x-&gt;bone();                 # +1
    $x-&gt;bone('-');              # -1
    </pre>
  </dd>
  <dt><b>length()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $len = $x-&gt;length();
    </pre>
    <p class="Pp">Return the length of <span class="Li">$x</span> in digits for
        integer values.</p>
  </dd>
  <dt><b>digit()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    print Math::BigRat-&gt;new('123/1')-&gt;digit(1);     # 1
    print Math::BigRat-&gt;new('123/1')-&gt;digit(-1);    # 3
    </pre>
    <p class="Pp">Return the N'ths digit from X when X is an integer value.</p>
  </dd>
  <dt><b>bnorm()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bnorm();
    </pre>
    <p class="Pp">Reduce the number to the shortest form. This routine is called
        automatically whenever it is needed.</p>
  </dd>
  <dt><b>bfac()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bfac();
    </pre>
    <p class="Pp">Calculates the factorial of <span class="Li">$x</span>. For
        instance:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    print Math::BigRat-&gt;new('3/1')-&gt;bfac(), &quot;\n&quot;;   # 1*2*3
    print Math::BigRat-&gt;new('5/1')-&gt;bfac(), &quot;\n&quot;;   # 1*2*3*4*5
    </pre>
    <p class="Pp">Works currently only for integers.</p>
  </dd>
  <dt><b>bround()</b>/<b>round()</b>/<b>bfround()</b></dt>
  <dd>Are not yet implemented.</dd>
  <dt><b>bmod()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bmod($y);
    </pre>
    <p class="Pp">Returns <span class="Li">$x</span> modulo
        <span class="Li">$y</span>. When <span class="Li">$x</span> is finite,
        and <span class="Li">$y</span> is finite and non-zero, the result is
        identical to the remainder after floored division (F-division). If, in
        addition, both <span class="Li">$x</span> and <span class="Li">$y</span>
        are integers, the result is identical to the result from Perl's %
        operator.</p>
  </dd>
  <dt><b>bmodinv()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bmodinv($mod);          # modular multiplicative inverse
    </pre>
    <p class="Pp">Returns the multiplicative inverse of
        <span class="Li">$x</span> modulo <span class="Li">$mod</span>. If</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $y = $x -&gt; copy() -&gt; bmodinv($mod)
    </pre>
    <p class="Pp">then <span class="Li">$y</span> is the number closest to zero,
        and with the same sign as <span class="Li">$mod</span>, satisfying</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ($x * $y) % $mod = 1 % $mod
    </pre>
    <p class="Pp">If <span class="Li">$x</span> and <span class="Li">$y</span>
        are non-zero, they must be relative primes, i.e.,
        <span class="Li">&quot;bgcd($y, $mod)==1&quot;</span>.
        '<span class="Li">&quot;NaN&quot;</span>' is returned when no modular
        multiplicative inverse exists.</p>
  </dd>
  <dt><b>bmodpow()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $num-&gt;bmodpow($exp,$mod);           # modular exponentiation
                                        # ($num**$exp % $mod)
    </pre>
    <p class="Pp">Returns the value of <span class="Li">$num</span> taken to the
        power <span class="Li">$exp</span> in the modulus
        <span class="Li">$mod</span> using binary exponentiation.
        <span class="Li">&quot;bmodpow&quot;</span> is far superior to
      writing</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $num ** $exp % $mod
    </pre>
    <p class="Pp">because it is much faster - it reduces internal variables into
        the modulus whenever possible, so it operates on smaller numbers.</p>
    <p class="Pp"><span class="Li">&quot;bmodpow&quot;</span> also supports
        negative exponents.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    bmodpow($num, -1, $mod)
    </pre>
    <p class="Pp">is exactly equivalent to</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    bmodinv($num, $mod)
    </pre>
  </dd>
  <dt><b>bneg()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bneg();
    </pre>
    <p class="Pp">Used to negate the object in-place.</p>
  </dd>
  <dt><b>is_one()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    print &quot;$x is 1\n&quot; if $x-&gt;is_one();
    </pre>
    <p class="Pp">Return true if <span class="Li">$x</span> is exactly one,
        otherwise false.</p>
  </dd>
  <dt><b>is_zero()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    print &quot;$x is 0\n&quot; if $x-&gt;is_zero();
    </pre>
    <p class="Pp">Return true if <span class="Li">$x</span> is exactly zero,
        otherwise false.</p>
  </dd>
  <dt><b>is_pos()</b>/<b>is_positive()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    print &quot;$x is &gt;= 0\n&quot; if $x-&gt;is_positive();
    </pre>
    <p class="Pp">Return true if <span class="Li">$x</span> is positive (greater
        than or equal to zero), otherwise false. Please note that '+inf' is also
        positive, while 'NaN' and '-inf' aren't.</p>
    <p class="Pp"><span class="Li">&quot;is_positive()&quot;</span> is an alias
        for <span class="Li">&quot;is_pos()&quot;</span>.</p>
  </dd>
  <dt><b>is_neg()</b>/<b>is_negative()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    print &quot;$x is &lt; 0\n&quot; if $x-&gt;is_negative();
    </pre>
    <p class="Pp">Return true if <span class="Li">$x</span> is negative (smaller
        than zero), otherwise false. Please note that '-inf' is also negative,
        while 'NaN' and '+inf' aren't.</p>
    <p class="Pp"><span class="Li">&quot;is_negative()&quot;</span> is an alias
        for <span class="Li">&quot;is_neg()&quot;</span>.</p>
  </dd>
  <dt><b>is_int()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    print &quot;$x is an integer\n&quot; if $x-&gt;is_int();
    </pre>
    <p class="Pp">Return true if <span class="Li">$x</span> has a denominator of
        1 (e.g. no fraction parts), otherwise false. Please note that '-inf',
        'inf' and 'NaN' aren't integer.</p>
  </dd>
  <dt><b>is_odd()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    print &quot;$x is odd\n&quot; if $x-&gt;is_odd();
    </pre>
    <p class="Pp">Return true if <span class="Li">$x</span> is odd, otherwise
        false.</p>
  </dd>
  <dt><b>is_even()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    print &quot;$x is even\n&quot; if $x-&gt;is_even();
    </pre>
    <p class="Pp">Return true if <span class="Li">$x</span> is even, otherwise
        false.</p>
  </dd>
  <dt><b>bceil()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bceil();
    </pre>
    <p class="Pp">Set <span class="Li">$x</span> to the next bigger integer
        value (e.g. truncate the number to integer and then increment it by
        one).</p>
  </dd>
  <dt><b>bfloor()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bfloor();
    </pre>
    <p class="Pp">Truncate <span class="Li">$x</span> to an integer value.</p>
  </dd>
  <dt><b>bint()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bint();
    </pre>
    <p class="Pp">Round <span class="Li">$x</span> towards zero.</p>
  </dd>
  <dt><b>bsqrt()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bsqrt();
    </pre>
    <p class="Pp">Calculate the square root of <span class="Li">$x</span>.</p>
  </dd>
  <dt><b>broot()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;broot($n);
    </pre>
    <p class="Pp">Calculate the N'th root of <span class="Li">$x</span>.</p>
  </dd>
  <dt><b>badd()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;badd($y);
    </pre>
    <p class="Pp">Adds <span class="Li">$y</span> to <span class="Li">$x</span>
        and returns the result.</p>
  </dd>
  <dt><b>bmul()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bmul($y);
    </pre>
    <p class="Pp">Multiplies <span class="Li">$y</span> to
        <span class="Li">$x</span> and returns the result.</p>
  </dd>
  <dt><b>bsub()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bsub($y);
    </pre>
    <p class="Pp">Subtracts <span class="Li">$y</span> from
        <span class="Li">$x</span> and returns the result.</p>
  </dd>
  <dt><b>bdiv()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $q = $x-&gt;bdiv($y);
    ($q, $r) = $x-&gt;bdiv($y);
    </pre>
    <p class="Pp">In scalar context, divides <span class="Li">$x</span> by
        <span class="Li">$y</span> and returns the result. In list context, does
        floored division (F-division), returning an integer
        <span class="Li">$q</span> and a remainder <span class="Li">$r</span> so
        that <span class="Li">$x</span> = <span class="Li">$q</span> *
        <span class="Li">$y</span> + <span class="Li">$r</span>. The remainer
        (modulo) is equal to what is returned by
        <span class="Li">&quot;$x-&quot;</span>bmod($y)&gt;.</p>
  </dd>
  <dt><b>bdec()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bdec();
    </pre>
    <p class="Pp">Decrements <span class="Li">$x</span> by 1 and returns the
        result.</p>
  </dd>
  <dt><b>binc()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;binc();
    </pre>
    <p class="Pp">Increments <span class="Li">$x</span> by 1 and returns the
        result.</p>
  </dd>
  <dt><b>copy()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    my $z = $x-&gt;copy();
    </pre>
    <p class="Pp">Makes a deep copy of the object.</p>
    <p class="Pp">Please see the documentation in Math::BigInt for further
        details.</p>
  </dd>
  <dt><b>bstr()</b>/<b>bsstr()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    my $x = Math::BigRat-&gt;new('8/4');
    print $x-&gt;bstr(), &quot;\n&quot;;             # prints 1/2
    print $x-&gt;bsstr(), &quot;\n&quot;;            # prints 1/2
    </pre>
    <p class="Pp">Return a string representing this object.</p>
  </dd>
  <dt><b>bcmp()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bcmp($y);
    </pre>
    <p class="Pp">Compares <span class="Li">$x</span> with
        <span class="Li">$y</span> and takes the sign into account. Returns -1,
        0, 1 or undef.</p>
  </dd>
  <dt><b>bacmp()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bacmp($y);
    </pre>
    <p class="Pp">Compares <span class="Li">$x</span> with
        <span class="Li">$y</span> while ignoring their sign. Returns -1, 0, 1
        or undef.</p>
  </dd>
  <dt><b>beq()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x -&gt; beq($y);
    </pre>
    <p class="Pp">Returns true if and only if <span class="Li">$x</span> is
        equal to <span class="Li">$y</span>, and false otherwise.</p>
  </dd>
  <dt><b>bne()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x -&gt; bne($y);
    </pre>
    <p class="Pp">Returns true if and only if <span class="Li">$x</span> is not
        equal to <span class="Li">$y</span>, and false otherwise.</p>
  </dd>
  <dt><b>blt()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x -&gt; blt($y);
    </pre>
    <p class="Pp">Returns true if and only if <span class="Li">$x</span> is
        equal to <span class="Li">$y</span>, and false otherwise.</p>
  </dd>
  <dt><b>ble()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x -&gt; ble($y);
    </pre>
    <p class="Pp">Returns true if and only if <span class="Li">$x</span> is less
        than or equal to <span class="Li">$y</span>, and false otherwise.</p>
  </dd>
  <dt><b>bgt()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x -&gt; bgt($y);
    </pre>
    <p class="Pp">Returns true if and only if <span class="Li">$x</span> is
        greater than <span class="Li">$y</span>, and false otherwise.</p>
  </dd>
  <dt><b>bge()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x -&gt; bge($y);
    </pre>
    <p class="Pp">Returns true if and only if <span class="Li">$x</span> is
        greater than or equal to <span class="Li">$y</span>, and false
        otherwise.</p>
  </dd>
  <dt><b>blsft()</b>/<b>brsft()</b></dt>
  <dd>Used to shift numbers left/right.
    <p class="Pp">Please see the documentation in Math::BigInt for further
        details.</p>
  </dd>
  <dt><b>band()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;band($y);               # bitwise and
    </pre>
  </dd>
  <dt><b>bior()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bior($y);               # bitwise inclusive or
    </pre>
  </dd>
  <dt><b>bxor()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bxor($y);               # bitwise exclusive or
    </pre>
  </dd>
  <dt><b>bnot()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bnot();                 # bitwise not (two's complement)
    </pre>
  </dd>
  <dt><b>bpow()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bpow($y);
    </pre>
    <p class="Pp">Compute <span class="Li">$x</span> **
        <span class="Li">$y</span>.</p>
    <p class="Pp">Please see the documentation in Math::BigInt for further
        details.</p>
  </dd>
  <dt><b>blog()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;blog($base, $accuracy);         # logarithm of x to the base $base
    </pre>
    <p class="Pp">If <span class="Li">$base</span> is not defined, Euler's
        number (e) is used:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    print $x-&gt;blog(undef, 100);         # log(x) to 100 digits
    </pre>
  </dd>
  <dt><b>bexp()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bexp($accuracy);        # calculate e ** X
    </pre>
    <p class="Pp">Calculates two integers A and B so that A/B is equal to
        <span class="Li">&quot;e ** $x&quot;</span>, where
        <span class="Li">&quot;e&quot;</span> is Euler's number.</p>
    <p class="Pp">This method was added in v0.20 of Math::BigRat (May 2007).</p>
    <p class="Pp">See also <span class="Li">&quot;blog()&quot;</span>.</p>
  </dd>
  <dt><b>bnok()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    $x-&gt;bnok($y);               # x over y (binomial coefficient n over k)
    </pre>
    <p class="Pp">Calculates the binomial coefficient n over k, also called the
        &quot;choose&quot; function. The result is equivalent to:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ( n )      n!
    | - |  = -------
    ( k )    k!(n-k)!
    </pre>
    <p class="Pp">This method was added in v0.20 of Math::BigRat (May 2007).</p>
  </dd>
  <dt><b>config()</b></dt>
  <dd><span class="Li"></span>
    <pre>
    Math::BigRat-&gt;config(&quot;trap_nan&quot; =&gt; 1);      # set
    $accu = Math::BigRat-&gt;config(&quot;accuracy&quot;);   # get
    </pre>
    <p class="Pp">Set or get configuration parameter values. Read-only
        parameters are marked as RO. Read-write parameters are marked as RW. The
        following parameters are supported.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Parameter       RO/RW   Description
                            Example
    ============================================================
    lib             RO      Name of the math backend library
                            Math::BigInt::Calc
    lib_version     RO      Version of the math backend library
                            0.30
    class           RO      The class of config you just called
                            Math::BigRat
    version         RO      version number of the class you used
                            0.10
    upgrade         RW      To which class numbers are upgraded
                            undef
    downgrade       RW      To which class numbers are downgraded
                            undef
    precision       RW      Global precision
                            undef
    accuracy        RW      Global accuracy
                            undef
    round_mode      RW      Global round mode
                            even
    div_scale       RW      Fallback accuracy for div, sqrt etc.
                            40
    trap_nan        RW      Trap NaNs
                            undef
    trap_inf        RW      Trap +inf/-inf
                            undef
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
Please report any bugs or feature requests to
  <span class="Li">&quot;bug-math-bigrat at rt.cpan.org&quot;</span>, or through
  the web interface at
  &lt;https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigRat&gt; (requires
  login). We will be notified, and then you'll automatically be notified of
  progress on your bug as I make changes.
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
You can find documentation for this module with the perldoc command.
<p class="Pp"><span class="Li"></span></p>
<pre>
    perldoc Math::BigRat
</pre>
<p class="Pp">You can also look for information at:</p>
<ul class="Bl-bullet">
  <li>RT: CPAN's request tracker
    <p class="Pp">&lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Math-BigRat&gt;</p>
  </li>
  <li>AnnoCPAN: Annotated CPAN documentation
    <p class="Pp">&lt;http://annocpan.org/dist/Math-BigRat&gt;</p>
  </li>
  <li>CPAN Ratings
    <p class="Pp">&lt;http://cpanratings.perl.org/dist/Math-BigRat&gt;</p>
  </li>
  <li>Search CPAN
    <p class="Pp">&lt;http://search.cpan.org/dist/Math-BigRat/&gt;</p>
  </li>
  <li>CPAN Testers Matrix
    <p class="Pp">&lt;http://matrix.cpantesters.org/?dist=Math-BigRat&gt;</p>
  </li>
  <li>The Bignum mailing list</li>
</ul>
<div class="Bd-indent">
<ul class="Bl-bullet">
  <li>Post to mailing list
    <p class="Pp"><span class="Li">&quot;bignum at
        lists.scsys.co.uk&quot;</span></p>
  </li>
  <li>View mailing list
    <p class="Pp">&lt;http://lists.scsys.co.uk/pipermail/bignum/&gt;</p>
  </li>
  <li>Subscribe/Unsubscribe
    <p class="Pp">&lt;http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/bignum&gt;</p>
  </li>
</ul>
</div>
<div class="Bd-indent"></div>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This program is free software; you may redistribute it and/or modify it under
  the same terms as Perl itself.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
bigrat, Math::BigFloat and Math::BigInt as well as the backends
  Math::BigInt::FastCalc, Math::BigInt::GMP, and Math::BigInt::Pari.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
<ul class="Bl-bullet">
  <li>Tels &lt;http://bloodgate.com/&gt; 2001-2009.</li>
  <li>Maintained by Peter John Acklam &lt;pjacklam@online.no&gt; 2011-</li>
</ul>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-11-01</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
