<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>DBIx::Class::Manual::Glossary(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Manual::Glossary(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Manual::Glossary(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
DBIx::Class::Manual::Glossary - Clarification of terms used.
</section>
<section class="Sh">
<h1 class="Sh" id="INTRODUCTION"><a class="permalink" href="#INTRODUCTION">INTRODUCTION</a></h1>
This document lists various terms used in DBIx::Class and attempts to explain
  them.
</section>
<section class="Sh">
<h1 class="Sh" id="DBIx::Class_TERMS"><a class="permalink" href="#DBIx::Class_TERMS">DBIx::Class
  TERMS</a></h1>
<section class="Ss">
<h2 class="Ss" id="_s-1DB_s0_schema"><a class="permalink" href="#_s-1DB_s0_schema">DB
  schema</a></h2>
Refers to a single physical schema within an RDBMS. Synonymous with the terms
  'database', for MySQL; and 'schema', for most other RDBMS(s).
<p class="Pp">In other words, it's the 'xyz' _thing_ you're connecting to when
    using any of the following DSN(s):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  dbi:DriverName:xyz@hostname:port
  dbi:DriverName:database=xyz;host=hostname;port=port
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Inflation"><a class="permalink" href="#Inflation">Inflation</a></h2>
The act of turning database row data into objects in language-space. DBIx::Class
  result classes can be set up to inflate your data into perl objects which more
  usefully represent their contents. For example:
  DBIx::Class::InflateColumn::DateTime for datetime or timestamp column data.
<p class="Pp">See also DBIx::Class::InflateColumn.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Deflation"><a class="permalink" href="#Deflation">Deflation</a></h2>
The opposite of &quot;Inflation&quot;. Existing perl objects that represent
  column values can be passed to DBIx::Class methods to store into the database.
  For example a DateTime object can be automatically deflated into a datetime
  string for insertion.
<p class="Pp">See DBIx::Class::InflateColumn and other modules in that
    namespace.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1ORM_s0"><a class="permalink" href="#_s-1ORM_s0">ORM</a></h2>
Object-relational mapping, or Object-relationship modelling. Either way it's a
  method of mapping the contents of database tables (rows), to objects in
  programming-language-space. DBIx::Class is an ORM.
</section>
<section class="Ss">
<h2 class="Ss" id="Relationship"><a class="permalink" href="#Relationship">Relationship</a></h2>
In DBIx::Class a relationship defines the connection between exactly two tables.
  The relationship condition lists the columns in each table that contain the
  same values. It is used to output an SQL JOIN condition between the tables.
</section>
<section class="Ss">
<h2 class="Ss" id="Relationship_bridge"><a class="permalink" href="#Relationship_bridge">Relationship
  bridge</a></h2>
A relationship bridge, such as <span class="Li">&quot;many_to_many&quot;</span>
  defines an accessor to retrieve row contents across multiple relationships.
<p class="Pp">The difference between a bridge and a relationship is, that the
    bridge cannot be used to <span class="Li">&quot;join&quot;</span> tables in
    a <span class="Li">&quot;search&quot;</span>, instead its component
    relationships must be used.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Schema"><a class="permalink" href="#Schema">Schema</a></h2>
A Schema object represents your entire table collection, plus the connection to
  the database. You can create one or more schema objects, connected to various
  databases, with various users, using the same set of table &quot;Result
  class&quot; definitions.
<p class="Pp">At least one DBIx::Class::Schema class is needed per database.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Result_class"><a class="permalink" href="#Result_class">Result
  class</a></h2>
A Result class defines both a source of data (usually one per table), and the
  methods that will be available in the &quot;Result&quot; objects created using
  that source.
<p class="Pp">One Result class is needed per data source (table, view, query)
    used in your application, they should inherit from DBIx::Class::Core.</p>
<p class="Pp">See also: DBIx::Class::Manual::ResultClass</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ResultSource"><a class="permalink" href="#ResultSource">ResultSource</a></h2>
ResultSource objects represent the source of your data, these are sometimes
  (incorrectly) called table objects.
<p class="Pp">ResultSources do not need to be directly created, a ResultSource
    instance is created for each &quot;Result class&quot; in your
    &quot;Schema&quot;, by the proxied methods
    <span class="Li">&quot;table&quot;</span> and
    <span class="Li">&quot;add_columns&quot;</span>.</p>
<p class="Pp">See also: &quot;METHODS&quot; in DBIx::Class::ResultSource</p>
</section>
<section class="Ss">
<h2 class="Ss" id="ResultSet"><a class="permalink" href="#ResultSet">ResultSet</a></h2>
This is an object representing a set of conditions to filter data. It can either
  be an entire table, or the results of a query. The actual data is not held in
  the ResultSet, it is only a description of how to fetch the data.
<p class="Pp">See also: &quot;METHODS&quot; in DBIx::Class::ResultSet</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Result"><a class="permalink" href="#Result">Result</a></h2>
Result objects contain your actual data. They are returned from ResultSet
  objects. These are sometimes (incorrectly) called row objects, including older
  versions of the DBIC documentation.
<p class="Pp">See also: DBIx::Class::Manual::ResultClass</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Row"><a class="permalink" href="#Row">Row</a></h2>
See Result.
</section>
<section class="Ss">
<h2 class="Ss" id="Object"><a class="permalink" href="#Object">Object</a></h2>
See Result.
</section>
<section class="Ss">
<h2 class="Ss" id="Record"><a class="permalink" href="#Record">Record</a></h2>
See Result.
</section>
<section class="Ss">
<h2 class="Ss" id="prefetch"><a class="permalink" href="#prefetch">prefetch</a></h2>
Similar to a join, except the related result objects are fetched and cached for
  future use, instead of used directly from the ResultSet. This allows you to
  jump to different relationships within a Result without worrying about
  generating a ton of extra SELECT statements.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SQL_TERMS"><a class="permalink" href="#SQL_TERMS">SQL
  TERMS</a></h1>
<section class="Ss">
<h2 class="Ss" id="_s-1CRUD_s0"><a class="permalink" href="#_s-1CRUD_s0">CRUD</a></h2>
Create, Read, Update, Delete. A general concept of something that can do all
  four operations (INSERT, SELECT, UPDATE, DELETE), usually at a row-level.
</section>
<section class="Ss">
<h2 class="Ss" id="Join"><a class="permalink" href="#Join">Join</a></h2>
This is an SQL keyword, it is used to link multiple tables in one SQL statement.
  This enables us to fetch data from more than one table at once, or filter data
  based on content in another table, without having to issue multiple SQL
  queries.
</section>
<section class="Ss">
<h2 class="Ss" id="Normalisation"><a class="permalink" href="#Normalisation">Normalisation</a></h2>
A normalised database is a sane database. Each table contains only data
  belonging to one concept, related tables refer to the key field or fields of
  each other. Some links to webpages about normalisation can be found in
  DBIx::Class::Manual::FAQ.
</section>
<section class="Ss">
<h2 class="Ss" id="Related_data"><a class="permalink" href="#Related_data">Related
  data</a></h2>
In SQL, related data actually refers to data that are normalised into the same
  table. (Yes. DBIC does mis-use this term.)
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_AND_CONTRIBUTORS"><a class="permalink" href="#AUTHOR_AND_CONTRIBUTORS">AUTHOR
  AND CONTRIBUTORS</a></h1>
See AUTHOR and CONTRIBUTORS in DBIx::Class
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
You may distribute this code under the same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-05</td>
    <td class="foot-os">perl v5.18.2</td>
  </tr>
</table>
</body>
</html>
