<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PPI::Statement(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PPI::Statement(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">PPI::Statement(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
PPI::Statement - The base class for Perl statements
</section>
<section class="Sh">
<h1 class="Sh" id="INHERITANCE"><a class="permalink" href="#INHERITANCE">INHERITANCE</a></h1>
<span class="Li"></span>
<pre>
  PPI::Statement
  isa PPI::Node
      isa PPI::Element
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
PPI::Statement is the root class for all Perl statements. This includes (from
  perlsyn) &quot;Declarations&quot;, &quot;Simple Statements&quot; and
  &quot;Compound Statements&quot;.
<p class="Pp">The class PPI::Statement itself represents a &quot;Simple
    Statement&quot; as defined in the perlsyn manpage.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="STATEMENT_CLASSES"><a class="permalink" href="#STATEMENT_CLASSES">STATEMENT
  CLASSES</a></h1>
Please note that unless documented themselves, these classes are yet to be
  frozen/finalised. Names may change slightly or be added or removed.
<section class="Ss">
<h2 class="Ss" id="PPI::Statement::Scheduled"><a class="permalink" href="#PPI::Statement::Scheduled">PPI::Statement::Scheduled</a></h2>
This covers all &quot;scheduled&quot; blocks, chunks of code that are executed
  separately from the main body of the code, at a particular time. This includes
  all <span class="Li">&quot;BEGIN&quot;</span>,
  <span class="Li">&quot;CHECK&quot;</span>,
  <span class="Li">&quot;UNITCHECK&quot;</span>,
  <span class="Li">&quot;INIT&quot;</span> and
  <span class="Li">&quot;END&quot;</span> blocks.
</section>
<section class="Ss">
<h2 class="Ss" id="PPI::Statement::Package"><a class="permalink" href="#PPI::Statement::Package">PPI::Statement::Package</a></h2>
A package declaration, as defined in perlfunc.
</section>
<section class="Ss">
<h2 class="Ss" id="PPI::Statement::Include"><a class="permalink" href="#PPI::Statement::Include">PPI::Statement::Include</a></h2>
A statement that loads or unloads another module.
<p class="Pp">This includes 'use', 'no', and 'require' statements.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="PPI::Statement::Sub"><a class="permalink" href="#PPI::Statement::Sub">PPI::Statement::Sub</a></h2>
A named subroutine declaration, or forward declaration
</section>
<section class="Ss">
<h2 class="Ss" id="PPI::Statement::Variable"><a class="permalink" href="#PPI::Statement::Variable">PPI::Statement::Variable</a></h2>
A variable declaration statement. This could be either a straight declaration or
  also be an expression.
<p class="Pp">This includes all 'my', 'state', 'local' and 'our' statements.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="PPI::Statement::Compound"><a class="permalink" href="#PPI::Statement::Compound">PPI::Statement::Compound</a></h2>
This covers the whole family of 'compound' statements, as described in perlsyn.
<p class="Pp">This includes all statements starting with 'if', 'unless', 'for',
    'foreach' and 'while'. Note that this does NOT include 'do', as it is
    treated differently.</p>
<p class="Pp">All compound statements have implicit ends. That is, they do not
    end with a ';' statement terminator.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="PPI::Statement::Break"><a class="permalink" href="#PPI::Statement::Break">PPI::Statement::Break</a></h2>
A statement that breaks out of a structure.
<p class="Pp">This includes all of 'redo', 'goto', 'next', 'last' and 'return'
    statements.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="PPI::Statement::Given"><a class="permalink" href="#PPI::Statement::Given">PPI::Statement::Given</a></h2>
The kind of statement introduced in Perl 5.10 that starts with 'given'. This has
  an implicit end.
</section>
<section class="Ss">
<h2 class="Ss" id="PPI::Statement::When"><a class="permalink" href="#PPI::Statement::When">PPI::Statement::When</a></h2>
The kind of statement introduced in Perl 5.10 that starts with 'when' or
  'default'. This also has an implicit end.
</section>
<section class="Ss">
<h2 class="Ss" id="PPI::Statement::Data"><a class="permalink" href="#PPI::Statement::Data">PPI::Statement::Data</a></h2>
A special statement which encompasses an entire
  <span class="Li">&quot;__DATA__&quot;</span> block, including the initial
  <span class="Li">'__DATA__'</span> token itself and the entire contents.
</section>
<section class="Ss">
<h2 class="Ss" id="PPI::Statement::End"><a class="permalink" href="#PPI::Statement::End">PPI::Statement::End</a></h2>
A special statement which encompasses an entire __END__ block, including the
  initial '__END__' token itself and the entire contents, including any parsed
  PPI::Token::POD that may occur in it.
</section>
<section class="Ss">
<h2 class="Ss" id="PPI::Statement::Expression"><a class="permalink" href="#PPI::Statement::Expression">PPI::Statement::Expression</a></h2>
PPI::Statement::Expression is a little more speculative, and is intended to help
  represent the special rules relating to &quot;expressions&quot; such as in:
<p class="Pp"><span class="Li"></span></p>
<pre>
  # Several examples of expression statements
  
  # Boolean conditions
  if ( expression ) { ... }
  
  # Lists, such as for arguments
  Foo-&gt;bar( expression )
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="PPI::Statement::Null"><a class="permalink" href="#PPI::Statement::Null">PPI::Statement::Null</a></h2>
A null statement is a special case for where we encounter two consecutive
  statement terminators. ( ;; )
<p class="Pp">The second terminator is given an entire statement of its own, but
    one that serves no purpose. Hence a 'null' statement.</p>
<p class="Pp">Theoretically, assuming a correct parsing of a perl file, all null
    statements are superfluous and should be able to be removed without damage
    to the file.</p>
<p class="Pp">But don't do that, in case PPI has parsed something wrong.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="PPI::Statement::UnmatchedBrace"><a class="permalink" href="#PPI::Statement::UnmatchedBrace">PPI::Statement::UnmatchedBrace</a></h2>
Because PPI is intended for use when parsing incorrect or incomplete code, the
  problem arises of what to do with a stray closing brace.
<p class="Pp">Rather than die, it is allocated its own &quot;unmatched
    brace&quot; statement, which really means &quot;unmatched closing
    brace&quot;. An unmatched open brace at the end of a file would become a
    structure with no contents and no closing brace.</p>
<p class="Pp">If the document loaded is intended to be correct and valid,
    finding a PPI::Statement::UnmatchedBrace in the PDOM is generally indicative
    of a misparse.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="PPI::Statement::Unknown"><a class="permalink" href="#PPI::Statement::Unknown">PPI::Statement::Unknown</a></h2>
This is used temporarily mid-parsing to hold statements for which the lexer
  cannot yet determine what class it should be, usually because there are
  insufficient clues, or it might be more than one thing.
<p class="Pp">You should never encounter these in a fully parsed PDOM tree.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<span class="Li">&quot;PPI::Statement&quot;</span> itself has very few methods.
  Most of the time, you will be working with the more generic PPI::Element or
  PPI::Node methods, or one of the methods that are subclass-specific.
<section class="Ss">
<h2 class="Ss" id="label"><a class="permalink" href="#label">label</a></h2>
One factor common to most statements is their ability to be labeled.
<p class="Pp">The <span class="Li">&quot;label&quot;</span> method returns the
    label for a statement, if one has been defined, but without the trailing
    colon. Take the following example</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  MYLABEL: while ( 1 .. 10 ) { last MYLABEL if $_ &gt; 5 }
</pre>
<p class="Pp">For the above statement, the
    <span class="Li">&quot;label&quot;</span> method would return 'MYLABEL'.</p>
<p class="Pp">Returns false if the statement does not have a label.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="specialized"><a class="permalink" href="#specialized">specialized</a></h2>
Answer whether this is a plain statement or one that has more significance.
<p class="Pp">Returns true if the statement is a subclass of this one, false
    otherwise.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="stable"><a class="permalink" href="#stable">stable</a></h2>
Much like the PPI::Document method of the same name, the -&gt;stable method
  converts a statement to source and back again, to determine if a modified
  statement is still legal, and won't be interpreted in a different way.
<p class="Pp">Returns true if the statement is stable, false if not, or
    <span class="Li">&quot;undef&quot;</span> on error.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TO_DO"><a class="permalink" href="#TO_DO">TO DO</a></h1>
- Complete, freeze and document the remaining classes
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
See the support section in the main module.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Adam Kennedy &lt;adamk@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright 2001 - 2011 Adam Kennedy.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">The full text of the license can be found in the LICENSE file
    included with this module.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-07-09</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
