<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Convert::ASN1(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Convert::ASN1(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Convert::ASN1(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Convert::ASN1 - ASN.1 Encode/Decode library
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 0.27
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSYS"><a class="permalink" href="#SYNOPSYS">SYNOPSYS</a></h1>
<span class="Li"></span>
<pre>
  use Convert::ASN1;

  $asn = Convert::ASN1-&gt;new;
  $asn-&gt;prepare(q&lt;

    [APPLICATION 7] SEQUENCE {
      int INTEGER,
      str OCTET STRING
    }

  &gt;);

  $pdu = $asn-&gt;encode( int =&gt; 7, str =&gt; &quot;string&quot;);

  $out = $asn-&gt;decode($pdu);
  print $out-&gt;{int},&quot; &quot;,$out-&gt;{str},&quot;\n&quot;;

  use Convert::ASN1 qw(:io);

  $peer   = asn_recv($sock,$buffer,0);
  $nbytes = asn_read($fh, $buffer);
  $nbytes = asn_send($sock, $buffer, $peer);
  $nbytes = asn_send($sock, $buffer);
  $nbytes = asn_write($fh, $buffer);
  $buffer = asn_get($fh);
  $yes    = asn_ready($fh)
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Convert::ASN1 encodes and decodes ASN.1 data structures using BER/DER rules.
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new_(___s-1OPTIONS_s0__)"><a class="permalink" href="#new_(___s-1OPTIONS_s0__)">new
  ( [OPTIONS] )</a></h2>
Contructor, creates a new object.
<p class="Pp">If given, <b>OPTIONS</b> are the same ones as for &quot;configure
    ( OPTIONS )&quot; below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="error_()"><a class="permalink" href="#error_()">error
  ()</a></h2>
Returns the last error.
</section>
<section class="Ss">
<h2 class="Ss" id="configure_(__s-1OPTIONS_s0_)"><a class="permalink" href="#configure_(__s-1OPTIONS_s0_)">configure
  ( OPTIONS )</a></h2>
Configure options to control how Convert::ASN1 will perform various tasks.
  Options are passed as name-value pairs.
<dl class="Bl-tag">
  <dt>encode</dt>
  <dd>Reference to a hash which contains various encode options.</dd>
  <dt>decode</dt>
  <dd>Reference to a hash which contains various decode options.</dd>
  <dt>encoding</dt>
  <dd>One of 'BER' or 'DER'. The default is 'BER'</dd>
  <dt>tagdefault</dt>
  <dd>One of 'EXPLICIT' or 'IMPLICIT'. Default tagging conventions are normally
      given in the ASN.1 module definition (not supported by the parser). The
      ASN.1 spec states EXPLICIT tagging is the default, but this option has
      IMPLICIT tagging default for backward compatibility reasons.</dd>
</dl>
<p class="Pp">Encode options</p>
<dl class="Bl-tag">
  <dt>real</dt>
  <dd>Which encoding to use for real's. One of 'binary', 'nr1', 'nr2',
    'nr3'</dd>
  <dt>time</dt>
  <dd>This controls how UTCTime and GeneralizedTime elements are encoded. The
      default is <span class="Li">&quot;withzone&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>utctime</dt>
  <dd>The value passed will be encoded without a zone, ie a UTC value.</dd>
  <dt>withzone</dt>
  <dd>The value will be encoded with a zone. By default it will be encoded using
      the local time offset. The offset may be set using the
      <span class="Li">&quot;timezone&quot;</span> configure option.</dd>
  <dt>raw</dt>
  <dd>The value passed should already be in the correct format and will be
      copied into the PDU as-is.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>timezone</dt>
  <dd>By default UTCTime and GeneralizedTime will be encoded using the local
      time offset from UTC. This will over-ride that. It is an offset from UTC
      in seconds. This option can be overridden by passing a reference to a list
      of two values as the time value. The list should contain the time value
      and the offset from UTC in seconds.</dd>
  <dt>bigint</dt>
  <dd>If during encoding an value greater than 32 bits is discovered and is not
      already a big integer object, then the value will first be converted into
      a big integer object. This option controls the big integer class into
      which the objects will be blessed. The default is to use Math::BigInt</dd>
</dl>
<p class="Pp">Decode options</p>
<dl class="Bl-tag">
  <dt>time</dt>
  <dd>This controls how a UTCTime or a GeneralizedTime element will be decoded.
      The default is <span class="Li">&quot;utctime&quot;</span>.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>utctime</dt>
  <dd>The value returned will be a time value as returned by the
      <span class="Li">&quot;time&quot;</span> function.</dd>
  <dt>withzone</dt>
  <dd>The value returned will be a reference to an array of two values. The
      first is the same as with <span class="Li">&quot;utctime&quot;</span>, the
      second is the timezone offset, in seconds, that was used in the
    encoding.</dd>
  <dt>raw</dt>
  <dd>The value returned will be the raw encoding as extracted from the
    PDU.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>bigint</dt>
  <dd>If during decoding any big integers are discovered (integers greater than
      32 bits), they will be decoded into big integer objects. This option
      controls the big integer class into which the objects will be blessed. The
      default is to use Math::BigInt.</dd>
  <dt>null</dt>
  <dd>The value to decode ASN.1 NULL types into. If not set, it defaults to
      <span class="Li">1</span>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="prepare_(__s-1ASN_s0_)"><a class="permalink" href="#prepare_(__s-1ASN_s0_)">prepare
  ( ASN )</a></h2>
Compile the given ASN.1 descripton which can be passed as a string or as a
  filehandle. The syntax used is very close to ASN.1, but has a few differences.
  If the ASN decribes only one macro then encode/decode can be called on this
  object. If ASN describes more than one ASN.1 macro then
  <span class="Li">&quot;find&quot;</span> must be called. The method returns
  undef on error.
</section>
<section class="Ss">
<h2 class="Ss" id="prepare_file_(__s-1ASNPATH_s0_)"><a class="permalink" href="#prepare_file_(__s-1ASNPATH_s0_)">prepare_file
  ( ASNPATH )</a></h2>
Compile the ASN.1 description to be read from the specified pathname.
</section>
<section class="Ss">
<h2 class="Ss" id="find_(__s-1MACRO_s0_)"><a class="permalink" href="#find_(__s-1MACRO_s0_)">find
  ( MACRO )</a></h2>
Find a macro from a prepared ASN.1 description. Returns an object which can be
  used for encode/decode.
</section>
<section class="Ss">
<h2 class="Ss" id="encode_(__s-1VARIABLES_s0_)"><a class="permalink" href="#encode_(__s-1VARIABLES_s0_)">encode
  ( VARIABLES )</a></h2>
Encode a PDU. Top-level variable are passed as name-value pairs, or as a
  reference to a hash containing them. Returns the encoded PDU, or undef on
  error.
</section>
<section class="Ss">
<h2 class="Ss" id="decode_(__s-1PDU_s0_)"><a class="permalink" href="#decode_(__s-1PDU_s0_)">decode
  ( PDU )</a></h2>
Decode the PDU, returns a reference to a hash containg the values for the PDU.
  Returns undef if there was an error.
</section>
<section class="Ss">
<h2 class="Ss" id="registeroid_(__s-1OID,_HANDLER_s0_)"><a class="permalink" href="#registeroid_(__s-1OID,_HANDLER_s0_)">registeroid
  ( OID, HANDLER )</a></h2>
Register a handler for all ASN.1 elements that are
  <span class="Li">&quot;DEFINED BY&quot;</span> the given OID.
<p class="Pp"><b>HANDLER</b> must be a Convert::ASN1 object, e.g. as returned by
    &quot;find ( MACRO )&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="registertype_(__s-1NAME,_OID,_HANDLER_s0_)"><a class="permalink" href="#registertype_(__s-1NAME,_OID,_HANDLER_s0_)">registertype
  ( NAME, OID, HANDLER )</a></h2>
Register a handler for all ASN.1 elements named
  <span class="Li">&quot;NAME&quot;</span>, that are
  <span class="Li">&quot;DEFINED BY&quot;</span> the given OID.
<p class="Pp"><b>HANDLER</b> must be a Convert::ASN1 object, e.g. as returned by
    &quot;find ( MACRO )&quot;.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
As well as providing an object interface for encoding/decoding PDUs
  Convert::ASN1 also provides the following functions.
<section class="Ss">
<h2 class="Ss" id="_s-1IO_s0_Functions"><a class="permalink" href="#_s-1IO_s0_Functions">IO
  Functions</a></h2>
<dl class="Bl-tag">
  <dt>asn_recv ( SOCK, BUFFER, FLAGS )</dt>
  <dd>Will read a single element from the socket SOCK into BUFFER. FLAGS may be
      MSG_PEEK as exported by <span class="Li">&quot;Socket&quot;</span>.
      Returns the address of the sender, or undef if there was an error. Some
      systems do not support the return of the peer address when the socket is a
      connected socket, in these cases the empty string will be returned. This
      is the same behaviour as the <span class="Li">&quot;recv&quot;</span>
      function in perl itself.
    <p class="Pp">It is recommended that if the socket is of type SOCK_DGRAM
        then <span class="Li">&quot;recv&quot;</span> be called directly instead
        of calling <span class="Li">&quot;asn_recv&quot;</span>.</p>
  </dd>
  <dt>asn_read ( FH, BUFFER, OFFSET )</dt>
  <dd></dd>
  <dt>asn_read ( FH, BUFFER )</dt>
  <dd>Will read a single element from the filehandle FH into BUFFER. Returns the
      number of bytes read if a complete element was read, -1 if an incomplete
      element was read or undef if there was an error. If OFFSET is specified
      then it is assumed that BUFFER already contains an incomplete element and
      new data will be appended starting at OFFSET.
    <p class="Pp">If FH is a socket the asn_recv is used to read the element, so
        the same restiction applies if FH is a socket of type SOCK_DGRAM.</p>
  </dd>
  <dt>asn_send ( SOCK, BUFFER, FLAGS, TO )</dt>
  <dd></dd>
  <dt>asn_send ( SOCK, BUFFER, FLAGS )</dt>
  <dd>Identical to calling <span class="Li">&quot;send&quot;</span>, see
      perlfunc</dd>
  <dt>asn_write ( FH, BUFFER )</dt>
  <dd>Identical to calling <span class="Li">&quot;syswrite&quot;</span> with 2
      arguments, see perlfunc</dd>
  <dt>asn_get ( FH )</dt>
  <dd><span class="Li">&quot;asn_get&quot;</span> provides buffered IO. Because
      it needs a buffer FH must be a GLOB or a reference to a GLOB.
      <span class="Li">&quot;asn_get&quot;</span> will use two entries in the
      hash element of the GLOB to use as its buffer:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  asn_buffer - input buffer
  asn_need   - number of bytes needed for the next element, if known
    </pre>
    <p class="Pp">Returns an element or undef if there was an error.</p>
  </dd>
  <dt>asn_ready ( FH )</dt>
  <dd><span class="Li">&quot;asn_ready&quot;</span> works with
      <span class="Li">&quot;asn_get&quot;</span>. It will return true if
      <span class="Li">&quot;asn_get&quot;</span> has already read enough data
      into the buffer to return a complete element.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Encode/Decode_Functions"><a class="permalink" href="#Encode/Decode_Functions">Encode/Decode
  Functions</a></h2>
<dl class="Bl-tag">
  <dt>asn_tag ( CLASS, VALUE )</dt>
  <dd>Given <b>CLASS</b> and a <b>VALUE</b>, calculate an integer which when
      encoded will become the tag.</dd>
  <dt>asn_decode_tag ( TAG )</dt>
  <dd>Decode the given ASN.1 encoded
    <span class="Li">&quot;TAG&quot;</span>.</dd>
  <dt>asn_encode_tag ( TAG )</dt>
  <dd>Encode <b>TAG</b> value for encoding. We assume that the tag has been
      correctly generated with &quot;asn_tag ( CLASS, VALUE )&quot;.</dd>
  <dt>asn_decode_length ( LEN )</dt>
  <dd>Decode the given ASN.1 decoded
    <span class="Li">&quot;LEN&quot;</span>.</dd>
  <dt>asn_encode_length ( LEN )</dt>
  <dd>Encode the given <span class="Li">&quot;LEN&quot;</span> to its ASN.1
      encoding.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Constants"><a class="permalink" href="#Constants">Constants</a></h2>
<dl class="Bl-tag">
  <dt>ASN_BIT_STR</dt>
  <dd></dd>
  <dt>ASN_BOOLEAN</dt>
  <dd></dd>
  <dt>ASN_ENUMERATED</dt>
  <dd></dd>
  <dt>ASN_GENERAL_TIME</dt>
  <dd></dd>
  <dt>ASN_IA5_STR</dt>
  <dd></dd>
  <dt>ASN_INTEGER</dt>
  <dd></dd>
  <dt>ASN_NULL</dt>
  <dd></dd>
  <dt>ASN_OBJECT_ID</dt>
  <dd></dd>
  <dt>ASN_OCTET_STR</dt>
  <dd></dd>
  <dt>ASN_PRINT_STR</dt>
  <dd></dd>
  <dt>ASN_REAL</dt>
  <dd></dd>
  <dt>ASN_SEQUENCE</dt>
  <dd></dd>
  <dt>ASN_SET</dt>
  <dd></dd>
  <dt>ASN_UTC_TIME</dt>
  <dd></dd>
  <dt>ASN_APPLICATION</dt>
  <dd></dd>
  <dt>ASN_CONTEXT</dt>
  <dd></dd>
  <dt>ASN_PRIVATE</dt>
  <dd></dd>
  <dt>ASN_UNIVERSAL</dt>
  <dd></dd>
  <dt>ASN_PRIMITIVE</dt>
  <dd></dd>
  <dt>ASN_CONSTRUCTOR</dt>
  <dd></dd>
  <dt>ASN_LONG_LEN</dt>
  <dd></dd>
  <dt>ASN_EXTENSION_ID</dt>
  <dd></dd>
  <dt>ASN_BIT</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Debug_Functions"><a class="permalink" href="#Debug_Functions">Debug
  Functions</a></h2>
<dl class="Bl-tag">
  <dt>asn_dump ( [FH,] BUFFER )</dt>
  <dd>Try to decode the given buffer as ASN.1 structure and dump it to the given
      file handle, or <span class="Li">&quot;STDERR&quot;</span> if the handle
      is not given.</dd>
  <dt>asn_hexdump ( FH, BUFFER )</dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT_TAGS"><a class="permalink" href="#EXPORT_TAGS">EXPORT
  TAGS</a></h1>
<dl class="Bl-tag">
  <dt>:all</dt>
  <dd>All exported functions</dd>
  <dt>:const</dt>
  <dd>ASN_BOOLEAN, ASN_INTEGER, ASN_BIT_STR, ASN_OCTET_STR, ASN_NULL,
      ASN_OBJECT_ID, ASN_REAL, ASN_ENUMERATED, ASN_SEQUENCE, ASN_SET,
      ASN_PRINT_STR, ASN_IA5_STR, ASN_UTC_TIME, ASN_GENERAL_TIME, ASN_UNIVERSAL,
      ASN_APPLICATION, ASN_CONTEXT, ASN_PRIVATE, ASN_PRIMITIVE, ASN_CONSTRUCTOR,
      ASN_LONG_LEN, ASN_EXTENSION_ID, ASN_BIT</dd>
  <dt>:debug</dt>
  <dd>asn_dump, asn_hexdump</dd>
  <dt>:io</dt>
  <dd>asn_recv, asn_send, asn_read, asn_write, asn_get, asn_ready</dd>
  <dt>:tag</dt>
  <dd>asn_tag, asn_decode_tag, asn_encode_tag, asn_decode_length,
      asn_encode_length</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="MAPPING_ASN.1_TO_PERL"><a class="permalink" href="#MAPPING_ASN.1_TO_PERL">MAPPING
  ASN.1 TO PERL</a></h1>
Every element in the ASN.1 definition has a name, in perl a hash is used with
  these names as an index and the element value as the hash value.
<p class="Pp"><span class="Li"></span></p>
<pre>
  # ASN.1
  int INTEGER,
  str OCTET STRING

  # Perl
  { int =&gt; 5, str =&gt; &quot;text&quot; }
</pre>
<p class="Pp">In the case of a SEQUENCE, SET or CHOICE then the value in the
    namespace will be a hash reference which will be the namespce for the
    elements with that element.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # ASN.1
  int INTEGER,
  seq SEQUENCE {
    str OCTET STRING,
    bool BOOLEAN
  }

  # Perl
  { int =&gt; 5, seq =&gt; { str =&gt; &quot;text&quot;, bool =&gt; 1}}
</pre>
<p class="Pp">If the element is a SEQUENCE OF, or SET OF, then the value in the
    namespace will be an array reference. The elements in the array will be of
    the type expected by the type following the OF. For example with
    &quot;SEQUENCE OF STRING&quot; the array would contain strings. With
    &quot;SEQUENCE OF SEQUENCE { ... }&quot; the array will contain hash
    references which will be used as namespaces</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # ASN.1
  int INTEGER,
  str SEQUENCE OF OCTET STRING

  # Perl
  { int =&gt; 5, str =&gt; [ &quot;text1&quot;, &quot;text2&quot;]}

  # ASN.1
  int INTEGER,
  str SEQUENCE OF SEQUENCE {
    type OCTET STRING,
    value INTEGER
  }

  # Perl
  { int =&gt; 5, str =&gt; [
    { type =&gt; &quot;abc&quot;, value =&gt; 4 },
    { type =&gt; &quot;def&quot;, value =&gt; -1 },
  ]}
</pre>
<p class="Pp">Finally, if you wish to pre-parse ASN.1 and hold it to include
    inline in your PDU, you can coerce it into the ASN.1 spec by defining the
    value as ANY in the schema, and then pass the pre encoded value inline.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # ASN.1
  int INTEGER,
  str OCTET STRING,
  pre ANY

  # Perl
  { int =&gt; 5, str =&gt; &quot;text&quot;, pre=&gt;&quot;\x03\x03\x00\x0a\x05&quot; }
</pre>
<p class="Pp">passes a pre-encoded BIT STRING instance as hex text. -But it
    could be a previous run of <span class="Li">$obj</span>-&gt;<b>encode()</b>
    from another run held in some variable.</p>
<section class="Ss">
<h2 class="Ss" id="Exceptions"><a class="permalink" href="#Exceptions">Exceptions</a></h2>
There are some exceptions where Convert::ASN1 does not require an element to be
  named. These are SEQUENCE {...}, SET {...} and CHOICE. In each case if the
  element is not given a name then the elements inside the {...} will share the
  same namespace as the elements outside of the {...}.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TODO"><a class="permalink" href="#TODO">TODO</a></h1>
<ul class="Bl-bullet">
  <li>XS implementation.</li>
  <li>More documentation.</li>
  <li>More tests.</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Graham Barr &lt;gbarr@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
Report issues via github at https://github.com/gbarr/perl-Convert-ASN1/issues
<p class="Pp">To contribute I encourage you to create a git fork of the
    repository at https://github.com/gbarr/perl-Convert-ASN1 do you work on a
    fresh branch created from master and submit a pull request</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c) 2000-2012 Graham Barr &lt;gbarr@cpan.org&gt;. All rights reserved.
  This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-06-25</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
