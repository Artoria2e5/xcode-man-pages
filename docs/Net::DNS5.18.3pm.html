<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Net::DNS(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Net::DNS(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Net::DNS(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Net::DNS - Perl interface to the Domain Name System
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use Net::DNS;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Net::DNS is a collection of Perl modules that act as a Domain Name System (DNS)
  resolver. It allows the programmer to perform DNS queries that are beyond the
  capabilities of <span class="Li">&quot;gethostbyname&quot;</span> and
  <span class="Li">&quot;gethostbyaddr&quot;</span>.
<p class="Pp">The programmer should be somewhat familiar with the format of a
    DNS packet and its various sections. See RFC 1035 or <i>DNS and BIND</i>
    (Albitz &amp; Liu) for details.</p>
<section class="Ss">
<h2 class="Ss" id="Resolver_Objects"><a class="permalink" href="#Resolver_Objects">Resolver
  Objects</a></h2>
A resolver object is an instance of the Net::DNS::Resolver class. A program can
  have multiple resolver objects, each maintaining its own state information
  such as the nameservers to be queried, whether recursion is desired, etc.
</section>
<section class="Ss">
<h2 class="Ss" id="Packet_Objects"><a class="permalink" href="#Packet_Objects">Packet
  Objects</a></h2>
Net::DNS::Resolver queries return Net::DNS::Packet objects. Packet objects have
  five sections:
<ul class="Bl-bullet">
  <li>The header section, a Net::DNS::Header object.</li>
  <li>The question section, a list of Net::DNS::Question objects.</li>
  <li>The answer section, a list of Net::DNS::RR objects.</li>
  <li>The authority section, a list of Net::DNS::RR objects.</li>
  <li>The additional section, a list of Net::DNS::RR objects.</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Update_Objects"><a class="permalink" href="#Update_Objects">Update
  Objects</a></h2>
The Net::DNS::Update package is a subclass of Net::DNS::Packet for creating
  packet objects to be used in dynamic updates.
</section>
<section class="Ss">
<h2 class="Ss" id="Header_Objects"><a class="permalink" href="#Header_Objects">Header
  Objects</a></h2>
Net::DNS::Header objects represent the header section of a DNS packet.
</section>
<section class="Ss">
<h2 class="Ss" id="Question_Objects"><a class="permalink" href="#Question_Objects">Question
  Objects</a></h2>
Net::DNS::Question objects represent the question section of a DNS packet.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1RR_s0_Objects"><a class="permalink" href="#_s-1RR_s0_Objects">RR
  Objects</a></h2>
Net::DNS::RR is the base class for DNS resource record (RR) objects in the
  answer, authority, and additional sections of a DNS packet.
<p class="Pp">Don't assume that RR objects will be of the type you requested --
    always check an RR object's type before calling any of its methods.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
See the manual pages listed above for other class-specific methods.
<section class="Ss">
<h2 class="Ss" id="version"><a class="permalink" href="#version">version</a></h2>
<span class="Li"></span>
<pre>
    print Net::DNS-&gt;version, &quot;\n&quot;;
</pre>
<p class="Pp">Returns the version of Net::DNS.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mx"><a class="permalink" href="#mx">mx</a></h2>
<span class="Li"></span>
<pre>
    # Use a default resolver -- can't get an error string this way.
    use Net::DNS;
    my @mx = mx(&quot;example.com&quot;);

    # Use your own resolver object.
    use Net::DNS;
    my $res = Net::DNS::Resolver-&gt;new;
    my  @mx = mx($res, &quot;example.com&quot;);
</pre>
<p class="Pp">Returns a list of Net::DNS::RR::MX objects representing the MX
    records for the specified name; the list will be sorted by preference.
    Returns an empty list if the query failed or no MX records were found.</p>
<p class="Pp">This method does not look up A records -- it only performs MX
    queries.</p>
<p class="Pp">See &quot;EXAMPLES&quot; for a more complete example.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="yxrrset"><a class="permalink" href="#yxrrset">yxrrset</a></h2>
Use this method to add an &quot;RRset exists&quot; prerequisite to a dynamic
  update packet. There are two forms, value-independent and value-dependent:
<p class="Pp"><span class="Li"></span></p>
<pre>
    # RRset exists (value-independent)
    $update-&gt;push(pre =&gt; yxrrset(&quot;host.example.com A&quot;));
</pre>
<p class="Pp">Meaning: At least one RR with the specified name and type must
    exist.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # RRset exists (value-dependent)
    $packet-&gt;push(pre =&gt; yxrrset(&quot;host.example.com A 10.1.2.3&quot;));
</pre>
<p class="Pp">Meaning: At least one RR with the specified name and type must
    exist and must have matching data.</p>
<p class="Pp">Returns a <span class="Li">&quot;Net::DNS::RR&quot;</span> object
    or <span class="Li">&quot;undef&quot;</span> if the object couldn't be
    created.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="nxrrset"><a class="permalink" href="#nxrrset">nxrrset</a></h2>
Use this method to add an &quot;RRset does not exist&quot; prerequisite to a
  dynamic update packet.
<p class="Pp"><span class="Li"></span></p>
<pre>
    $packet-&gt;push(pre =&gt; nxrrset(&quot;host.example.com A&quot;));
</pre>
<p class="Pp">Meaning: No RRs with the specified name and type can exist.</p>
<p class="Pp">Returns a <span class="Li">&quot;Net::DNS::RR&quot;</span> object
    or <span class="Li">&quot;undef&quot;</span> if the object couldn't be
    created.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="yxdomain"><a class="permalink" href="#yxdomain">yxdomain</a></h2>
Use this method to add a &quot;name is in use&quot; prerequisite to a dynamic
  update packet.
<p class="Pp"><span class="Li"></span></p>
<pre>
    $packet-&gt;push(pre =&gt; yxdomain(&quot;host.example.com&quot;));
</pre>
<p class="Pp">Meaning: At least one RR with the specified name must exist.</p>
<p class="Pp">Returns a <span class="Li">&quot;Net::DNS::RR&quot;</span> object
    or <span class="Li">&quot;undef&quot;</span> if the object couldn't be
    created.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="nxdomain"><a class="permalink" href="#nxdomain">nxdomain</a></h2>
Use this method to add a &quot;name is not in use&quot; prerequisite to a
  dynamic update packet.
<p class="Pp"><span class="Li"></span></p>
<pre>
    $packet-&gt;push(pre =&gt; nxdomain(&quot;host.example.com&quot;));
</pre>
<p class="Pp">Meaning: No RR with the specified name can exist.</p>
<p class="Pp">Returns a <span class="Li">&quot;Net::DNS::RR&quot;</span> object
    or <span class="Li">&quot;undef&quot;</span> if the object couldn't be
    created.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="rr_add"><a class="permalink" href="#rr_add">rr_add</a></h2>
Use this method to add RRs to a zone.
<p class="Pp"><span class="Li"></span></p>
<pre>
    $packet-&gt;push(update =&gt; rr_add(&quot;host.example.com A 10.1.2.3&quot;));
</pre>
<p class="Pp">Meaning: Add this RR to the zone.</p>
<p class="Pp">RR objects created by this method should be added to the
    &quot;update&quot; section of a dynamic update packet. The TTL defaults to
    86400 seconds (24 hours) if not specified.</p>
<p class="Pp">Returns a <span class="Li">&quot;Net::DNS::RR&quot;</span> object
    or <span class="Li">&quot;undef&quot;</span> if the object couldn't be
    created.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="rr_del"><a class="permalink" href="#rr_del">rr_del</a></h2>
Use this method to delete RRs from a zone. There are three forms: delete an
  RRset, delete all RRsets, and delete an RR.
<p class="Pp"><span class="Li"></span></p>
<pre>
    # Delete an RRset.
    $packet-&gt;push(update =&gt; rr_del(&quot;host.example.com A&quot;));
</pre>
<p class="Pp">Meaning: Delete all RRs having the specified name and type.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # Delete all RRsets.
    $packet-&gt;push(update =&gt; rr_del(&quot;host.example.com&quot;));
</pre>
<p class="Pp">Meaning: Delete all RRs having the specified name.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # Delete an RR.
    $packet-&gt;push(update =&gt; rr_del(&quot;host.example.com A 10.1.2.3&quot;));
</pre>
<p class="Pp">Meaning: Delete all RRs having the specified name, type, and
  data.</p>
<p class="Pp">RR objects created by this method should be added to the
    &quot;update&quot; section of a dynamic update packet.</p>
<p class="Pp">Returns a <span class="Li">&quot;Net::DNS::RR&quot;</span> object
    or <span class="Li">&quot;undef&quot;</span> if the object couldn't be
    created.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Zone_Serial_Number_Management"><a class="permalink" href="#Zone_Serial_Number_Management">Zone
  Serial Number Management</a></h1>
The Net::DNS module provides auxiliary functions which support policy-driven
  zone serial numbering regimes.
<section class="Ss">
<h2 class="Ss" id="Strictly_Sequential"><a class="permalink" href="#Strictly_Sequential">Strictly
  Sequential</a></h2>
<span class="Li"></span>
<pre>
    $successor = $soa-&gt;serial( SEQUENTIAL );
</pre>
<p class="Pp">The existing serial number is incremented modulo 2**32.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Time_Encoded"><a class="permalink" href="#Time_Encoded">Time
  Encoded</a></h2>
<span class="Li"></span>
<pre>
    $successor = $soa-&gt;serial( UNIXTIME );
</pre>
<p class="Pp">The Unix time scale will be used as the basis for zone serial
    numbering. The serial number will be incremented if the time elapsed since
    the previous update is less than one second.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Date_Encoded"><a class="permalink" href="#Date_Encoded">Date
  Encoded</a></h2>
<span class="Li"></span>
<pre>
    $successor = $soa-&gt;serial( YYYYMMDDxx );
</pre>
<p class="Pp">The 32 bit value returned by the auxiliary <i>YYYYMMDDxx()</i>
    function will be used as the base for the date-coded zone serial number.
    Serial number increments must be limited to 100 per day for the date
    information to remain useful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Sorting_of__s-1RR_s0_arrays"><a class="permalink" href="#Sorting_of__s-1RR_s0_arrays">Sorting
  of RR arrays</a></h2>
As of version 0.55 there is functionality to help you sort RR arrays.
  '<i>rrsort()</i>' is the function that is available to do the sorting. In most
  cases rrsort will give you the answer that you want but you can specify your
  own sorting method by using the Net::DNS::RR::FOO-&gt;<i>set_rrsort_func()</i>
  class method. See Net::DNS::RR for details.
<p class="Pp"><i></i><i>rrsort()</i><i></i></p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   use Net::DNS qw(rrsort);

   my @prioritysorted=rrsort(&quot;SRV&quot;,&quot;priority&quot;,@rr_array);
</pre>
<p class="Pp"><i>rrsort()</i> selects all RRs from the input array that are of
    the type that are defined in the first argument. Those RRs are sorted based
    on the attribute that is specified as second argument.</p>
<p class="Pp">There are a number of RRs for which the sorting function is
    specifically defined for certain attributes. If such sorting function is
    defined in the code (it can be set or overwritten using the
    <i>set_rrsort_func()</i> class method) that function is used.</p>
<p class="Pp">For instance:
   my
    <span class="Li">@prioritysorted</span>=rrsort(&quot;SRV&quot;,&quot;priority&quot;,@rr_array);
    returns the SRV records sorted from lowest to heighest priority and for
    equal priorities from heighes to lowes weight.</p>
<p class="Pp">If the function does not exist then a numerical sort on the
    attribute value is performed.
   my
    <span class="Li">@portsorted</span>=rrsort(&quot;SRV&quot;,&quot;port&quot;,@rr_array);</p>
<p class="Pp">If the attribute does not exist for a certain RR than the RRs are
    sorted on string comparrisson of the rdata.</p>
<p class="Pp">If the attribute is not defined than either the default_sort
    function will be defined or &quot;Canonical sorting&quot; (as defined by
    DNSSEC) will be used.</p>
<p class="Pp"><i>rrsort()</i> returns a sorted array with only elements of the
    specified RR type or undef.</p>
<p class="Pp"><i>rrsort()</i> returns undef when arguments are incorrect.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
The following examples show how to use the
  <span class="Li">&quot;Net::DNS&quot;</span> modules. See the other manual
  pages and the demo scripts included with the source code for additional
  examples.
<p class="Pp">See the <span class="Li">&quot;Net::DNS::Update&quot;</span>
    manual page for an example of performing dynamic updates.</p>
<section class="Ss">
<h2 class="Ss" id="Look_up_a_host's_addresses."><a class="permalink" href="#Look_up_a_host's_addresses.">Look
  up a host's addresses.</a></h2>
<span class="Li"></span>
<pre>
  use Net::DNS;
  my $res   = Net::DNS::Resolver-&gt;new;
  my $query = $res-&gt;search(&quot;host.example.com&quot;);

  if ($query) {
      foreach my $rr ($query-&gt;answer) {
          next unless $rr-&gt;type eq &quot;A&quot;;
          print $rr-&gt;address, &quot;\n&quot;;
      }
  } else {
      warn &quot;query failed: &quot;, $res-&gt;errorstring, &quot;\n&quot;;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Find_the_nameservers_for_a_domain."><a class="permalink" href="#Find_the_nameservers_for_a_domain.">Find
  the nameservers for a domain.</a></h2>
<span class="Li"></span>
<pre>
  use Net::DNS;
  my $res   = Net::DNS::Resolver-&gt;new;
  my $query = $res-&gt;query(&quot;example.com&quot;, &quot;NS&quot;);

  if ($query) {
      foreach $rr (grep { $_-&gt;type eq 'NS' } $query-&gt;answer) {
          print $rr-&gt;nsdname, &quot;\n&quot;;
      }
  }
  else {
      warn &quot;query failed: &quot;, $res-&gt;errorstring, &quot;\n&quot;;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Find_the__s-1MX_s0_records_for_a_domain."><a class="permalink" href="#Find_the__s-1MX_s0_records_for_a_domain.">Find
  the MX records for a domain.</a></h2>
<span class="Li"></span>
<pre>
  use Net::DNS;
  my $name = &quot;example.com&quot;;
  my $res  = Net::DNS::Resolver-&gt;new;
  my @mx   = mx($res, $name);

  if (@mx) {
      foreach $rr (@mx) {
          print $rr-&gt;preference, &quot; &quot;, $rr-&gt;exchange, &quot;\n&quot;;
      }
  } else {
      warn &quot;Can't find MX records for $name: &quot;, $res-&gt;errorstring, &quot;\n&quot;;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Print_a_domain's__s-1SOA_s0_record_in_zone_file_format."><a class="permalink" href="#Print_a_domain's__s-1SOA_s0_record_in_zone_file_format.">Print
  a domain's SOA record in zone file format.</a></h2>
<span class="Li"></span>
<pre>
  use Net::DNS;
  my $res   = Net::DNS::Resolver-&gt;new;
  my $query = $res-&gt;query(&quot;example.com&quot;, &quot;SOA&quot;);

  if ($query) {
      ($query-&gt;answer)[0]-&gt;print;
  } else {
      print &quot;query failed: &quot;, $res-&gt;errorstring, &quot;\n&quot;;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Perform_a_zone_transfer_and_print_all_the_records."><a class="permalink" href="#Perform_a_zone_transfer_and_print_all_the_records.">Perform
  a zone transfer and print all the records.</a></h2>
<span class="Li"></span>
<pre>
  use Net::DNS;
  my $res  = Net::DNS::Resolver-&gt;new;
  $res-&gt;nameservers(&quot;ns.example.com&quot;);

  my @zone = $res-&gt;axfr(&quot;example.com&quot;);

  foreach $rr (@zone) {
      $rr-&gt;print;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Perform_a_background_query_and_do_some_other_work_while_waiting_for_the_answer."><a class="permalink" href="#Perform_a_background_query_and_do_some_other_work_while_waiting_for_the_answer.">Perform
  a background query and do some other work while waiting for the
  answer.</a></h2>
<span class="Li"></span>
<pre>
  use Net::DNS;
  my $res    = Net::DNS::Resolver-&gt;new;
  my $socket = $res-&gt;bgsend(&quot;host.example.com&quot;);

  until ($res-&gt;bgisready($socket)) {
      # do some work here while waiting for the answer
      # ...and some more here
  }

  my $packet = $res-&gt;bgread($socket);
  $packet-&gt;print;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Send_a_background_query_and_use_select_to_determine_when_the_answer_has_arrived."><a class="permalink" href="#Send_a_background_query_and_use_select_to_determine_when_the_answer_has_arrived.">Send
  a background query and use select to determine when the answer has
  arrived.</a></h2>
<span class="Li"></span>
<pre>
  use Net::DNS;
  use IO::Select;

  my $timeout = 5;
  my $res     = Net::DNS::Resolver-&gt;new;
  my $bgsock  = $res-&gt;bgsend(&quot;host.example.com&quot;);
  my $sel     = IO::Select-&gt;new($bgsock);

  # Add more sockets to $sel if desired.
  my @ready = $sel-&gt;can_read($timeout);
  if (@ready) {
      foreach my $sock (@ready) {
          if ($sock == $bgsock) {
              my $packet = $res-&gt;bgread($bgsock);
              $packet-&gt;print;
              $bgsock = undef;
          }
          # Check for the other sockets.
          $sel-&gt;remove($sock);
          $sock = undef;
      }
  } else {
      warn &quot;timed out after $timeout seconds\n&quot;;
  }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<span class="Li">&quot;Net::DNS&quot;</span> is slow.
<p class="Pp">For other items to be fixed, or if you discover a bug in this
    distribution please use the CPAN bug reporting system.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c)1997-2002 Michael Fuhr. Portions Copyright(c)2002-2004 Chris
  Reinhardt. Portions Copyright(c)2005 Olaf Kolkman (RIPE NCC) Portions
  Copyright(c)2006 Olaf Kolkman (NLnet Labs)
<p class="Pp">All rights reserved.</p>
<p class="Pp">This program is free software; you may redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_INFORMATION"><a class="permalink" href="#AUTHOR_INFORMATION">AUTHOR
  INFORMATION</a></h1>
Net::DNS is currently maintained at NLnet Labs (www.nlnetlabs.nl) by:
 Olaf Kolkman 	olaf@net-dns.org
<p class="Pp">Between 2002 and 2004 Net::DNS was maintained by:
   Chris Reinhardt</p>
<p class="Pp">Net::DNS was created by: 	Michael Fuhr 	mike@fuhr.org</p>
<p class="Pp">For more information see:
   http://www.net-dns.org/</p>
<p class="Pp">Stay tuned and syndicate:
   http://www.net-dns.org/blog/</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perl, Net::DNS::Resolver, Net::DNS::Packet, Net::DNS::Update, Net::DNS::Header,
  Net::DNS::Question, Net::DNS::RR, RFC 1035, <i>DNS and BIND</i> by Paul Albitz
  &amp; Cricket Liu
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-16</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
