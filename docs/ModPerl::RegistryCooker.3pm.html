<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>install::TempContent::Objects::mod_perl-2.0.9::docs::api::ModPerl::RegistryCooker(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">install::TempContent::Objects::mod_perl-2.0.9::docs::api::ModPerl::RegistryCooker(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">install::TempContent::Objects::mod_perl-2.0.9::docs::api::ModPerl::RegistryCooker(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
ModPerl::RegistryCooker - Cook mod_perl 2.0 Registry Modules
</section>
<section class="Sh">
<h1 class="Sh" id="Synopsis"><a class="permalink" href="#Synopsis">Synopsis</a></h1>
<span class="Li"></span>
<pre>
  # shouldn't be used as-is but sub-classed first
  # see ModPerl::Registry for an example
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Description"><a class="permalink" href="#Description">Description</a></h1>
<span class="Li">&quot;ModPerl::RegistryCooker&quot;</span> is used to create
  flexible and overridable registry modules which emulate mod_cgi for Perl
  scripts. The concepts are discussed in the manpage of the following modules:
  <span class="Li">&quot;ModPerl::Registry&quot;</span>,
  <span class="Li">&quot;ModPerl::Registry&quot;</span> and
  <span class="Li">&quot;ModPerl::RegistryBB&quot;</span>.
<p class="Pp"><span class="Li">&quot;ModPerl::RegistryCooker&quot;</span> has
    two purposes:</p>
<ul class="Bl-bullet">
  <li>Provide ingredients that can be used by registry sub-classes</li>
  <li>Provide a default behavior, which can be overriden in sub-classed
    <p class="Pp">META: in the future this functionality may move into a
        separate class.</p>
  </li>
</ul>
<p class="Pp">Here are the current overridable methods:</p>
<p class="Pp">META: these are all documented in RegistryCooker.pm, though not
    using pod. please help to port these to pod and move the descriptions
  here.</p>
<ul class="Bl-bullet">
  <li><i>new()</i>
    <p class="Pp">create the class's object, bless it and return it</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $obj = $class-&gt;new($r);
    </pre>
    <p class="Pp"><span class="Li">$class</span> -- the registry class, usually
        <span class="Li">&quot;__PACKAGE__&quot;</span> can be used.</p>
    <p class="Pp"><span class="Li">$r</span> --
        <span class="Li">&quot;Apache2::Request&quot;</span> object.</p>
    <p class="Pp">default: <i>new()</i></p>
  </li>
  <li><i>init()</i>
    <p class="Pp">initializes the data object's fields:
        <span class="Li">&quot;REQ&quot;</span>,
        <span class="Li">&quot;FILENAME&quot;</span>,
        <span class="Li">&quot;URI&quot;</span>. Called from the
      <i>new()</i>.</p>
    <p class="Pp">default: <i>init()</i></p>
  </li>
  <li><i>default_handler()</i>
    <p class="Pp">default: <i>default_handler()</i></p>
  </li>
  <li><i>run()</i>
    <p class="Pp">default: <i>run()</i></p>
  </li>
  <li><i>can_compile()</i>
    <p class="Pp">default: <i>can_compile()</i></p>
  </li>
  <li><i>make_namespace()</i>
    <p class="Pp">default: <i>make_namespace()</i></p>
  </li>
  <li><i>namespace_root()</i>
    <p class="Pp">default: <i>namespace_root()</i></p>
  </li>
  <li><i>namespace_from()</i>
    <p class="Pp">If <span class="Li">&quot;namespace_from_uri&quot;</span> is
        used and the script is called from the virtual host, by default the
        virtual host name is prepended to the uri when package name for the
        compiled script is created. Sometimes this behavior is undesirable,
        e.g., when the same (physical) script is accessed using the same
        path_info but different virtual hosts. In that case you can make the
        script compiled only once for all vhosts, by specifying:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $ModPerl::RegistryCooker::NameWithVirtualHost = 0;
    </pre>
    <p class="Pp">The drawback is that it affects the global environment and all
        other scripts will be compiled ignoring virtual hosts.</p>
    <p class="Pp">default: <i>namespace_from()</i></p>
  </li>
  <li><i>is_cached()</i>
    <p class="Pp">default: <i>is_cached()</i></p>
  </li>
  <li><i>should_compile()</i>
    <p class="Pp">default: <i>should_compile()</i></p>
  </li>
  <li><i>flush_namespace()</i>
    <p class="Pp">default: <i>flush_namespace()</i></p>
  </li>
  <li><i>cache_table()</i>
    <p class="Pp">default: <i>cache_table()</i></p>
  </li>
  <li><i>cache_it()</i>
    <p class="Pp">default: <i>cache_it()</i></p>
  </li>
  <li><i>read_script()</i>
    <p class="Pp">default: <i>read_script()</i></p>
  </li>
  <li><i>shebang_to_perl()</i>
    <p class="Pp">default: <i>shebang_to_perl()</i></p>
  </li>
  <li><i>get_script_name()</i>
    <p class="Pp">default: <i>get_script_name()</i></p>
  </li>
  <li><i>chdir_file()</i>
    <p class="Pp">default: <i>chdir_file()</i></p>
  </li>
  <li><i>get_mark_line()</i>
    <p class="Pp">default: <i>get_mark_line()</i></p>
  </li>
  <li><i>compile()</i>
    <p class="Pp">default: <i>compile()</i></p>
  </li>
  <li><i>error_check()</i>
    <p class="Pp">default: <i>error_check()</i></p>
  </li>
  <li><i>strip_end_data_segment()</i>
    <p class="Pp">default: <i>strip_end_data_segment()</i></p>
  </li>
  <li><i>convert_script_to_compiled_handler()</i>
    <p class="Pp">default: <i>convert_script_to_compiled_handler()</i></p>
  </li>
</ul>
<section class="Ss">
<h2 class="Ss" id="Special_Predefined_Functions"><a class="permalink" href="#Special_Predefined_Functions">Special
  Predefined Functions</a></h2>
The following functions are implemented as constants.
<ul class="Bl-bullet">
  <li><i>NOP()</i>
    <p class="Pp">Use when the function shouldn't do anything.</p>
  </li>
  <li><i>TRUE()</i>
    <p class="Pp">Use when a function should always return a true value.</p>
  </li>
  <li><i>FALSE()</i>
    <p class="Pp">Use when a function should always return a false value.</p>
  </li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Sub-classing_Techniques"><a class="permalink" href="#Sub-classing_Techniques">Sub-classing
  Techniques</a></h1>
To override the default
  <span class="Li">&quot;ModPerl::RegistryCooker&quot;</span> methods, first,
  sub-class <span class="Li">&quot;ModPerl::RegistryCooker&quot;</span> or one
  of its existing sub-classes, using <span class="Li">&quot;use
  base&quot;</span>. Second, override the methods.
<p class="Pp">Those methods that weren't overridden will be resolved at run time
    when used for the first time and cached for the future requests. One way to
    to shortcut this first run resolution is to use the symbol aliasing feature.
    For example to alias
    <span class="Li">&quot;ModPerl::MyRegistry::flush_namespace&quot;</span> as
    <span class="Li">&quot;ModPerl::RegistryCooker::flush_namespace&quot;</span>,
    you can do:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package ModPerl::MyRegistry;
  use base qw(ModPerl::RegistryCooker);
  *ModPerl::MyRegistry::flush_namespace =
      \&amp;ModPerl::RegistryCooker::flush_namespace;
  1;
</pre>
<p class="Pp">In fact, it's a good idea to explicitly alias all the methods so
    you know exactly what functions are used, rather then relying on the
    defaults. For that purpose
    <span class="Li">&quot;ModPerl::RegistryCooker&quot;</span> class method
    <i>install_aliases()</i> can be used. Simply prepare a hash with method
    names in the current package as keys and corresponding fully qualified
    methods to be aliased for as values and pass it to <i>install_aliases()</i>.
    Continuing our example we could do:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  package ModPerl::MyRegistry;
  use base qw(ModPerl::RegistryCooker);
  my %aliases = (
      flush_namespace =&gt; 'ModPerl::RegistryCooker::flush_namespace',
  );
  __PACKAGE__-&gt;install_aliases(\%aliases);
  1;
</pre>
<p class="Pp">The values use fully qualified packages so you can mix methods
    from different classes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Examples"><a class="permalink" href="#Examples">Examples</a></h1>
The best examples are existing core registry modules:
  <span class="Li">&quot;ModPerl::Registry&quot;</span>,
  <span class="Li">&quot;ModPerl::Registry&quot;</span> and
  <span class="Li">&quot;ModPerl::RegistryBB&quot;</span>. Look at the source
  code and their manpages to see how they subclass
  <span class="Li">&quot;ModPerl::RegistryCooker&quot;</span>.
<p class="Pp">For example by default
    <span class="Li">&quot;ModPerl::Registry&quot;</span> uses the script's path
    when creating a package's namespace. If for example you want to use a uri
    instead you can override it with:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  *ModPerl::MyRegistry::namespace_from =
      \&amp;ModPerl::RegistryCooker::namespace_from_uri;
  1;
</pre>
<p class="Pp">Since the <span class="Li">&quot;namespace_from_uri&quot;</span>
    component already exists in
    <span class="Li">&quot;ModPerl::RegistryCooker&quot;</span>. If you want to
    write your own method, e.g., that creates a namespace based on the inode,
    you can do:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub namespace_from_inode {
      my $self = shift;
      return (stat $self-&gt;[FILENAME])[1];
  }
</pre>
<p class="Pp">META: when <span class="Li">$r</span>-&gt;finfo will be ported
    it'll be more effecient. (stat <span class="Li">$r</span>-&gt;finfo)[1]</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Authors"><a class="permalink" href="#Authors">Authors</a></h1>
Doug MacEachern
<p class="Pp">Stas Bekman</p>
</section>
<section class="Sh">
<h1 class="Sh" id="See_Also"><a class="permalink" href="#See_Also">See
  Also</a></h1>
<span class="Li">&quot;ModPerl::Registry&quot;</span>,
  <span class="Li">&quot;ModPerl::RegistryBB&quot;</span> and
  <span class="Li">&quot;ModPerl::PerlRun&quot;</span>.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-06-18</td>
    <td class="foot-os">perl v5.18.2</td>
  </tr>
</table>
</body>
</html>
