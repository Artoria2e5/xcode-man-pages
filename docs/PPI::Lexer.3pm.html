<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PPI::Lexer(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PPI::Lexer(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">PPI::Lexer(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
PPI::Lexer - The PPI Lexer
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use PPI;
  
  # Create a new Lexer
  my $Lexer = PPI::Lexer-&gt;new;
  
  # Build a PPI::Document object from a Token stream
  my $Tokenizer = PPI::Tokenizer-&gt;load('My/Module.pm');
  my $Document = $Lexer-&gt;lex_tokenizer($Tokenizer);
  
  # Build a PPI::Document object for some raw source
  my $source = &quot;print 'Hello World!'; kill(Humans-&gt;all);&quot;;
  $Document = $Lexer-&gt;lex_source($source);
  
  # Build a PPI::Document object for a particular file name
  $Document = $Lexer-&gt;lex_file('My/Module.pm');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The is the PPI Lexer. In the larger scheme of things, its job is to take token
  streams, in a variety of forms, and &quot;lex&quot; them into nested
  structures.
<p class="Pp">Pretty much everything in this module happens behind the scenes at
    this point. In fact, at the moment you don't really need to instantiate the
    lexer at all, the three main methods will auto-instantiate themselves a
    <span class="Li">&quot;PPI::Lexer&quot;</span> object as needed.</p>
<p class="Pp">All methods do a one-shot &quot;lex this and give me a
    PPI::Document object&quot;.</p>
<p class="Pp">In fact, if you are reading this, what you <b>probably</b> want to
    do is to just &quot;load a document&quot;, in which case you can do this in
    a much more direct and concise manner with one of the following.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use PPI;
  
  $Document = PPI::Document-&gt;load( $filename );
  $Document = PPI::Document-&gt;new( $string );
</pre>
<p class="Pp">See PPI::Document for more details.</p>
<p class="Pp">For more unusual tasks, by all means forge onwards.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new"><a class="permalink" href="#new">new</a></h2>
The <span class="Li">&quot;new&quot;</span> constructor creates a new
  <span class="Li">&quot;PPI::Lexer&quot;</span> object. The object itself is
  merely used to hold various buffers and state data during the lexing process,
  and holds no significant data between -&gt;lex_xxxxx calls.
<p class="Pp">Returns a new <span class="Li">&quot;PPI::Lexer&quot;</span>
    object</p>
</section>
<section class="Ss">
<h2 class="Ss" id="lex_file_$filename"><a class="permalink" href="#lex_file_$filename">lex_file
  $filename</a></h2>
The <span class="Li">&quot;lex_file&quot;</span> method takes a filename as
  argument. It then loads the file, creates a PPI::Tokenizer for the content and
  lexes the token stream produced by the tokenizer. Basically, a sort of
  all-in-one method for getting a PPI::Document object from a file name.
<p class="Pp">Returns a PPI::Document object, or
    <span class="Li">&quot;undef&quot;</span> on error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="lex_source_$string"><a class="permalink" href="#lex_source_$string">lex_source
  $string</a></h2>
The <span class="Li">&quot;lex_source&quot;</span> method takes a normal scalar
  string as argument. It creates a PPI::Tokenizer object for the string, and
  then lexes the resulting token stream.
<p class="Pp">Returns a PPI::Document object, or
    <span class="Li">&quot;undef&quot;</span> on error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="lex_tokenizer_$Tokenizer"><a class="permalink" href="#lex_tokenizer_$Tokenizer">lex_tokenizer
  $Tokenizer</a></h2>
The <span class="Li">&quot;lex_tokenizer&quot;</span> takes as argument a
  PPI::Tokenizer object. It lexes the token stream from the tokenizer into a
  PPI::Document object.
<p class="Pp">Returns a PPI::Document object, or
    <span class="Li">&quot;undef&quot;</span> on error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="errstr"><a class="permalink" href="#errstr">errstr</a></h2>
For any error that occurs, you can use the
  <span class="Li">&quot;errstr&quot;</span>, as either a static or object
  method, to access the error message.
<p class="Pp">If no error occurs for any particular action,
    <span class="Li">&quot;errstr&quot;</span> will return false.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TO_DO"><a class="permalink" href="#TO_DO">TO DO</a></h1>
- Add optional support for some of the more common source filters
<p class="Pp">- Some additional checks for blessing things into various
    Statement and Structure subclasses.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
See the support section in the main module.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Adam Kennedy &lt;adamk@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright 2001 - 2011 Adam Kennedy.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">The full text of the license can be found in the LICENSE file
    included with this module.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-07-09</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
