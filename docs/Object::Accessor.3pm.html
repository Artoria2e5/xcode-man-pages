<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Object::Accessor(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Object::Accessor(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Object::Accessor(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Object::Accessor - interface to create per object accessors
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    ### using the object
    $obj = Object::Accessor-&gt;new;        # create object
    $obj = Object::Accessor-&gt;new(@list); # create object with accessors
    $obj = Object::Accessor-&gt;new(\%h);   # create object with accessors
                                         # and their allow handlers

    $bool   = $obj-&gt;mk_accessors('foo'); # create accessors
    $bool   = $obj-&gt;mk_accessors(        # create accessors with input
               {foo =&gt; ALLOW_HANDLER} ); # validation

    $bool   = $obj-&gt;mk_aliases(          # create an alias to an existing
                alias_name =&gt; 'method'); # method name

    $clone  = $obj-&gt;mk_clone;            # create a clone of original
                                         # object without data
    $bool   = $obj-&gt;mk_flush;            # clean out all data

    @list   = $obj-&gt;ls_accessors;        # retrieves a list of all
                                         # accessors for this object

    $bar    = $obj-&gt;foo('bar');          # set 'foo' to 'bar'
    $bar    = $obj-&gt;foo();               # retrieve 'bar' again

    $sub    = $obj-&gt;can('foo');          # retrieve coderef for
                                         # 'foo' accessor
    $bar    = $sub-&gt;('bar');             # set 'foo' via coderef
    $bar    = $sub-&gt;();                  # retrieve 'bar' by coderef

    ### using the object as base class
    package My::Class;
    use base 'Object::Accessor';

    $obj    = My::Class-&gt;new;               # create base object
    $bool   = $obj-&gt;mk_accessors('foo');    # create accessors, etc...

    ### make all attempted access to non-existent accessors fatal
    ### (defaults to false)
    $Object::Accessor::FATAL = 1;

    ### enable debugging
    $Object::Accessor::DEBUG = 1;

    ### advanced usage -- callbacks
    {   my $obj = Object::Accessor-&gt;new('foo');
        $obj-&gt;register_callback( sub { ... } );

        $obj-&gt;foo( 1 ); # these calls invoke the callback you registered
        $obj-&gt;foo()     # which allows you to change the get/set
                        # behaviour and what is returned to the caller.
    }

    ### advanced usage -- lvalue attributes
    {   my $obj = Object::Accessor::Lvalue-&gt;new('foo');
        print $obj-&gt;foo = 1;            # will print 1
    }

    ### advanced usage -- scoped attribute values
    {   my $obj = Object::Accessor-&gt;new('foo');

        $obj-&gt;foo( 1 );
        print $obj-&gt;foo;                # will print 1

        ### bind the scope of the value of attribute 'foo'
        ### to the scope of '$x' -- when $x goes out of
        ### scope, 'foo's previous value will be restored
        {   $obj-&gt;foo( 2 =&gt; \my $x );
            print $obj-&gt;foo, ' ', $x;   # will print '2 2'
        }
        print $obj-&gt;foo;                # will print 1
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<span class="Li">&quot;Object::Accessor&quot;</span> provides an interface to
  create per object accessors (as opposed to per
  <span class="Li">&quot;Class&quot;</span> accessors, as, for example,
  <span class="Li">&quot;Class::Accessor&quot;</span> provides).
<p class="Pp">You can choose to either subclass this module, and thus using its
    accessors on your own module, or to store an
    <span class="Li">&quot;Object::Accessor&quot;</span> object inside your own
    object, and access the accessors from there. See the
    <span class="Li">&quot;SYNOPSIS&quot;</span> for examples.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="$object_=_Object::Accessor_-_new(___s-1ARGS_s0__);"><a class="permalink" href="#$object_=_Object::Accessor_-_new(___s-1ARGS_s0__);">$object
  = Object::Accessor-&gt;new( [ARGS] );</a></h2>
Creates a new (and empty) <span class="Li">&quot;Object::Accessor&quot;</span>
  object. This method is inheritable.
<p class="Pp">Any arguments given to <span class="Li">&quot;new&quot;</span> are
    passed straight to <span class="Li">&quot;mk_accessors&quot;</span>.</p>
<p class="Pp">If you want to be able to assign to your accessors as if they were
    <span class="Li">&quot;lvalue&quot;</span>s, you should create your object
    in the <span class="Li">&quot;Object::Accessor::Lvalue&quot;</span>
    namespace instead. See the section on <span class="Li">&quot;LVALUE
    ACCESSORS&quot;</span> below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_$object_-_mk_accessors(_@ACCESSORS____e_ACCESSOR_MAP_);"><a class="permalink" href="#$bool_=_$object_-_mk_accessors(_@ACCESSORS____e_ACCESSOR_MAP_);">$bool
  = $object-&gt;mk_accessors( @ACCESSORS | \%ACCESSOR_MAP );</a></h2>
Creates a list of accessors for this object (and
  <span class="Li">&quot;NOT&quot;</span> for other ones in the same class!).
  Will not clobber existing data, so if an accessor already exists, requesting
  to create again is effectively a <span class="Li">&quot;no-op&quot;</span>.
<p class="Pp">When providing a <span class="Li">&quot;hashref&quot;</span> as
    argument, rather than a normal list, you can specify a list of key/value
    pairs of accessors and their respective input validators. The validators can
    be anything that <span class="Li">&quot;Params::Check&quot;</span>'s
    <span class="Li">&quot;allow&quot;</span> function accepts. Please see its
    manpage for details.</p>
<p class="Pp">For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $object-&gt;mk_accessors( {
        foo     =&gt; qr/^\d+$/,       # digits only
        bar     =&gt; [0,1],           # booleans
        zot     =&gt; \&amp;my_sub         # a custom verification sub
    } );
</pre>
<p class="Pp">Returns true on success, false on failure.</p>
<p class="Pp">Accessors that are called on an object, that do not exist return
    <span class="Li">&quot;undef&quot;</span> by default, but you can make this
    a fatal error by setting the global variable <span class="Li">$FATAL</span>
    to true. See the section on <span class="Li">&quot;GLOBAL</span>
    <span class="Li">VARIABLES&quot;</span> for details.</p>
<p class="Pp">Note that you can bind the values of attributes to a scope. This
    allows you to <span class="Li">&quot;temporarily&quot;</span> change a value
    of an attribute, and have it's original value restored up on the end of it's
    bound variable's scope;</p>
<p class="Pp">For example, in this snippet of code, the attribute
    <span class="Li">&quot;foo&quot;</span> will temporarily be set to
    <span class="Li">2</span>, until the end of the scope of
    <span class="Li">$x</span>, at which point the original value of
    <span class="Li">1</span> will be restored.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $obj = Object::Accessor-&gt;new;

    $obj-&gt;mk_accessors('foo');
    $obj-&gt;foo( 1 );
    print $obj-&gt;foo;                # will print 1

    ### bind the scope of the value of attribute 'foo'
    ### to the scope of '$x' -- when $x goes out of
    ### scope, 'foo' previous value will be restored
    {   $obj-&gt;foo( 2 =&gt; \my $x );
        print $obj-&gt;foo, ' ', $x;   # will print '2 2'
    }
    print $obj-&gt;foo;                # will print 1
</pre>
<p class="Pp">Note that all accessors are read/write for everyone. See the
    <span class="Li">&quot;TODO&quot;</span> section for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="@list_=_$self_-_ls_accessors;"><a class="permalink" href="#@list_=_$self_-_ls_accessors;">@list
  = $self-&gt;ls_accessors;</a></h2>
Returns a list of accessors that are supported by the current object. The
  corresponding coderefs can be retrieved by passing this list one by one to the
  <span class="Li">&quot;can&quot;</span> method.
</section>
<section class="Ss">
<h2 class="Ss" id="$ref_=_$self_-_ls_allow(_s-1KEY_s0)"><a class="permalink" href="#$ref_=_$self_-_ls_allow(_s-1KEY_s0)">$ref
  = $self-&gt;ls_allow(KEY)</a></h2>
Returns the allow handler for the given key, which can be used with
  <span class="Li">&quot;Params::Check&quot;</span>'s
  <span class="Li">&quot;allow()&quot;</span> handler. If there was no allow
  handler specified, an allow handler that always returns true will be returned.
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_$self_-_mk_aliases(_alias_=__method,__alias2_=__method2,_...__);"><a class="permalink" href="#$bool_=_$self_-_mk_aliases(_alias_=__method,__alias2_=__method2,_...__);">$bool
  = $self-&gt;mk_aliases( alias =&gt; method, [alias2 =&gt; method2, ...]
  );</a></h2>
Creates an alias for a given method name. For all intents and purposes, these
  two accessors are now identical for this object. This is akin to doing the
  following on the symbol table level:
<p class="Pp"><span class="Li"></span></p>
<pre>
  *alias = *method
</pre>
<p class="Pp">This allows you to do the following:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $self-&gt;mk_accessors('foo');
  $self-&gt;mk_aliases( bar =&gt; 'foo' );

  $self-&gt;bar( 42 );
  print $self-&gt;foo;     # will print 42
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="$clone_=_$self_-_mk_clone;"><a class="permalink" href="#$clone_=_$self_-_mk_clone;">$clone
  = $self-&gt;mk_clone;</a></h2>
Makes a clone of the current object, which will have the exact same accessors as
  the current object, but without the data stored in them.
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_$self_-_mk_flush;"><a class="permalink" href="#$bool_=_$self_-_mk_flush;">$bool
  = $self-&gt;mk_flush;</a></h2>
Flushes all the data from the current object; all accessors will be set back to
  their default state of <span class="Li">&quot;undef&quot;</span>.
<p class="Pp">Returns true on success and false on failure.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_$self_-_mk_verify;"><a class="permalink" href="#$bool_=_$self_-_mk_verify;">$bool
  = $self-&gt;mk_verify;</a></h2>
Checks if all values in the current object are in accordance with their own
  allow handler. Specifically useful to check if an empty initialised object has
  been filled with values satisfying their own allow criteria.
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_$self_-_register_callback(_sub___...___);"><a class="permalink" href="#$bool_=_$self_-_register_callback(_sub___...___);">$bool
  = $self-&gt;register_callback( sub { ... } );</a></h2>
This method allows you to register a callback, that is invoked every time an
  accessor is called. This allows you to munge input data, access external data
  stores, etc.
<p class="Pp">You are free to return whatever you wish. On a
    <span class="Li">&quot;set&quot;</span> call, the data is even stored in the
    object.</p>
<p class="Pp">Below is an example of the use of a callback.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $object-&gt;some_method( &quot;some_value&quot; );

    my $callback = sub {
        my $self    = shift; # the object
        my $meth    = shift; # &quot;some_method&quot;
        my $val     = shift; # [&quot;some_value&quot;]
                             # could be undef -- check 'exists';
                             # if scalar @$val is empty, it was a 'get'

        # your code here

        return $new_val;     # the value you want to be set/returned
    }
</pre>
<p class="Pp">To access the values stored in the object, circumventing the
    callback structure, you should use the
    <span class="Li">&quot;___get&quot;</span> and
    <span class="Li">&quot;___set&quot;</span> methods documented further
  down.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_$self_-_can(__s-1METHOD_NAME__s0)"><a class="permalink" href="#$bool_=_$self_-_can(__s-1METHOD_NAME__s0)">$bool
  = $self-&gt;can( METHOD_NAME )</a></h2>
This method overrides <span class="Li">&quot;UNIVERAL::can&quot;</span> in order
  to provide coderefs to accessors which are loaded on demand. It will behave
  just like <span class="Li">&quot;UNIVERSAL::can&quot;</span> where it can --
  returning a class method if it exists, or a closure pointing to a valid
  accessor of this particular object.
<p class="Pp">You can use it as follows:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $sub = $object-&gt;can('some_accessor');   # retrieve the coderef
    $sub-&gt;('foo');                          # 'some_accessor' now set
                                            # to 'foo' for $object
    $foo = $sub-&gt;();                        # retrieve the contents
                                            # of 'some_accessor'
</pre>
<p class="Pp">See the <span class="Li">&quot;SYNOPSIS&quot;</span> for more
    examples.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$val_=_$self_-________get(__s-1METHOD_NAME__s0);"><a class="permalink" href="#$val_=_$self_-________get(__s-1METHOD_NAME__s0);">$val
  = $self-&gt;___get( METHOD_NAME );</a></h2>
Method to directly access the value of the given accessor in the object. It
  circumvents all calls to allow checks, callbacks, etc.
<p class="Pp">Use only if you <span class="Li">&quot;Know What You Are
    Doing&quot;</span>! General usage for this functionality would be in your
    own custom callbacks.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_$self_-________set(__s-1METHOD_NAME_s0_=___s-1VALUE__s0);"><a class="permalink" href="#$bool_=_$self_-________set(__s-1METHOD_NAME_s0_=___s-1VALUE__s0);">$bool
  = $self-&gt;___set( METHOD_NAME =&gt; VALUE );</a></h2>
Method to directly set the value of the given accessor in the object. It
  circumvents all calls to allow checks, callbacks, etc.
<p class="Pp">Use only if you <span class="Li">&quot;Know What You Are
    Doing&quot;</span>! General usage for this functionality would be in your
    own custom callbacks.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$bool_=_$self_-________alias(__s-1ALIAS_s0_=___s-1METHOD__s0);"><a class="permalink" href="#$bool_=_$self_-________alias(__s-1ALIAS_s0_=___s-1METHOD__s0);">$bool
  = $self-&gt;___alias( ALIAS =&gt; METHOD );</a></h2>
Method to directly alias one accessor to another for this object. It circumvents
  all sanity checks, etc.
<p class="Pp">Use only if you <span class="Li">&quot;Know What You Are
    Doing&quot;</span>!</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="LVALUE_ACCESSORS"><a class="permalink" href="#LVALUE_ACCESSORS">LVALUE
  ACCESSORS</a></h1>
<span class="Li">&quot;Object::Accessor&quot;</span> supports
  <span class="Li">&quot;lvalue&quot;</span> attributes as well. To enable
  these, you should create your objects in the designated namespace,
  <span class="Li">&quot;Object::Accessor::Lvalue&quot;</span>. For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $obj = Object::Accessor::Lvalue-&gt;new('foo');
    $obj-&gt;foo += 1;
    print $obj-&gt;foo;
</pre>
<p class="Pp">will actually print <span class="Li">1</span> and work as
    expected. Since this is an optional feature, that's not desirable in all
    cases, we require you to explicitly use the
    <span class="Li">&quot;Object::Accessor::Lvalue&quot;</span> class.</p>
<p class="Pp">Doing the same on the standard
    <span class="Li">&quot;Object&quot;</span>&gt;Accessor&gt; class would
    generate the following code &amp; errors:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $obj = Object::Accessor-&gt;new('foo');
    $obj-&gt;foo += 1;

    Can't modify non-lvalue subroutine call
</pre>
<p class="Pp">Note that <span class="Li">&quot;lvalue&quot;</span> support on
    <span class="Li">&quot;AUTOLOAD&quot;</span> routines is a
    <span class="Li">&quot;perl 5.8.x&quot;</span> feature. See perldoc
    perl58delta for details.</p>
<section class="Ss">
<h2 class="Ss" id="_s-1CAVEATS_s0"><a class="permalink" href="#_s-1CAVEATS_s0">CAVEATS</a></h2>
<ul class="Bl-bullet">
  <li>Allow handlers
    <p class="Pp">Due to the nature of <span class="Li">&quot;lvalue
        subs&quot;</span>, we never get access to the value you are assigning,
        so we can not check it against your allow handler. Allow handlers are
        therefor unsupported under <span class="Li">&quot;lvalue&quot;</span>
        conditions.</p>
    <p class="Pp">See <span class="Li">&quot;perldoc perlsub&quot;</span> for
        details.</p>
  </li>
  <li>Callbacks
    <p class="Pp">Due to the nature of <span class="Li">&quot;lvalue
        subs&quot;</span>, we never get access to the value you are assigning,
        so we can not check provide this value to your callback. Furthermore, we
        can not distinguish between a <span class="Li">&quot;get&quot;</span>
        and a <span class="Li">&quot;set&quot;</span> call. Callbacks are
        therefor unsupported under <span class="Li">&quot;lvalue&quot;</span>
        conditions.</p>
    <p class="Pp">See <span class="Li">&quot;perldoc perlsub&quot;</span> for
        details.</p>
  </li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GLOBAL_VARIABLES"><a class="permalink" href="#GLOBAL_VARIABLES">GLOBAL
  VARIABLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="$Object::Accessor::FATAL"><a class="permalink" href="#$Object::Accessor::FATAL">$Object::Accessor::FATAL</a></h2>
Set this variable to true to make all attempted access to non-existent accessors
  be fatal. This defaults to <span class="Li">&quot;false&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="$Object::Accessor::DEBUG"><a class="permalink" href="#$Object::Accessor::DEBUG">$Object::Accessor::DEBUG</a></h2>
Set this variable to enable debugging output. This defaults to
  <span class="Li">&quot;false&quot;</span>.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TODO"><a class="permalink" href="#TODO">TODO</a></h1>
<section class="Ss">
<h2 class="Ss" id="Create_read-only_accessors"><a class="permalink" href="#Create_read-only_accessors">Create
  read-only accessors</a></h2>
Currently all accessors are read/write for everyone. Perhaps a future release
  should make it possible to have read-only accessors as well.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
If you use codereferences for your allow handlers, you will not be able to
  freeze the data structures using <span class="Li">&quot;Storable&quot;</span>.
<p class="Pp">Due to a bug in storable (until at least version 2.15),
    <span class="Li">&quot;qr//&quot;</span> compiled regexes also don't
    de-serialize properly. Although this bug has been reported, you should be
    aware of this issue when serializing your objects.</p>
<p class="Pp">You can track the bug here:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    http://rt.cpan.org/Ticket/Display.html?id=1827
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BUG_REPORTS"><a class="permalink" href="#BUG_REPORTS">BUG
  REPORTS</a></h1>
Please report bugs or other issues to &lt;bug-object-accessor@rt.cpan.org&gt;.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
This module by Jos Boumans &lt;kane@cpan.org&gt;.
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
This library is free software; you may redistribute and/or modify it under the
  same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
