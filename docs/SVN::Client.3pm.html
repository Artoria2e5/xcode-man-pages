<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>native::Client(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">native::Client(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">native::Client(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
SVN::Client - Subversion client functions
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use SVN::Client;
    my $client = new SVN::Client();

    # setup to handle authentication the same as the command line client
    my $config_dir = undef; # use default location
    my $config = SVN:Core::config_get_config($config_dir);
    my $config_category = $cfg-&gt;{SVN::Core::CONFIG_CATEGORY_CONFIG};
    $client-&gt;auth(
      SVN::Core::cmdline_create_auth_baton(0,           #non_interactive
                                           undef,       #username
                                           undef,       #password
                                           $config_dir,
                                           0,           #no_auth_cache
                                           0,           #trust_server_cert
                                           $config_category,
                                           undef)       #cancel_callback
    );

    # Use first argument as target and canonicalize it before using
    my $target;
    if (SVN::Core::path_is_url($ARGV[0])) {
      $target = SVN::Core::uri_canonicalize($ARGV[0]);
    } else {
      $target = SVN::Core::dirent_canonicalize($ARGV[0]);
    }

    # fetch the head revision of the target
    $client-&gt;cat(\*STDOUT, $target, 'HEAD');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
SVN::Client wraps the highest level of functions provided by subversion to
  accomplish specific tasks in an object oriented API. Methods are similar to
  the functions provided by the C API and as such the documentation for it may
  be helpful in understanding this interface.
<p class="Pp">There are a few notable differences from the C API. Most C
    function calls take a svn_client_ctx_t pointer as the next to last
    parameter. The Perl method calls take a SVN::Client object as the first
    parameter. This allows method call invocation of the methods to be possible.
    For example, the following are equivalent:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  SVN::Client::add($client,$path, $recursive, $pool);
  $client-&gt;add($path, $recursive, $pool);
</pre>
<p class="Pp">Many of the C API calls also take a apr_pool_t pointer as their
    last argument. The Perl bindings generally deal with this for you and you do
    not need to pass a pool parameter. However, you may still pass a pool
    parameter as the last parameter to override the automatic handling of this
    for you.</p>
<p class="Pp">Users of this interface should not directly manipulate the
    underlying hash values but should use the respective attribute methods. Many
    of these attribute methods do other things, especially when setting an
    attribute, besides simply manipulating the value in the hash.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PARAMETER_NOTES"><a class="permalink" href="#PARAMETER_NOTES">PARAMETER
  NOTES</a></h1>
The client methods described below take a variety of parameters. Many of them
  are similar. Methods accepting parameters named below will follow the rules
  below or will be noted otherwise in the method description.
<dl class="Bl-tag">
  <dt>$client</dt>
  <dd>An SVN::Client object that you get from the constructor.</dd>
  <dt>$url</dt>
  <dd>This is a URL to a subversion repository.</dd>
  <dt>$path</dt>
  <dd>This is a path to a file or directory on the local file system. Paths need
      to be canonicalized before being passed into the Subversion APIs. Paths on
      the local file system are called dirents and can be canonicalized by
      calling
      <span class="Li">&quot;SVN::Core::dirent_canonicalize&quot;</span>.</dd>
  <dt>$paths</dt>
  <dd>This argument can either be a single <span class="Li">$path</span> (as
      defined above) or a reference to an array of them.</dd>
  <dt>$target</dt>
  <dd>This is a path to a file or directory in a working copy or a URL to a file
      or directory in a subversion repository. Both paths and URLs need to be
      canonicalized before being passed into the Subversion APIs. Paths on the
      local file system are called dirents and can be canonicalized by calling
      <span class="Li">&quot;SVN::Core::dirent_canonicalize&quot;</span>. URLs
      can be canonicalized by calling
      <span class="Li">&quot;SVN::Core::uri_canonicalize&quot;</span>.</dd>
  <dt>$targets</dt>
  <dd>This argument can either be a single <span class="Li">$target</span> (as
      defined above) or a reference to an array of them.</dd>
  <dt>$revision</dt>
  <dd>This specifies a revision in the Subversion repository. You can specify a
      revision in several ways. The easiest and most obvious is to directly
      provide the revision number. You may also use the strings (aka revision
      keywords) 'HEAD', 'BASE', 'COMMITTED', and 'PREV' which have the same
      meanings as in the command line client. When referencing a working copy
      you can use the string 'WORKING&quot; to reference the BASE plus any local
      modifications. <span class="Li">&quot;undef&quot;</span> may be used to
      specify an unspecified revision. You may also pass a date by specifying
      the date inside curly braces '{}'. The date formats accepted are the same
      as the command line client accepts. Finally a
      <span class="Li">&quot;_p_svn_opt_revision_t&quot;</span> object is
      accepted (which may have been returned by some Subversion function).</dd>
  <dt>$recursive $nonrecursive.</dt>
  <dd>A boolean parameter that specifies if the action should follow
      directories. It should only be 1 or 0. <span class="Li">$recursive</span>
      means, 1 means to descend into directories, 0 means not to.
      <span class="Li">$nonrecursive</span> has the inverse meaning.</dd>
  <dt>$pool</dt>
  <dd>Pool is always an option parameter. If you wish to pass a pool parameter
      it should be a SVN::Pool or an apr_pool_t object.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
The following methods are available:
<dl class="Bl-tag">
  <dt>$client = SVN::Client-&gt;new( %options );</dt>
  <dd>This class method constructs a new
      <span class="Li">&quot;SVN::Client&quot;</span> object and returns a
      reference to it.
    <p class="Pp">Key/value pair arguments may be provided to set up the initial
        state of the user agent. The following methods correspond to attribute
        methods described below:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    KEY                    DEFAULT
    ----------             ----------------------------------------
    auth                   auth_baton initiated with providers that
                           read cached authentication options from
                           the subversion config only.

    cancel                 undef

    config                 Hash containing the config from the
                           default subversion config file location.

    log_msg                undef

    notify                 undef

    pool                   A new pool is created for the context.
    </pre>
  </dd>
  <dt>$client-&gt;add($path, $recursive, $pool);</dt>
  <dd>Similar to <span class="Li">$client</span>-&gt;<i>add2()</i>, but with
      <span class="Li">$force</span> always set to FALSE.</dd>
  <dt>$client-&gt;add2($path, $recursive, $force, $pool);</dt>
  <dd>Similar to <span class="Li">$client</span>-&gt;<i>add3()</i>, but with
      <span class="Li">$no_ignore</span> always set to FALSE.</dd>
  <dt>$client-&gt;add3($path, $recursive, $force, $no_ignore, $pool);</dt>
  <dd>Similar to <span class="Li">$client</span>-&gt;<i>add4()</i>, but with
      <span class="Li">$add_parents</span> always set to FALSE and
      <span class="Li">$depth</span> set according to
      <span class="Li">$recursive</span>; if TRUE, then depth is
      <span class="Li">$SVN::Depth::infinity</span>, if FALSE, then
      <span class="Li">$SVN::Depth::empty</span>.</dd>
  <dt>$client-&gt;add4($path, $depth, $force, $no_ignore, $add_parents,
    $pool);</dt>
  <dd>Schedule a working copy <span class="Li">$path</span> for addition to the
      repository.
    <p class="Pp">If <span class="Li">$depth</span> is
        <span class="Li">$SVN::Depth::empty</span>, add just
        <span class="Li">$path</span> and nothing below it. If
        <span class="Li">$SVN::Depth::files</span>, add
        <span class="Li">$path</span> and any file children of
        <span class="Li">$path</span>. If
        <span class="Li">$SVN::Depth::immediates</span>, add
        <span class="Li">$path</span>, any file children, and any immediate
        subdirectories (but nothing underneath those subdirectories). If
        <span class="Li">$SVN::Depth::infinity</span>, add
        <span class="Li">$path</span> and everything under it fully
      recursively.</p>
    <p class="Pp"><span class="Li">$path</span>'s parent must be under revision
        control already (unless <span class="Li">$add_parents</span> is TRUE),
        but <span class="Li">$path</span> is not.</p>
    <p class="Pp">Unless <span class="Li">$force</span> is TRUE and
        <span class="Li">$path</span> is already under version control, returns
        an <span class="Li">$SVN::Error::ENTRY_EXISTS</span> object. If
        <span class="Li">$force</span> is set, do not error on already-versioned
        items. When used with <span class="Li">$depth</span> set to
        <span class="Li">$SVN::Depth::infinity</span> it will enter versioned
        directories; scheduling unversioned children.</p>
    <p class="Pp">Calls the notify callback for each added item.</p>
    <p class="Pp">If <span class="Li">$no_ignore</span> is FALSE, don't add any
        file or directory (or recurse into any directory) that is unversioned
        and found by recursion (as opposed to being the explicit target
        <span class="Li">$path</span>) and whose name matches the svn:ignore
        property on its parent directory or the global-ignores list in
        <span class="Li">$client</span>-&gt;config. If
        <span class="Li">$no_ignore</span> is TRUE, do include such files and
        directories. (Note that an svn:ignore property can influence this
        behaviour only when recursing into an already versioned directory with
        <span class="Li">$force</span>).</p>
    <p class="Pp">If <span class="Li">$add_parents</span> is TRUE, recurse up
        <span class="Li">$path</span>'s directory and look for a versioned
        directory. If found, add all intermediate paths between it and
        <span class="Li">$path</span>. If not found return
        <span class="Li">$SVN::Error::NO_VERSIONED_PARENT</span>.</p>
    <p class="Pp">Important: this is a <b>scheduling</b> operation. No changes
        will happen to the repository until a commit occurs. This scheduling can
        be removed with <span class="Li">$client</span>-&gt;<i>revert()</i>.</p>
    <p class="Pp">No return.</p>
  </dd>
  <dt>$client-&gt;blame($target, $start, $end, \&amp;receiver, $pool);</dt>
  <dd>Invoke \&amp;receiver subroutine on each line-blame item associated with
      revision <span class="Li">$end</span> of <span class="Li">$target</span>,
      using <span class="Li">$start</span> as the default source of all blame.
    <p class="Pp">An Error will be raised if either
        <span class="Li">$start</span> or <span class="Li">$end</span> is
      undef.</p>
    <p class="Pp">No return.</p>
    <p class="Pp">The blame receiver subroutine receives the following
        arguments: <span class="Li">$line_no</span>,
        <span class="Li">$revision</span>, <span class="Li">$author</span>,
        <span class="Li">$date</span>, <span class="Li">$line</span>,
        <span class="Li">$pool</span></p>
    <p class="Pp"><span class="Li">$line_no</span> is the line number of the
        file (starting with 0). The line was last changed in revision number
        <span class="Li">$revision</span> by <span class="Li">$author</span> on
        <span class="Li">$date</span> and the contents were
        <span class="Li">$line</span>.</p>
    <p class="Pp">The blame receiver subroutine can return an svn_error_t object
        to return an error. All other returns will be ignored. You can create an
        svn_error_t object with <i>SVN::Error::create()</i>.</p>
  </dd>
  <dt>$client-&gt;cat(\*FILEHANDLE, $target, $revision, $pool);</dt>
  <dd>Outputs the content of the file identified by
      <span class="Li">$target</span> and <span class="Li">$revision</span> to
      the FILEHANDLE. FILEHANDLE is a reference to a filehandle.
    <p class="Pp">If <span class="Li">$target</span> is not a local path and if
        <span class="Li">$revision</span> is 'PREV' (or some other kind that
        requires a local path), then an error will be raised, because the
        desired revision can not be determined.</p>
  </dd>
  <dt>$client-&gt;checkout($url, $path, $revision, $recursive, $pool);</dt>
  <dd>Similar to <span class="Li">$client</span>-&gt;<i>checkout2()</i>, but
      with <span class="Li">$peg_revision</span> always set to undef
      (unspecified) and <span class="Li">$ignore_externals</span> always set to
      FALSE.</dd>
  <dt>$client-&gt;checkout2($url, $path, $peg_revision, $revision, $recursive,
    $ignore_externals, $pool);</dt>
  <dd>Similar to <span class="Li">$client</span>-&gt;<i>checkout3()</i>, but
      with <span class="Li">$allow_unver_obstructions</span> always set to
      FALSE, and <span class="Li">$depth</span> set according to
      <span class="Li">$recurse:</span> if <span class="Li">$recurse</span> is
      TRUE, <span class="Li">$depth</span> is
      <span class="Li">$SVN::Depth::infinity</span>, if
      <span class="Li">$recurse</span> is FALSE, set
      <span class="Li">$depth</span> to
      <span class="Li">$SVN::Depth::files</span>.</dd>
  <dt>$client-&gt;checkout3($url, $path, $preg_revision, $revision, $depth,
    $ignore_externals, $allow_unver_obstructions, $pool);</dt>
  <dd>Checkout a working copy of <span class="Li">$url</span> at
      <span class="Li">$revision</span> using <span class="Li">$path</span> as
      the root directory of the newly checked out working copy.
    <p class="Pp">The <span class="Li">$peg_revision</span> sets the revision at
        which the path in the <span class="Li">$url</span> is treated as
        representing.</p>
    <p class="Pp"><span class="Li">$revision</span> must be a number, 'HEAD', or
        a date. If <span class="Li">$revision</span> does not meet these
        requirements the
        <span class="Li">$SVN::Error::CLIENT_BAD_REVISION</span> is raised.</p>
    <p class="Pp"><span class="Li">$depth</span> is one of the constants in
        SVN::Depth and specifies the depth of the operation. If set to
        <span class="Li">$SVN::Depth::unknown</span>, then behave as if for
        <span class="Li">$SVN::Depth::infinity</span>, except in the case of
        resuming a previous checkout of <span class="Li">$path</span> (i.e.
        updating) in which case use the depth of the existing working copy.</p>
    <p class="Pp"><span class="Li">$ignore_exteranls</span> if set to TRUE the
        operation will ignore external definitions.</p>
    <p class="Pp"><span class="Li">$allow_unver_obstructions</span> if set to
        TRUE the operation will tolerate existing unversioned items that
        obstruct incoming paths. Only obstructions of the same type (file or
        dir) as the added item are tolerated. The text of obstructing files is
        left as-is, effectively treating it as a user modification after the
        checkout. Working properties of obstructing items are set equal to the
        base properties. If set to FALSE, then abort if there are any
        unversioned obstructing items.</p>
    <p class="Pp">Returns the value of the revision actually checked out of the
        repository.</p>
  </dd>
  <dt>$client-&gt;cleanup($dir, $pool);</dt>
  <dd>Recursively cleanup a working copy directory,
      <span class="Li">$dir</span>, finishing any incomplete operations,
      removing lockfiles, etc.</dd>
  <dt>$client-&gt;commit($targets, $nonrecursive, $pool);</dt>
  <dd>Commit files or directories referenced by target. Will use the log_msg
      callback to obtain the log message for the commit.
    <p class="Pp">If <span class="Li">$targets</span> contains no paths (zero
        elements), then does nothing and immediately returns without error.</p>
    <p class="Pp">Calls the notify callback as the commit progresses with any of
        the following actions:
        <span class="Li">$SVN::Wc::Notify::Action::commit_modified</span>,
        <span class="Li">$SVN::Wc::Notify::Action::commit_added</span>,
        <span class="Li">$SVN::Wc::Notify::Action::commit_deleted</span>,
        <span class="Li">$SVN::Wc::Notify::Action::commit_replaced</span>,
        <span class="Li">$SVN::Wc::Notify::Action::commit_postfix_txdelta</span>.</p>
    <p class="Pp">Use <span class="Li">$nonrecursive</span> to indicate that
        subdirectories of directory targets should be ignored.</p>
    <p class="Pp">Returns a svn_client_commit_info_t object. If the revision
        member of the commit information object is
        <span class="Li">$SVN::Core::INVALID_REVNUM</span> and no error was
        raised, then the commit was a no-op; nothing needed to be committed.</p>
  </dd>
  <dt>$client-&gt;copy($src_target, $src_revision, $dst_target, $pool);</dt>
  <dd>Copies <span class="Li">$src_target</span> to
      <span class="Li">$dst_target</span>.
    <p class="Pp"><span class="Li">$src_target</span> must be a file or
        directory under version control, or the URL of a versioned item in the
        repository. If <span class="Li">$src_target</span> is a URL,
        <span class="Li">$src_revision</span> is used to choose the revision
        from which to copy the <span class="Li">$src_target</span>.
        <span class="Li">$dst_path</span> must be a file or directory under
        version control, or a repository URL, existing or not.</p>
    <p class="Pp">If <span class="Li">$dst_target</span> is a URL, immediately
        attempt to commit the copy action to the repository. The log_msg
        callback will be called to query for a commit log message. If the commit
        succeeds, return a svn_client_commit_info_t object.</p>
    <p class="Pp">If <span class="Li">$dst_target</span> is not a URL, then this
        is just a variant of <span class="Li">$client</span>-&gt;<i>add()</i>,
        where the <span class="Li">$dst_path</span> items are scheduled for
        addition as copies. No changes will happen to the repository until a
        commit occurs. This scheduling can be removed with
        <span class="Li">$client</span>-&gt;<i>revert()</i>. undef will be
        returned in this case.</p>
    <p class="Pp">Calls the notify callback for each item added at the new
        location, passing the new, relative path of the added item.</p>
  </dd>
  <dt>$client-&gt;delete($targets, $force, $pool);</dt>
  <dd>Delete items from a repository or working copy.
    <p class="Pp">If the paths in <span class="Li">$targets</span> are URLs,
        immediately attempt to commit a deletion of the URLs from the
        repository. The log_msg callback will be called to query for a commit
        log message. If the commit succeeds, return a svn_client_commit_info_t
        object. Every path must belong to the same repository.</p>
    <p class="Pp">Else, schedule the working copy paths in
        <span class="Li">$targets</span> for removal from the repository. Each
        path's parent must be under revision control. This is just a
        <b>scheduling</b> operation. No changes will happen to the repository
        until a commit occurs. This scheduling can be removed with
        <span class="Li">$client</span>-&gt;<i>revert()</i>. If a path is a file
        it is immediately removed from the working copy. If the path is a
        directory it will remain in the working copy but all the files, and all
        unversioned items it contains will be removed. If
        <span class="Li">$force</span> is not set then this operation will fail
        if any path contains locally modified and/or unversioned items. If
        <span class="Li">$force</span> is set such items will be deleted.</p>
    <p class="Pp">The notify callback is called for each item deleted with the
        path of the deleted item.</p>
    <p class="Pp">Has no return.</p>
  </dd>
  <dt>$client-&gt;diff($diff_options, $target1, $revision1, $target2,
    $revision2, $recursive, $ignore_ancestry, $no_diff_deleted, $outfile,
    $errfile, $pool);</dt>
  <dd>Produces diff output which describes the delta between
      <span class="Li">$target1</span> at <span class="Li">$revision1</span> and
      <span class="Li">$target2</span> at <span class="Li">$revision2</span>.
      They both must represent the same node type (i.e. they most both be
      directories or files). The revisions must not be undef.
    <p class="Pp">Prints the output of the diff to the filename or filehandle
        passed as <span class="Li">$outfile</span>, and any errors to the
        filename or filehandle passed as <span class="Li">$errfile</span>.</p>
    <p class="Pp">Use <span class="Li">$ignore_ancestry</span> to control
        whether or not items being diffed will be checked for relatedness first.
        Unrelated items are typically transmitted to the editor as a deletion of
        one thing and the addition of another, but if this flag is true,
        unrelated items will be diffed as if they were related.</p>
    <p class="Pp">If <span class="Li">$no_diff_deleted</span> is true, then no
        diff output will be generated on deleted files.</p>
    <p class="Pp"><span class="Li">$diff_options</span> is a reference to an
        array of additional arguments to pass to diff process invoked to compare
        files. You'll usually just want to use [] to pass an empty array to
        return a unified context diff (like `diff -u`).</p>
    <p class="Pp">Has no return.</p>
  </dd>
  <dt>$client-&gt;diff_summarize($target1, $revision1, $target2, $revision2,
    $recursive, $ignore_ancestry, \&amp;summarize_func, $pool);</dt>
  <dd>Produce a diff summary which lists the changed items between
      <span class="Li">$target1</span> at <span class="Li">$revision1</span> and
      <span class="Li">$target2</span> at <span class="Li">$revision2</span>
      without creating text deltas. <span class="Li">$target1</span> and
      <span class="Li">$target2</span> can be either working-copy paths or URLs.
    <p class="Pp">The function may report false positives if
        <span class="Li">$ignore_ancestry</span> is false, since a file might
        have been modified between two revisions, but still have the same
        contents.</p>
    <p class="Pp">Calls \&amp;summarize_func with with a
        svn_client_diff_summarize_t structure describing the difference.</p>
    <p class="Pp">See <i>diff()</i> for a description of the other
      parameters.</p>
    <p class="Pp">Has no return.</p>
  </dd>
  <dt>$client-&gt;export($from, $to, $revision, $force, $pool);</dt>
  <dd>Export the contents of either a subversion repository or a subversion
      working copy into a 'clean' directory (meaning a directory with no
      administrative directories).
    <p class="Pp"><span class="Li">$from</span> is either the path to the
        working copy on disk, or a URL to the repository you wish to export.</p>
    <p class="Pp"><span class="Li">$to</span> is the path to the directory where
        you wish to create the exported tree.</p>
    <p class="Pp"><span class="Li">$revision</span> is the revision that should
        be exported, which is only used when exporting from a repository. It may
        be undef otherwise.</p>
    <p class="Pp">The notify callback will be called for the items exported.</p>
    <p class="Pp">Returns the value of the revision actually exported or
        <span class="Li">$SVN::Core::INVALID_REVNUM</span> for local
      exports.</p>
  </dd>
  <dt>$client-&gt;import($path, $url, $nonrecursive, $pool);</dt>
  <dd>Import file or directory <span class="Li">$path</span> into repository
      directory <span class="Li">$url</span> at head.
    <p class="Pp">If some components of <span class="Li">$url</span> do not
        exist then create parent directories as necessary.</p>
    <p class="Pp">If <span class="Li">$path</span> is a directory, the contents
        of that directory are imported directly into the directory identified by
        <span class="Li">$url</span>. Note that the directory
        <span class="Li">$path</span> itself is not imported; that is, the
        basename of <span class="Li">$path</span> is not part of the import.</p>
    <p class="Pp">If <span class="Li">$path</span> is a file, then the dirname
        of <span class="Li">$url</span> is the directory receiving the import.
        The basename of <span class="Li">$url</span> is the filename in the
        repository. In this case if <span class="Li">$url</span> already exists,
        raise an error.</p>
    <p class="Pp">The notify callback (if defined) will be called as the import
        progresses, with any of the following actions:
        <span class="Li">$SVN::Wc::Notify::Action::commit_added</span>,
        <span class="Li">$SVN::Wc::Notify::Action::commit_postfix_txdelta</span>.</p>
    <p class="Pp">Use <span class="Li">$nonrecursive</span> to indicate that
        imported directories should not recurse into any subdirectories they may
        have.</p>
    <p class="Pp">Uses the log_msg callback to determine the log message for the
        commit when one is needed.</p>
    <p class="Pp">Returns a svn_client_commit_info_t object.</p>
  </dd>
  <dt>$client-&gt;info($path_or_url, $peg_revision, $revision, \&amp;receiver,
    $recurse);</dt>
  <dd>Invokes \&amp;receiver passing it information about
      <span class="Li">$path_or_url</span> for
      <span class="Li">$revision</span>. The information returned is
      system-generated metadata, not the sort of &quot;property&quot; metadata
      created by users. For methods available on the object passed to
      \&amp;receiver, <b>see svn_info_t</b>.
    <p class="Pp">If both revision arguments are either
        svn_opt_revision_unspecified or NULL, then information will be pulled
        solely from the working copy; no network connections will be made.</p>
    <p class="Pp">Otherwise, information will be pulled from a repository. The
        actual node revision selected is determined by the
        <span class="Li">$path_or_url</span> as it exists in
        <span class="Li">$peg_revision</span>. If
        <span class="Li">$peg_revision</span> is undef, then it defaults to HEAD
        for URLs or WORKING for WC targets.</p>
    <p class="Pp">If <span class="Li">$path_or_url</span> is not a local path,
        then if <span class="Li">$revision</span> is PREV (or some other kind
        that requires a local path), an error will be returned, because the
        desired revision cannot be determined.</p>
    <p class="Pp">Uses the authentication baton cached in ctx to authenticate
        against the repository.</p>
    <p class="Pp">If <span class="Li">$recurse</span> is true (and
        <span class="Li">$path_or_url</span> is a directory) this will be a
        recursive operation, invoking <span class="Li">$receiver</span> on each
        child.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 my $receiver = sub {
     my( $path, $info, $pool ) = @_;
     print &quot;Current revision of $path is &quot;, $info-&gt;rev, &quot;\n&quot;;
 };
 $client-&gt;info( 'foo/bar.c', undef, 'WORKING', $receiver, 0 );
    </pre>
  </dd>
  <dt>$client-&gt;log5($targets, $peg_revision, $revision_ranges, $limit,
    $discover_changed_paths, $strict_node_history, $include_merged_revisions,
    $revprops, \&amp;log_entry_receiver, $pool);</dt>
  <dd>Invoke <span class="Li">&quot;log_entry_receiver&quot;</span> on each log
      message from each revision range in
      <span class="Li">$revision_ranges</span> in turn, inclusive (but never
      invoke <span class="Li">&quot;log_entry_receiver&quot;</span> on a given
      log message more than once).
    <p class="Pp"><span class="Li">$targets</span> is a reference to an array of
        either a URL followed by zero or more relative paths, or 1 working copy
        path, for which log messages are desired. If the array contains only a
        single element you may set <span class="Li">$targets</span> to this
        element instead. <span class="Li">&quot;log_entry_receiver&quot;</span>
        is invoked only on messages whose revisions involved a change to some
        path in <span class="Li">$targets</span>.</p>
    <p class="Pp"><span class="Li">$peg_revision</span> indicates in which
        revision <span class="Li">$targets</span> are valid. If
        <span class="Li">$peg_revision</span> is
        <span class="Li">&quot;undef&quot;</span>, it defaults to 'HEAD' for
        URLs or 'WORKING' for WC paths.</p>
    <p class="Pp"><span class="Li">$revision_ranges</span> is either a single
        <i>revision range</i> or a reference to an array of them. A <i>revision
        range</i> may be specified as a reference to a two-element array
        <span class="Li">&quot;[$start, $end]&quot;</span> of
        <span class="Li">$revision</span>s or a
        SVN::Core::svn_opt_revision_range_t object. Examples:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $revision_ranges = ['HEAD', 1];
  $revision_ranges = [[2, 3], [5, 8], [13, 21]];
    </pre>
    <p class="Pp">If <span class="Li">$limit</span> is non-zero only invoke
        <span class="Li">&quot;log_entry_receiver&quot;</span> on the first
        <span class="Li">$limit</span> logs.</p>
    <p class="Pp">If <span class="Li">$discover_changed_paths</span> is true,
        then the <i>changed_paths2</i> field in the
        <span class="Li">$log_entry</span> argument to
        <span class="Li">&quot;log_entry_receiver&quot;</span> will be populated
        on each invocation. <i>Note:</i> The <i>text_modified</i> and
        <i>props_modified</i> fields of the <i>changed_paths2</i> structure may
        have the value <span class="Li">$SVN::Tristate::unknown</span> if the
        repository does not report that information.</p>
    <p class="Pp">If <span class="Li">$strict_node_history</span> is true, copy
        history (if any exists) will not be traversed while harvesting revision
        logs for each target.</p>
    <p class="Pp">If <span class="Li">$include_merged_revisions</span> is true,
        log information for revisions which have been merged to
        <span class="Li">$targets</span> will also be returned.</p>
    <p class="Pp">If <span class="Li">$revprops</span> is
        <span class="Li">&quot;undef&quot;</span>, retrieve all revision
        properties. Otherwise <span class="Li">$revpros</span> should be a
        reference to an array of property names and only these properties will
        be retrieved (i.e. none if the array is empty).</p>
    <p class="Pp">Use <span class="Li">$pool</span> for any temporary
        allocation.</p>
    <p class="Pp">Calls the notify subroutine with a
        <span class="Li">$SVN::Wc::Notify::Action::skip</span> signal on any
        unversioned <span class="Li">$targets</span>.</p>
    <p class="Pp">The <span class="Li">&quot;log_entry_receiver&quot;</span>
        takes the following arguments: <span class="Li">&quot;$log_entry,
        $pool&quot;</span>. <span class="Li">$log_entry</span> is a
        SVN::Core::svn_log_entry_t object.</p>
  </dd>
  <dt>$client-&gt;log4($targets, $peg_revision, $start, $end, $limit,
    $discover_changed_paths, $strict_node_history, $include_merged_revisions,
    $revprops, \&amp;log_entry_receiver, $pool);</dt>
  <dd>Similar to <span class="Li">&quot;$client-&gt;log5()&quot;</span>, but
      takes explicit <span class="Li">$start</span> and
      <span class="Li">$end</span> parameters instead of
      <span class="Li">$revision_ranges</span>.
    <p class="Pp">Deprecated.</p>
  </dd>
  <dt>$client-&gt;log3($targets, $peg_revision, $start, $end, $limit,
    $discover_changed_paths, $strict_node_history, \&amp;log_message_receiver,
    $pool);</dt>
  <dd>Similar to <span class="Li">&quot;$client-&gt;log4()&quot;</span>, but
      using <span class="Li">&quot;log_message_receiver&quot;</span> instead of
      <span class="Li">&quot;log_entry_receiver&quot;</span>. Also,
      <span class="Li">$include_merged_revisions</span> is false and
      <span class="Li">$revprops</span> is [qw( svn:author svn:date and svn:log
      )].
    <p class="Pp">The <span class="Li">&quot;log_message_receiver&quot;</span>
        takes the following arguments: <span class="Li">&quot;$changed_paths,
        $revision, $author, $date, $message, $pool&quot;</span>. It is called
        once for each log <span class="Li">$message</span> from the
        <span class="Li">$revision</span> on <span class="Li">$date</span> by
        <span class="Li">$author</span>. <span class="Li">$author</span>,
        <span class="Li">$date</span> or <span class="Li">$message</span> may be
        <span class="Li">&quot;undef&quot;</span>.</p>
    <p class="Pp">If <span class="Li">$changed_paths</span> is defined it
        references a hash with the keys every path committed in
        <span class="Li">$revision</span>; the values are
        SVN::Core::svn_log_changed_path_t objects.</p>
    <p class="Pp">Deprecated.</p>
  </dd>
  <dt>$client-&gt;log2($targets, $start, $end, $limit, $discover_changed_paths,
    $strict_node_history, \&amp;log_message_receiver, $pool);</dt>
  <dd>Similar to <span class="Li">&quot;$client-&gt;log3()&quot;</span>, but
      with <span class="Li">$peg_revision</span> set to
      <span class="Li">&quot;undef&quot;</span>.
    <p class="Pp">Deprecated.</p>
  </dd>
  <dt>$client-&gt;log($targets, $start, $end, $discover_changed_paths,
    $strict_node_history, \&amp;log_message_receiver, $pool);</dt>
  <dd>Similar to <span class="Li">&quot;$client-&gt;log2()&quot;</span>, but
      with <span class="Li">$limit</span> set to 0.
    <p class="Pp"><i>Special case for repositories at revision 0:</i> If
        <span class="Li">$start</span> is 'HEAD' and
        <span class="Li">$end</span> is 1, then handle an empty (no revisions)
        repository specially: instead of erroring because requested revision 1
        when the highest revision is 0, just invoke
        <span class="Li">&quot;log_message_receiver&quot;</span> on revision 0,
        passing <span class="Li">&quot;undef&quot;</span> to
        <span class="Li">$changed_paths</span> and empty strings for the author
        and date. This is because that particular combination of
        <span class="Li">$start</span> and <span class="Li">$end</span> usually
        indicates the common case of log invocation; the user wants to see all
        log messages from youngest to oldest, where the oldest commit is
        revision 1. That works fine, except there are no commits in the
        repository, hence this special case.</p>
    <p class="Pp">Deprecated.</p>
  </dd>
  <dt>$client-&gt;ls($target, $revision, $recursive, $pool);</dt>
  <dd>Returns a hash of svn_dirent_t objects for <span class="Li">$target</span>
      at <span class="Li">$revision</span>.
    <p class="Pp">If <span class="Li">$target</span> is a directory, returns
        entries for all of the directories' contents. If
        <span class="Li">$recursive</span> is true, it will recurse
        subdirectories in <span class="Li">$target</span>.</p>
    <p class="Pp">If <span class="Li">$target</span> is a file only return an
        entry for the file.</p>
    <p class="Pp">If <span class="Li">$target</span> is non-existent, raises the
        <span class="Li">$SVN::Error::FS_NOT_FOUND</span> error.</p>
  </dd>
  <dt>$client-&gt;merge($src1, $rev1, $src2, $rev2, $target_wcpath, $recursive,
    $ignore_ancestry, $force, $dry_run, $pool);</dt>
  <dd>Merge changes from <span class="Li">$src1</span>/$rev1 to
      <span class="Li">$src2</span>/$rev2 into the working-copy path
      <span class="Li">$target_wcpath</span>.
    <p class="Pp"><span class="Li">$src1</span> and
        <span class="Li">$src2</span> are either URLs that refer to entries in
        the repository, or paths to entries in the working copy.</p>
    <p class="Pp">By 'merging', we mean: apply file differences and schedule
        additions &amp; deletions when appropriate.</p>
    <p class="Pp"><span class="Li">$src1</span> and
        <span class="Li">$src2</span> must both represent the same node kind;
        that is, if <span class="Li">$src1</span> is a directory,
        <span class="Li">$src2</span> must also be, and if
        <span class="Li">$src1</span> is a file, <span class="Li">$src2</span>
        must also be.</p>
    <p class="Pp">If either <span class="Li">$rev1</span> or
        <span class="Li">$rev2</span> is undef raises the
        <span class="Li">$SVN::Error::CLIENT_BAD_REVISION</span> error.</p>
    <p class="Pp">If <span class="Li">$recursive</span> is true (and the URLs
        are directories), apply changes recursively; otherwise, only apply
        changes in the current directory.</p>
    <p class="Pp">Use <span class="Li">$ignore_ancestry</span> to control
        whether or not items being diffed will be checked for relatedness first.
        Unrelated items are typically transmitted to the editor as a deletion of
        one thing and the addition of another, but if this flag is true,
        unrelated items will be diffed as if they were related.</p>
    <p class="Pp">If <span class="Li">$force</span> is not set and the merge
        involves deleting locally modified or unversioned items the operation
        will raise an error. If <span class="Li">$force</span> is set such items
        will be deleted.</p>
    <p class="Pp">Calls the notify callback once for each merged target, passing
        the targets local path.</p>
    <p class="Pp">If <span class="Li">$dry_run</span> is true the merge is
        carried out, and the full notification feedback is provided, but the
        working copy is not modified.</p>
    <p class="Pp">Has no return.</p>
  </dd>
  <dt>$client-&gt;mkdir($targets, $pool);</dt>
  <dd>Similar to <span class="Li">$client</span>-&gt;<i>mkdir2()</i> except it
      returns an svn_client_commit_info_t object instead of a svn_commit_info_t
      object.</dd>
  <dt>$client-&gt;mkdir2($targets, $pool);</dt>
  <dd>Similar to <span class="Li">$client</span>-&gt;<i>mkdir3()</i>, but with
      <span class="Li">$make_parents</span> always FALSE, and
      <span class="Li">$revprop_hash</span> always undef.</dd>
  <dt>$client-&gt;mkdir3($targets, $make_parents, $revprop_hash, $pool);</dt>
  <dd>Similar to <span class="Li">$client</span>-&gt;<i>mkdir4()</i>, but
      returns a svn_commit_info_t object rather than through a callback
      function.</dd>
  <dt>$client-&gt;mkdir4($targets, $make_parents, $revprop_hash,
    \&amp;commit_callback, $pool);</dt>
  <dd>Create a directory, either in a repository or a working copy.
    <p class="Pp">If <span class="Li">$targets</span> contains URLs, immediately
        attempts to commit the creation of the directories in
        <span class="Li">$targets</span> in the repository. Returns a
        svn_client_commit_info_t object.</p>
    <p class="Pp">Else, create the directories on disk, and attempt to schedule
        them for addition. In this case returns undef.</p>
    <p class="Pp">If <span class="Li">$make_parents</span> is TRUE, create any
        non-existent parent directories also.</p>
    <p class="Pp">If not undef, <span class="Li">$revprop_hash</span> is a
        reference to a hash table holding additional custom revision properites
        (property names mapped to strings) to be set on the new revision in the
        event that this is a committing operation. This hash cannot contain any
        standard Subversion properties.</p>
    <p class="Pp">Calls the log message callback to query for a commit log
        message when one is needed.</p>
    <p class="Pp">Calls the notify callback when the directory has been created
        (successfully) in the working copy, with the path of the new directory.
        Note this is only called for items added to the working copy.</p>
    <p class="Pp">If \&amp;commit_callback is not undef, then for each
        successful commit, call \&amp;commit_callback with the svn_commit_info_t
        object for the commit.</p>
  </dd>
  <dt>$client-&gt;move($src_path, $src_revision, $dst_path, $force, $pool);</dt>
  <dd>Move <span class="Li">$src_path</span> to
      <span class="Li">$dst_path</span>.
    <p class="Pp"><span class="Li">$src_path</span> must be a file or directory
        under version control, or the URL of a versioned item in the
      repository.</p>
    <p class="Pp">If <span class="Li">$src_path</span> is a repository URL:</p>
    <p class="Pp">* <span class="Li">$dst_path</span> must also be a repository
        URL (existent or not).</p>
    <p class="Pp">* <span class="Li">$src_revision</span> is used to choose the
        revision from which to copy the <span class="Li">$src_path</span>.</p>
    <p class="Pp">* The log_msg callback will be called for the commit log
        message.</p>
    <p class="Pp">* The move operation will be immediately committed. If the
        commit succeeds, returns a svn_client_commit_info_t object.</p>
    <p class="Pp">If <span class="Li">$src_path</span> is a working copy
      path</p>
    <p class="Pp">* <span class="Li">$dst_path</span> must also be a working
        copy path (existent or not).</p>
    <p class="Pp">* <span class="Li">$src_revision</span> is ignored and may be
        undef. The log_msg callback will not be called.</p>
    <p class="Pp">* This is a scheduling operation. No changes will happen to
        the repository until a commit occurs. This scheduling can be removed
        with <span class="Li">$client</span>-&gt;<i>revert()</i>. If
        <span class="Li">$src_path</span> is a file it is removed from the
        working copy immediately. If <span class="Li">$src_path</span> is a
        directory it will remain in the working copy but all files, and
        unversioned items, it contains will be removed.</p>
    <p class="Pp">* If <span class="Li">$src_path</span> contains locally
        modified and/or unversioned items and <span class="Li">$force</span> is
        not set, the copy will raise an error. If <span class="Li">$force</span>
        is set such items will be removed.</p>
    <p class="Pp">The notify callback will be called twice for each item moved,
        once to indicate the deletion of the moved node, and once to indicate
        the addition of the new location of the node.</p>
  </dd>
  <dt>$client-&gt;propget($propname, $target, $revision, $recursive,
    $pool);</dt>
  <dd>Returns a reference to a hash containing paths or URLs, prefixed by
      <span class="Li">$target</span> (a working copy or URL), of items for
      which the property <span class="Li">$propname</span> is set, and whose
      values represent the property value for <span class="Li">$propname</span>
      at that path.</dd>
  <dt>$client-&gt;proplist($target, $revision, $recursive, $pool);</dt>
  <dd>Returns a reference to an array of svn_client_proplist_item_t objects.
    <p class="Pp">For each item the node_name member of the proplist_item object
        contains the name relative to the same base as
        <span class="Li">$target</span>.</p>
    <p class="Pp">If <span class="Li">$revision</span> is undef, then get
        properties from the working copy, if <span class="Li">$target</span> is
        a working copy, or from the repository head if
        <span class="Li">$target</span> is a URL. Else get the properties as of
        <span class="Li">$revision</span>.</p>
    <p class="Pp">If <span class="Li">$recursive</span> is false, or
        <span class="Li">$target</span> is a file, the returned array will only
        contain a single element. Otherwise, it will contain one entry for each
        versioned entry below (and including)
      <span class="Li">$target</span>.</p>
    <p class="Pp">If <span class="Li">$target</span> is not found, raises the
        <span class="Li">$SVN::Error::ENTRY_NOT_FOUND</span> error.</p>
  </dd>
  <dt>$client-&gt;propset($propname, $propval, $target, $recursive, $pool);</dt>
  <dd>Set <span class="Li">$propname</span> to <span class="Li">$propval</span>
      on <span class="Li">$target</span> (a working copy or URL path).
    <p class="Pp">If <span class="Li">$recursive</span> is true, then
        <span class="Li">$propname</span> will be set recursively on
        <span class="Li">$target</span> and all children. If
        <span class="Li">$recursive</span> is false, and
        <span class="Li">$target</span> is a directory,
        <span class="Li">$propname</span> will be set on <b>only</b>
        <span class="Li">$target</span>.</p>
    <p class="Pp">A <span class="Li">$propval</span> of undef will delete the
        property.</p>
    <p class="Pp">If <span class="Li">$propname</span> is an svn-controlled
        property (i.e. prefixed with svn:), then the caller is responsible for
        ensuring that <span class="Li">$propval</span> is UTF8-encoded and uses
        LF line-endings.</p>
  </dd>
  <dt>$client-&gt;relocate($dir, $from, $to, $recursive, $pool);</dt>
  <dd>Modify a working copy directory <span class="Li">$dir</span>, changing any
      repository URLs that begin with <span class="Li">$from</span> to begin
      with <span class="Li">$to</span> instead, recursing into subdirectories if
      <span class="Li">$recursive</span> is true.
    <p class="Pp">Has no return.</p>
  </dd>
  <dt>$client-&gt;resolved($path, $recursive, $pool);</dt>
  <dd>Removed the 'conflicted' state on a working copy path.
    <p class="Pp">This will not semantically resolve conflicts; it just allows
        <span class="Li">$path</span> to be committed in the future. The
        implementation details are opaque. If <span class="Li">$recursive</span>
        is set, recurse below <span class="Li">$path</span>, looking for
        conflicts to resolve.</p>
    <p class="Pp">If <span class="Li">$path</span> is not in a state of conflict
        to begin with, do nothing.</p>
    <p class="Pp">If <span class="Li">$path</span>'s conflict state is removed,
        call the notify callback with the <span class="Li">$path</span>.</p>
  </dd>
  <dt>$client-&gt;revert($paths, $recursive, $pool);</dt>
  <dd>Restore the pristine version of a working copy
      <span class="Li">$paths</span>, effectively undoing any local mods.
    <p class="Pp">For each path in <span class="Li">$paths</span>, if it is a
        directory and <span class="Li">$recursive</span> is true, this will be a
        recursive operation.</p>
  </dd>
  <dt>$client-&gt;revprop_get($propname, $url, $revision, $pool);</dt>
  <dd>Returns two values, the first of which is the value of
      <span class="Li">$propname</span> on revision
      <span class="Li">$revision</span> in the repository represented by
      <span class="Li">$url</span>. The second value is the actual revision
      queried.
    <p class="Pp">Note that unlike its cousin
        <span class="Li">$client</span>-&gt;<i>propget()</i>, this routine
        doesn't affect working copy at all; it's a pure network operation that
        queries an <b>unversioned</b> property attached to a revision. This can
        be used to query log messages, dates, authors, and the like.</p>
  </dd>
  <dt>$client-&gt;revprop_list($url, $revision, $pool);</dt>
  <dd>Returns two values, the first of which is a reference to a hash containing
      the properties attached to <span class="Li">$revision</span> in the
      repository represented by <span class="Li">$url</span>. The second value
      is the actual revision queried.
    <p class="Pp">Note that unlike its cousin
        <span class="Li">$client</span>-&gt;<i>proplist()</i>, this routine
        doesn't read a working copy at all; it's a pure network operation that
        reads <b>unversioned</b> properties attached to a revision.</p>
  </dd>
  <dt>$client-&gt;revprop_set($propname, $propval, $url, $revision, $force,
    $pool);</dt>
  <dd>Set <span class="Li">$propname</span> to <span class="Li">$propval</span>
      on revision <span class="Li">$revision</span> in the repository
      represented by <span class="Li">$url</span>.
    <p class="Pp">Returns the actual revision affected. A
        <span class="Li">$propval</span> of undef will delete the property.</p>
    <p class="Pp">If <span class="Li">$force</span> is true, allow newlines in
        the author property.</p>
    <p class="Pp">If <span class="Li">$propname</span> is an svn-controlled
        property (i.e. prefixed with svn:), then the caller is responsible for
        ensuring that the value is UTF8-encoded and uses LF line-endings.</p>
    <p class="Pp">Note that unlike its cousin
        <span class="Li">$client</span>-&gt;<i>propset()</i>, this routine
        doesn't affect the working copy at all; it's a pure network operation
        that changes an <b>unversioned</b> property attached to a revision. This
        can be used to tweak log messages, dates, authors, and the like. Be
        careful: it's a lossy operation, meaning that any existing value is
        replaced with the new value, with no way to retrieve the prior
      value.</p>
    <p class="Pp">Also note that unless the administrator creates a
        pre-revprop-change hook in the repository, this feature will fail.</p>
  </dd>
  <dt>$client-&gt;status($path, $revision, \&amp;status_func, $recursive,
    $get_all, $update, $no_ignore, $pool);</dt>
  <dd>Similar to <span class="Li">$client</span>-&gt;<i>status2()</i>, but with
      ignore_externals always set to FALSE, and with the status_func receiving a
      svn_wc_status2_t instead of a svn_wc_status_t object.</dd>
  <dt>$client-&gt;status2($path, $revision, \&amp;status_func, $recursive,
    $get_all, $update, $no_ignore, $ignore_externals, $pool);</dt>
  <dd>Similar to <span class="Li">$client</span>-&gt;<i>status3()</i>, but with
      the changelists passed as undef, and with recursive instead of depth.</dd>
  <dt>$client-&gt;status3($path, $revision, \&amp;status_func, $depth, $get_all,
    $update, $no_ignore, $ignore_externals, $changelists, $pool);</dt>
  <dd>Similar to <span class="Li">$client</span>-&gt;<i>status4()</i>, without
      the pool parameter to the callback and the return of the callback is
      ignored.</dd>
  <dt>$client-&gt;status4($path, $revision, \&amp;status_func, $depth, $get_all,
    $update, $no_ignore, $ignore_externals, $changelists, $pool);</dt>
  <dd>Given <span class="Li">$path</span> to a working copy directory (or single
      file), call <i>status_func()</i> with a set of svn_wc_status2_t objects
      which describe the status of <span class="Li">$path</span> and its
      children.
    <p class="Pp">If <span class="Li">$recursive</span> is true, recurse fully,
        else do only immediate children.</p>
    <p class="Pp">If <span class="Li">$get_all</span> is set, retrieve all
        entries; otherwise, retrieve only 'interesting' entries (local mods
        and/or out-of-date).</p>
    <p class="Pp">If <span class="Li">$update</span> is set, contact the
        repository and augment the status objects with information about
        out-of-dateness (with respect to <span class="Li">$revision</span>).
        Also, will return the value of the actual revision against with the
        working copy was compared. (The return will be undef if
        <span class="Li">$update</span> is not set).</p>
    <p class="Pp">Unless ignore_externals is set, the function recurses into
        externals definitions ('svn:externals') after handling the main target,
        if any exist. The function calls the notify callback with
        <span class="Li">$SVN::Wc::Notify::Action::status_external</span> action
        before handling each externals definition, and with
        <span class="Li">$SVN::Wc::Notify::Action::status_completed</span> after
        each.</p>
    <p class="Pp"><span class="Li">$changelists</span> is a reference to an
        array of changelist names, used as a restrictive filter on items whose
        statuses are reported; that is don't report status about any item unless
        it's a member of those changelists. If changelists is empty (or
        altogether undef), no changelist filtering occurs.</p>
    <p class="Pp">The status_func subroutine takes the following parameters:
        <span class="Li">$path</span>, <span class="Li">$status</span>,
        <span class="Li">$pool</span></p>
    <p class="Pp"><span class="Li">$path</span> is the pathname of the file or
        directory which status is being reported.
        <span class="Li">$status</span> is a svn_wc_status2_t object.
        <span class="Li">$pool</span> is an apr_pool_t object which is cleaned
        between invocations to the callback.</p>
    <p class="Pp">The return of the status_func subroutine can be a svn_error_t
        object created by SVN::Error::create in order to propagate an error
      up.</p>
  </dd>
  <dt>$client-&gt;switch($path, $url, $revision, $recursive, $pool);</dt>
  <dd>Switch working tree <span class="Li">$path</span> to
      <span class="Li">$url</span> at <span class="Li">$revision</span>.
    <p class="Pp"><span class="Li">$revision</span> must be a number, 'HEAD', or
        a date, otherwise it raises the
        <span class="Li">$SVN::Error::CLIENT_BAD_REVISION</span> error.</p>
    <p class="Pp">Calls the notify callback on paths affected by the switch.
        Also invokes the callback for files that may be restored from the
        text-base because they were removed from the working copy.</p>
    <p class="Pp">Summary of purpose: This is normally used to switch a working
        directory over to another line of development, such as a branch or a
        tag. Switching an existing working directory is more efficient than
        checking out <span class="Li">$url</span> from scratch.</p>
    <p class="Pp">Returns the value of the revision to which the working copy
        was actually switched.</p>
  </dd>
  <dt>$client-&gt;update($path, $revision, $recursive, $pool)</dt>
  <dd>Similar to <span class="Li">$client</span>-&gt;<i>update2()</i> except
      that it accepts only a single target in <span class="Li">$path</span>,
      returns a single revision, and <span class="Li">$ignore_externals</span>
      is always set to FALSE.</dd>
  <dt>$client-&gt;update2($paths, $revision, $recursive, $ignore_externals,
    $pool)</dt>
  <dd>Similar to <span class="Li">$client</span>-&gt;<i>update3()</i> but with
      <span class="Li">$allow_unver_obstructions</span> always set to FALSE,
      <span class="Li">$depth_is_sticky</span> to FALSE, and
      <span class="Li">$depth</span> set according to
      <span class="Li">$recursive:</span> if <span class="Li">$recursive</span>
      is TRUE, set <span class="Li">$depth</span> to
      <span class="Li">$SVN::Depth::infinity</span>, if
      <span class="Li">$recursive</span> is FALSE, set
      <span class="Li">$depth</span> to
      <span class="Li">$SVN::Depth::files</span>.</dd>
  <dt>$client-&gt;update3($paths, $revision, $depth, $depth_is_sticky,
    $ignore_externals, $allow_unver_obstructions, $pool)</dt>
  <dd>Similar to <span class="Li">$client</span>-&gt;<i>update4()</i> but with
      <span class="Li">$make_parents</span> always set to FALSE and
      <span class="Li">$adds_as_modification</span> set to TRUE.</dd>
  <dt>$client-&gt;update4($paths, $revision, $depth, $depth_is_sticky,
    $ignore_externals, $allow_unver_obstructions, $adds_as_modification,
    $make_parents)</dt>
  <dd>Update working trees <span class="Li">$paths</span> to
      <span class="Li">$revision</span>.
    <p class="Pp"><span class="Li">$paths</span> is a array reference of paths
        to be updated. Unversioned paths that are the direct children of a
        versioned path will cause an update that attempts to add that path;
        other unversioned paths are skipped.</p>
    <p class="Pp"><span class="Li">$revision</span> must be a revision number,
        'HEAD', or a date or this method will raise the
        <span class="Li">$SVN::Error::CLIENT_BAD_REVISION</span> error.</p>
    <p class="Pp">The paths in <span class="Li">$paths</span> can be from
        multiple working copies from multiple repositories, but even if they all
        come from the same repository there is no guarantee that revision
        represented by 'HEAD' will remain the same as each path is updated.</p>
    <p class="Pp">If <span class="Li">$ignore_externals</span> is set, don't
        process externals definitions as part of this operation.</p>
    <p class="Pp">If <span class="Li">$depth</span> is
        <span class="Li">$SVN::Depth::infinity</span>, update fully
        recursivelly. Else if it is
        <span class="Li">$SVN::Depth::immediates</span> or
        <span class="Li">$SVN::Depth::files</span>, update each target and its
        file entries, but not its subdirectories. Else if
        <span class="Li">$SVN::Depth::empty</span>, update exactly each target,
        nonrecursively (essentially, update the target's properties).</p>
    <p class="Pp">If <span class="Li">$depth</span> is
        <span class="Li">$SVN::Depth::unknown</span>, take the working depth
        from <span class="Li">$paths</span> and then describe as behaved
      above.</p>
    <p class="Pp">If <span class="Li">$depth_is_sticky</span> is set and
        <span class="Li">$depth</span> is not
        <span class="Li">$SVN::Depth::unknown</span>, then in addition to update
        paths, also set their sticky ambient depth value to
        <span class="Li">$depth</span>.</p>
    <p class="Pp">If <span class="Li">$allow_unver_obstructions</span> is TRUE
        then the update tolerates existing unversioned items that obstruct added
        paths. Only obstructions of the same type (file or dir) as the added
        item are tolerated. The text of obstructing files is left as-is,
        effectively treating it as a user modification after the update. Working
        properties of obstructing items are set equal to the base properties. If
        <span class="Li">$allow_unver_obstructions</span> is FALSE then the
        update will abort if there are any unversioned obstructing items.</p>
    <p class="Pp">If <span class="Li">$adds_as_modification</span> is TRUE, a
        local addition at the same path as an incoming addition of the same node
        kind results in a normal node with a possible local modification,
        instead of a tree conflict.</p>
    <p class="Pp">If <span class="Li">$make_parents</span> is TRUE, create any
        non-existent parent directories also by checking them out at
        depth=empty.</p>
    <p class="Pp">Calls the notify callback for each item handled by the update,
        and also for files restored from the text-base.</p>
    <p class="Pp">Returns an array reference to an array of revision numbers
        with each element set to the revision to which
        <span class="Li">$revision</span> was resolved for the corresponding
        element of <span class="Li">$paths</span>.</p>
  </dd>
  <dt>$client-&gt;url_from_path($target, $pool); or
    SVN::Client::url_from_path($target, $pool);</dt>
  <dd>Returns the URL for <span class="Li">$target</span>.
    <p class="Pp">If <span class="Li">$target</span> is already a URL it returns
        <span class="Li">$target</span>.</p>
    <p class="Pp">If <span class="Li">$target</span> is a versioned item, it
        returns <span class="Li">$target</span>'s entry URL.</p>
    <p class="Pp">If <span class="Li">$target</span> is unversioned (has no
        entry), returns undef.</p>
  </dd>
  <dt>$client-&gt;uuid_from_path($path, $adm_access, $pool);</dt>
  <dd>Return the repository uuid for working-copy <span class="Li">$path</span>,
      allocated in <span class="Li">$pool</span>.
    <p class="Pp">Use <span class="Li">$adm_access</span> to retrieve the uuid
        from <span class="Li">$path</span>'s entry; if not present in the entry,
        then call <span class="Li">$client</span>-&gt;<i>uuid_from_url()</i> to
        retrieve, using the entry's URL.</p>
    <p class="Pp">Note: The only reason this function falls back on
        <span class="Li">$client</span>-&gt;uuid_from_url is for compatibility
        purposes. Old working copies may not have uuids in the entries
      files.</p>
    <p class="Pp">Note: This method probably doesn't work right now without a
        lot of pain, because SVN::Wc is incomplete and it requires an adm_access
        object from it.</p>
  </dd>
  <dt>$client-&gt;uuid_from_url($url, $pool);</dt>
  <dd>Return repository uuid for url.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="ATTRIBUTE_METHODS"><a class="permalink" href="#ATTRIBUTE_METHODS">ATTRIBUTE
  METHODS</a></h1>
The following attribute methods are provided that allow you to set various
  configuration or retrieve it. They all take value(s) to set the attribute and
  return the new value of the attribute or no parameters which returns the
  current value.
<dl class="Bl-tag">
  <dt>$client-&gt;auth(<i>SVN::Client::get_username_provider()</i>);</dt>
  <dd>Provides access to the auth_baton in the svn_client_ctx_t attached to the
      SVN::Client object.
    <p class="Pp">This method will accept an array or array ref of values
        returned from the authentication provider functions see
        &quot;AUTHENTICATION PROVIDERS&quot;, which it will convert to an
        auth_baton for you. This is the preferred method of setting the
        auth_baton.</p>
    <p class="Pp">It will also accept a scalar that references a
        _p_svn_auth_baton_t such as those returned from SVN::Core::auth_open and
        SVN::Core::auth_open_helper.</p>
  </dd>
  <dt>$client-&gt;notify(\&amp;notify);</dt>
  <dd>Sets the notify callback for the client context to a code reference that
      you pass. It always returns the current codereference set.
    <p class="Pp">The subroutine pointed to by this reference will be called
        when a change is made to the working copy. The return value of this
        function is ignored. It's only purpose is to notify you of the
      change.</p>
    <p class="Pp">The subroutine will receive 6 parameters. The first parameter
        will be the path of the changed file (absolute or relative to the cwd).
        The second is an integer specifying the type of action taken. See
        SVN::Wc for a list of the possible actions values and what they mean.
        The 3rd is an integer specifying the kind of node the path is, which can
        be: <span class="Li">$SVN::Node::none</span>,
        <span class="Li">$SVN::Node::file</span>,
        <span class="Li">$SVN::Node::dir</span>,
        <span class="Li">$SVN::Node::unknown</span>. The fourth parameter is the
        mime-type of the file or undef if the mime-type is unknown (it will
        always be undef for directories). The 5th parameter is the state of the
        file, again see SVN::Wc for a list of the possible states. The 6th and
        final parameter is the numeric revision number of the changed file. The
        revision number will be -1 except when the action is
        <span class="Li">$SVN::Wc::Notify::Action::update_completed</span>.</p>
  </dd>
  <dt>$client-&gt;log_msg(\&amp;log_msg)</dt>
  <dd>Sets the log_msg callback for the client context to a code reference that
      you pass. It always returns the current codereference set.
    <p class="Pp">The subroutine pointed to by this coderef will be called to
        get the log message for any operation that will commit a revision to the
        repo.</p>
    <p class="Pp">It receives 4 parameters. The first parameter is a reference
        to a scalar value in which the callback should place the log_msg. If you
        wish to cancel the commit you can set this scalar to undef. The 2nd
        value is a path to any temporary file which might be holding that log
        message, or undef if no such file exists (though, if log_msg is undef,
        this value is undefined). The log message <b>MUST</b> be a UTF8 string
        with LF line separators. The 3rd parameter is a reference to an array of
        svn_client_commit_item3_t objects, which may be fully or only partially
        filled-in, depending on the type of commit operation. The 4th and last
        parameter will be a pool.</p>
    <p class="Pp">If the function wishes to return an error it should return a
        svn_error_t object made with SVN::Error::create. Any other return value
        will be interpreted as SVN_NO_ERROR.</p>
  </dd>
  <dt>$client-&gt;cancel(\&amp;cancel)</dt>
  <dd>Sets the cancellation callback for the client context to a code reference
      that you pass. See &quot;CANCELLATION CALLBACK&quot; below for details. It
      always returns the current codereference set.</dd>
  <dt>$client-&gt;pool(new SVN::Pool);</dt>
  <dd>Method that sets or gets the default pool that is passed to method calls
      requiring a pool, but which were not explicitly passed one.
    <p class="Pp">See SVN::Core for more information about how pools are managed
        in this interface.</p>
  </dd>
  <dt>$client-&gt;config(SVN::Core::config_get_config(undef));</dt>
  <dd>Method that allows access to the config member of the svn_client_ctx_t.
      Accepts a Perl hash to set, which is what functions like
      <i>SVN::Core:config_get_config()</i> will return.
    <p class="Pp">It will return a _p_arp_hash_t scalar. This is a temporary
        situation. The return value is not particular useful. In the future,
        this value will be tied to the actual hash used by the C API.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHENTICATION_PROVIDERS"><a class="permalink" href="#AUTHENTICATION_PROVIDERS">AUTHENTICATION
  PROVIDERS</a></h1>
The following functions get authentication providers for you. They come in two
  forms. Standard or File versions, which look for authentication information in
  the subversion configuration directory that was previously cached, or Prompt
  versions which call a subroutine to allow you to prompt the user for the
  information.
<p class="Pp">The functions that return the svn_auth_provider_object_t for
    prompt style providers take a reference to a Perl subroutine to use for the
    callback. The first parameter each of these subroutines receive is a
    credential object. The subroutines return the response by setting members of
    that object. Members may be set like so:
    <span class="Li">$cred</span>-&gt;username(&quot;breser&quot;); These
    functions and credential objects always have a may_save member which
    specifies if the authentication data will be cached.</p>
<p class="Pp">The providers are as follows:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        NAME                WHAT IT HANDLES
        ----------------    ----------------------------------------
        simple              username and password pairs

        username            username only

        ssl_server_trust    server certificates and failures
                            authenticating them

        ssl_client_cert     client side certificate files

        ssl_client_cert_pw  password for a client side certificate file.
</pre>
<dl class="Bl-tag">
  <dt>SVN::Client::get_simple_provider</dt>
  <dd>Returns a simple provider that returns information from previously cached
      sessions. Takes no parameters or one pool parameter.</dd>
  <dt>SVN::Client::get_simple_prompt_provider</dt>
  <dd>Returns a simple provider that prompts the user via a callback. Takes two
      or three parameters, the first is the callback subroutine, the 2nd is the
      number of retries to allow, the 3rd is optionally a pool. The subroutine
      gets called with the following parameters: a svn_auth_cred_simple_t
      object, a realm string, a default username, may_save, and a pool. The
      svn_auth_cred_simple has the following members: username, password, and
      may_save.</dd>
  <dt>SVN::Client::get_username_provider</dt>
  <dd>Returns a username provider that returns information from a previously
      cached sessions. Takes no parameters or one pool parameter.</dd>
  <dt>SVN::Client::get_username_prompt_provider</dt>
  <dd>Returns a username provider that prompts the user via a callback. Takes
      two or three parameters, the first is the callback subroutine, the 2nd is
      the number of retries to allow, the 3rd is optionally a pool. The
      subroutine gets called with the following parameters: a
      svn_auth_cred_username_t object, a realm string, a default username,
      may_save, and a pool. The svn_auth_cred_username has the following
      members: username and may_save.</dd>
  <dt>SVN::Client::get_ssl_server_trust_file_provider</dt>
  <dd>Returns a server trust provider that returns information from previously
      cached sessions. Takes no parameters or optionally a pool parameter.</dd>
  <dt>SVN::Client::get_ssl_server_trust_prompt_provider</dt>
  <dd>Returns a server trust provider that prompts the user via a callback.
      Takes one or two parameters the callback subroutine and optionally a pool
      parameter. The subroutine gets called with the following parameters. A
      svn_auth_cred_ssl_server_trust_t object, a realm string, an integer
      specifying how the certificate failed authentication, a
      svn_auth_ssl_server_cert_info_t object, may_save, and a pool. The
      svn_auth_cred_ssl_server_trust_t object has the following members:
      may_save and accepted_failures. The svn_auth_ssl_server_cert_info_t object
      has the following members (and behaves just like cred objects though you
      can't modify it): hostname, fingerprint, valid_from, valid_until,
      issuer_dname, ascii_cert.
    <p class="Pp">The masks used for determining the failures are in
        SVN::Auth::SSL and are named:</p>
    <p class="Pp"><span class="Li">$SVN::Auth::SSL::NOTYETVALID</span>
        <span class="Li">$SVN::Auth::SSL::EXPIRED</span>
        <span class="Li">$SVN::Auth::SSL::CNMISMATCH</span>
        <span class="Li">$SVN::Auth::SSL::UNKNOWNCA</span>
        <span class="Li">$SVN::Auth::SSL::OTHER</span></p>
    <p class="Pp">You reply by setting the accepted_failures of the cred object
        with an integer of the values for what you want to accept bitwise AND'd
        together.</p>
  </dd>
  <dt>SVN::Client::get_ssl_client_cert_file_provider</dt>
  <dd>Returns a client certificate provider that returns information from
      previously cached sessions. Takes no parameters or optionally a pool
      parameter.</dd>
  <dt>SVN::Client::get_ssl_client_cert_prompt_provider</dt>
  <dd>Returns a client certificate provider that prompts the user via a
      callback. Takes two or three parameters: the first is the callback
      subroutine, the 2nd is the number of retries to allow, the 3rd is
      optionally a pool parameter. The subroutine gets called with the following
      parameters. A svn_auth_cred_ssl_client_cert object, a realm string,
      may_save, and a pool. The svn_auth_cred_ssl_client_cert the following
      members: cert_file and may_save.</dd>
  <dt>SVN::Client::get_ssl_client_cert_pw_file_provider</dt>
  <dd>Returns a client certificate password provider that returns information
      from previously cached sessions. Takes no parameters or optionally a pool
      parameter.</dd>
  <dt>SVN::Client::get_ssl_client_cert_pw_prompt_provider</dt>
  <dd>Returns a client certificate password provider that prompts the user via a
      callback. Takes two or three parameters, the first is the callback
      subroutine, the 2nd is the number of retries to allow, the 3rd is
      optionally a pool parameter. The subroutine gets called with the following
      parameters. A svn_auth_cred_ssl_client_cert_pw object, a realm string,
      may_save, and a pool. The svn_auth_cred_ssl_client_cert_pw has the
      following members: password and may_save.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="CANCELLATION_CALLBACK"><a class="permalink" href="#CANCELLATION_CALLBACK">CANCELLATION
  CALLBACK</a></h1>
This callback will be called periodically to see if the operation should be
  canceled. If the operation should be canceled, the function may return one of
  the following values:
<p class="Pp">An svn_error_t object made with SVN::Error::create.</p>
<p class="Pp">Any true value, in which case the bindings will generate an
    svn_error_t object for you with the error code of SVN_ERR_CANCELLED and the
    string set to &quot;By cancel callback&quot;.</p>
<p class="Pp">A string, in which case the bindings will generate an svn_error_t
    object for you with the error code of SVN_ERR_CANCELLED and the string set
    to the string you returned.</p>
<p class="Pp">Any other value will be interpreted as wanting to continue the
    operation. Generally, it's best to return 0 to continue the operation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECTS"><a class="permalink" href="#OBJECTS">OBJECTS</a></h1>
These are some of the object types that are returned from the methods and
  functions. Others are documented in SVN::Core and SVN::Wc. If an object is not
  documented, it is more than likely opaque and not something you can do
  anything with, except pass to other functions that require such objects.
<section class="Ss">
<h2 class="Ss" id="svn_info_t"><a class="permalink" href="#svn_info_t">svn_info_t</a></h2>
<dl class="Bl-tag">
  <dt>$info-&gt;<i>URL()</i></dt>
  <dd>Where the item lives in the repository.</dd>
  <dt>$info-&gt;<i>rev()</i></dt>
  <dd>The revision of the object. If path_or_url is a working-copy path, then
      this is its current working revnum. If path_or_url is a URL, then this is
      the repos revision that path_or_url lives in.</dd>
  <dt>$info-&gt;<i>kind()</i></dt>
  <dd>The node's kind.</dd>
  <dt>$info-&gt;<i>repos_root_URL()</i></dt>
  <dd>The root URL of the repository.</dd>
  <dt>$info-&gt;<i>repos_UUID()</i></dt>
  <dd>The repository's UUID.</dd>
  <dt>$info-&gt;<i>last_changed_rev()</i></dt>
  <dd>The last revision in which this object changed.</dd>
  <dt>$info-&gt;<i>last_changed_date()</i></dt>
  <dd>The date of the last_changed_rev.</dd>
  <dt>$info-&gt;<i>last_changed_author()</i></dt>
  <dd>The author of the last_changed_rev.</dd>
  <dt>$info-&gt;<i>lock()</i></dt>
  <dd>An exclusive lock, if present. Could be either local or remote.</dd>
</dl>
<p class="Pp">See SVN::Wc::svn_wc_entry_t for the rest of these. svn_client.h
    indicates that these were copied from that struct and mean the same things.
    They are also only useful when working with a WC.</p>
<dl class="Bl-tag">
  <dt>$info-&gt;<i>has_wc_info()</i></dt>
  <dd></dd>
  <dt>$info-&gt;<i>schedule()</i></dt>
  <dd></dd>
  <dt>$info-&gt;<i>copyfrom_url()</i></dt>
  <dd></dd>
  <dt>$info-&gt;<i>copyfrom_rev()</i></dt>
  <dd></dd>
  <dt>$info-&gt;<i>text_time()</i></dt>
  <dd></dd>
  <dt>$info-&gt;<i>prop_time()</i></dt>
  <dd></dd>
  <dt>$info-&gt;<i>checksum()</i></dt>
  <dd></dd>
  <dt>$info-&gt;<i>conflict_old()</i></dt>
  <dd></dd>
  <dt>$info-&gt;<i>conflict_new()</i></dt>
  <dd></dd>
  <dt>$info-&gt;<i>conflict_wrk()</i></dt>
  <dd></dd>
  <dt>$info-&gt;<i>prejfile()</i></dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="svn_client_commit_item3_t"><a class="permalink" href="#svn_client_commit_item3_t">svn_client_commit_item3_t</a></h2>
<dl class="Bl-tag">
  <dt>$commit_item-&gt;<i>path()</i></dt>
  <dd>Absolute working-copy path of item.</dd>
  <dt>$commit_item-&gt;<i>kind()</i></dt>
  <dd>An integer representing the type of node it is (file/dir). Can be one of
      the following constants: <span class="Li">$SVN::Node::none</span>
      <span class="Li">$SVN::Node::file</span>
      <span class="Li">$SVN::Node::dir</span>
      <span class="Li">$SVN::Node::unknown</span></dd>
  <dt>$commit_item-&gt;<i>url()</i></dt>
  <dd>Commit URL for this item.</dd>
  <dt>$commit_item-&gt;<i>revision()</i></dt>
  <dd>Revision (copyfrom_rev if state_flags has IS_COPY set).</dd>
  <dt>$commit_item-&gt;<i>copyform_url()</i>;</dt>
  <dd>CopyFrom URL</dd>
  <dt>$commit_item-&gt;<i>state_flags()</i>;</dt>
  <dd>One of several state flags:
      <span class="Li">$SVN::Client::COMMIT_ITEM_ADD</span>
      <span class="Li">$SVN::Client::COMMIT_ITEM_DELETE</span>
      <span class="Li">$SVN::Client::COMMIT_ITEM_TEXT_MODS</span>
      <span class="Li">$SVN::Client::COMMIT_ITEM_PROP_MODS</span>
      <span class="Li">$SVN::Client::COMMIT_ITEM_IS_COPY</span></dd>
  <dt>$commit_item-&gt;<i>incoming_prop_changes()</i></dt>
  <dd>A reference to an array of svn_prop_t objects representing changes to WC
      properties.</dd>
  <dt>$commit_item-&gt;<i>outgoing_prop_changes()</i></dt>
  <dd>A reference to an array of svn_prop_t objects representing extra changes
      to properties in the repository (which are not necessarily reflected by
      the WC).</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="svn_client_commit_info_t"><a class="permalink" href="#svn_client_commit_info_t">svn_client_commit_info_t</a></h2>
<dl class="Bl-tag">
  <dt>$commit_info-&gt;<i>revision()</i></dt>
  <dd>Just committed revision.</dd>
  <dt>$commit_info-&gt;<i>date()</i></dt>
  <dd>Server-Side date of the commit as a string.</dd>
  <dt>$commit_info-&gt;<i>author()</i></dt>
  <dd>Author of the commit.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="svn_client_proplist_item_t"><a class="permalink" href="#svn_client_proplist_item_t">svn_client_proplist_item_t</a></h2>
<dl class="Bl-tag">
  <dt>$proplist-&gt;<i>node_name()</i></dt>
  <dd>The name of the node on which these properties are set.</dd>
  <dt>$proplist-&gt;<i>prop_hash()</i></dt>
  <dd>A reference to a hash of property names and values.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="svn_client_diff_summarize_kind_t__-_SVN::Summarize"><a class="permalink" href="#svn_client_diff_summarize_kind_t__-_SVN::Summarize">svn_client_diff_summarize_kind_t
  - SVN::Summarize</a></h2>
An enum of the following constants:
<p class="Pp"><span class="Li">$SVN::Client::Summarize::normal</span>,
    <span class="Li">$SVN::Client::Summarize::added</span>,
    <span class="Li">$SVN::Client::Summarize::modified</span>,
    <span class="Li">$SVN::Client::Summarize::deleted</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="svn_client_diff_summarize_t"><a class="permalink" href="#svn_client_diff_summarize_t">svn_client_diff_summarize_t</a></h2>
<dl class="Bl-tag">
  <dt>$diff_summarize-&gt;<i>path()</i></dt>
  <dd>Path relative to the target. If the target is a file, path is the empty
      string.</dd>
  <dt>$diff_summarize-&gt;<i>summarize_kind()</i></dt>
  <dd>Change kind.</dd>
  <dt>$diff_summarize-&gt;<i>prop_changed()</i></dt>
  <dd>Properties changed?</dd>
  <dt>$diff_summarize-&gt;<i>node_kind()</i></dt>
  <dd>File or dir?</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1ADDITIONAL_METHODS_s0"><a class="permalink" href="#_s-1ADDITIONAL_METHODS_s0">ADDITIONAL
  METHODS</a></h2>
The following methods work, but are not currently documented in this file.
  Please consult the svn_client.h section in the Subversion API for more
  details.
<dl class="Bl-tag">
  <dt>$client-&gt;add_to_changelist(...)</dt>
  <dd></dd>
  <dt>$client-&gt;blame2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;blame3(...)</dt>
  <dd></dd>
  <dt>$client-&gt;blame4(...)</dt>
  <dd></dd>
  <dt>$client-&gt;cat2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;commit2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;commit3(...)</dt>
  <dd></dd>
  <dt>$client-&gt;commit4(...)</dt>
  <dd></dd>
  <dt>$client-&gt;copy2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;copy3(...)</dt>
  <dd></dd>
  <dt>$client-&gt;copy4(...)</dt>
  <dd></dd>
  <dt>$client-&gt;create_context(...)</dt>
  <dd></dd>
  <dt>$client-&gt;delete2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;delete3(...)</dt>
  <dd></dd>
  <dt>$client-&gt;diff2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;diff3(...)</dt>
  <dd></dd>
  <dt>$client-&gt;diff4(...)</dt>
  <dd></dd>
  <dt>$client-&gt;diff_peg(...)</dt>
  <dd></dd>
  <dt>$client-&gt;diff_peg2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;diff_peg3(...)</dt>
  <dd></dd>
  <dt>$client-&gt;diff_peg4(...)</dt>
  <dd></dd>
  <dt>$client-&gt;diff_summarize2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;diff_summarize_dup(...)</dt>
  <dd></dd>
  <dt>$client-&gt;diff_summarize_peg(...)</dt>
  <dd></dd>
  <dt>$client-&gt;diff_summarize_peg2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;export2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;export3(...)</dt>
  <dd></dd>
  <dt>$client-&gt;export4(...)</dt>
  <dd></dd>
  <dt>$client-&gt;import2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;import3(...)</dt>
  <dd></dd>
  <dt>$client-&gt;info2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;invoke_blame_receiver(...)</dt>
  <dd></dd>
  <dt>$client-&gt;invoke_blame_receiver2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;invoke_diff_summarize_func(...)</dt>
  <dd></dd>
  <dt>$client-&gt;list(...)</dt>
  <dd></dd>
  <dt>$client-&gt;list2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;ls2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;ls3(...)</dt>
  <dd></dd>
  <dt>$client-&gt;merge2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;merge3(...)</dt>
  <dd></dd>
  <dt>$client-&gt;merge_peg(...)</dt>
  <dd></dd>
  <dt>$client-&gt;merge_peg2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;merge_peg3(...)</dt>
  <dd></dd>
  <dt>$client-&gt;move2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;move3(...)</dt>
  <dd></dd>
  <dt>$client-&gt;move4(...)</dt>
  <dd></dd>
  <dt>$client-&gt;move5(...)</dt>
  <dd></dd>
  <dt>$client-&gt;open_ra_session(...)</dt>
  <dd></dd>
  <dt>$client-&gt;propget2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;propget3(...)</dt>
  <dd></dd>
  <dt>$client-&gt;proplist2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;proplist3(...)</dt>
  <dd></dd>
  <dt>$client-&gt;propset2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;propset3(...)</dt>
  <dd></dd>
  <dt>$client-&gt;remove_from_changelist(...)</dt>
  <dd></dd>
  <dt>$client-&gt;resolve(...)</dt>
  <dd></dd>
  <dt>$client-&gt;revert2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;switch2(...)</dt>
  <dd></dd>
  <dt>$client-&gt;unlock(...)</dt>
  <dd></dd>
  <dt>$client-&gt;version(...)</dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TODO"><a class="permalink" href="#TODO">TODO</a></h1>
* Better support for the config.
<p class="Pp">* Unit tests for cleanup, diff, export, merge, move, relocate,
    resolved and switch. This may reveal problems for using these methods as I
    haven't tested them yet that require deeper fixes.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Chia-liang Kao &lt;clkao@clkao.org&gt;
<p class="Pp">Ben Reser &lt;ben@reser.org&gt;</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<span class="Li"></span>
<pre>
    Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    &quot;License&quot;); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-01-01</td>
    <td class="foot-os">perl v5.18.2</td>
  </tr>
</table>
</body>
</html>
