<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Test::Trap(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test::Trap(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Test::Trap(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Test::Trap - Trap exit codes, exceptions, output, etc.
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
Version 0.3.4
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use Test::More;
  use Test::Trap;

  my @r = trap { some_code(@some_parameters) };
  is ( $trap-&gt;exit, 1, 'Expecting &amp;some_code to exit with 1' );
  is ( $trap-&gt;stdout, '', 'Expecting no STDOUT' );
  like ( $trap-&gt;stderr, qr/^Bad parameters; exiting\b/, 'Expecting warnings.' );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Primarily (but not exclusively) for use in test scripts: A block eval on
  steroids, configurable and extensible, but by default trapping (Perl) STDOUT,
  STDERR, warnings, exceptions, would-be exit codes, and return values from
  boxed blocks of test code.
<p class="Pp">The values collected by the latest trap can then be queried or
    tested through a special trap object.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT"><a class="permalink" href="#EXPORT">EXPORT</a></h1>
A function and a scalar may be exported by any name. The function (by default
  named <span class="Li">&quot;trap&quot;</span>) is an analogue to block
  <b>eval()</b>, and the scalar (by default named <span class="Li">$trap</span>)
  is the corresponding analogue to <span class="Li">$@</span>.
<p class="Pp">Optionally, you may specify the layers of the exported trap.
    Layers may be specified by name, with a colon sigil. Multiple layers may be
    given in a list, or just stringed together like
    <span class="Li">&quot;:flow:stderr:warn&quot;</span>.</p>
<p class="Pp">(For the advanced user, you may also specify anonymous layer
    implementations -- i.e. an appropriate subroutine.)</p>
<p class="Pp">See below for a list of the built-in layers, most of which are
    enabled by default. Note, finally, that the ordering of the layers matter:
    The :raw layer is always on the bottom (anything underneath it is ignored),
    and any other &quot;flow control&quot; layers used should be right down
    there with it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTION"><a class="permalink" href="#FUNCTION">FUNCTION</a></h1>
<section class="Ss">
<h2 class="Ss" id="trap__s-1BLOCK_s0"><a class="permalink" href="#trap__s-1BLOCK_s0">trap
  BLOCK</a></h2>
This function may be exported by any name, but defaults to
  <span class="Li">&quot;trap&quot;</span>.
<p class="Pp">By default, traps exceptions (like block eval), but also exits and
    exit codes, returns and return values, context, and (Perl) output on STDOUT
    or STDERR, and warnings. All information trapped can be queried through the
    trap object, which is by default exported as <span class="Li">$trap</span>,
    but can be exported by any name.</p>
<p class="Pp">The value returned from <span class="Li">&quot;trap&quot;</span>
    mimics that returned from <span class="Li">&quot;eval&quot;</span>: If the
    <i>BLOCK</i> would die or exit, it returns an undefined value in scalar
    context or an empty list in list context; otherwise it returns whatever the
    <i>BLOCK</i> would return in the given context (also available as the
    trapped return values).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TRAP_LAYERS"><a class="permalink" href="#TRAP_LAYERS">TRAP
  LAYERS</a></h1>
Exactly what the <span class="Li">&quot;trap&quot;</span> traps depends on the
  layers of the trap. It is possible to register more (see Test::Trap::Builder),
  but the following layers are pre-defined by this module:
<section class="Ss">
<h2 class="Ss" id=":raw"><a class="permalink" href="#:raw">:raw</a></h2>
The only built-in terminating layer, at which the processing of the layers
  stops, and the actual call to the user code is performed. On success, it
  collects the return value(s) in the appropriate context. Pushing the :raw
  layer on a trap will for most purposes remove all layers below.
</section>
<section class="Ss">
<h2 class="Ss" id=":die"><a class="permalink" href="#:die">:die</a></h2>
The layer emulating block eval, trapping normal exceptions.
</section>
<section class="Ss">
<h2 class="Ss" id=":exit"><a class="permalink" href="#:exit">:exit</a></h2>
The third &quot;flow control&quot; layer, capturing exit codes if anything used
  in the dynamic scope of the trap calls <b>CORE::GLOBAL::exit()</b>. (See
  CAVEATS below for more.)
</section>
<section class="Ss">
<h2 class="Ss" id=":flow"><a class="permalink" href="#:flow">:flow</a></h2>
A shortcut for :raw:die:exit (effectively pushing all three layers on the trap).
  Since this includes :raw, it is also terminating: Pushing :flow on a trap will
  effectively remove all layers below.
</section>
<section class="Ss">
<h2 class="Ss" id=":stdout,_:stderr"><a class="permalink" href="#:stdout,_:stderr">:stdout,
  :stderr</a></h2>
Layers trapping Perl output on STDOUT and STDERR, respectively.
</section>
<section class="Ss">
<h2 class="Ss" id=":stdout(perlio),_:stderr(perlio)"><a class="permalink" href="#:stdout(perlio),_:stderr(perlio)">:stdout(perlio),
  :stderr(perlio)</a></h2>
As above, but specifying a capture strategy using PerlIO::scalar. If this
  strategy is not available (typically if PerlIO is not), this is an error. See
  &quot;CAPTURE STRATEGIES&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id=":stdout(tempfile),_:stderr(tempfile)"><a class="permalink" href="#:stdout(tempfile),_:stderr(tempfile)">:stdout(tempfile),
  :stderr(tempfile)</a></h2>
As above, but specifying a capture strategy using File::Temp. Note that this is
  the default strategy, unless the <span class="Li">&quot;:output()&quot;</span>
  layer is used to set another default. See &quot;CAPTURE STRATEGIES&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id=":stdout(a;b;c),_:stderr(a,b,c)"><a class="permalink" href="#:stdout(a;b;c),_:stderr(a,b,c)">:stdout(a;b;c),
  :stderr(a,b,c)</a></h2>
(Either syntax, commas or semicolons, is permitted, as is any number of names in
  the list.) As above, but specifying the capture strategy by the first existing
  name among <i>a</i>, <i>b</i>, and <i>c</i>. If no such strategy is found,
  this is an error. See &quot;CAPTURE STRATEGIES&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id=":warn"><a class="permalink" href="#:warn">:warn</a></h2>
A layer trapping warnings, with additional tee: If STDERR is open, it will also
  print the warnings there. (This output may be trapped by the :stderr layer, be
  it above or below the :warn layer.)
</section>
<section class="Ss">
<h2 class="Ss" id=":default"><a class="permalink" href="#:default">:default</a></h2>
A short-cut for :raw:die:exit:stdout:stderr:warn (effectively pushing all six
  layers on the trap). Since this includes :raw, it is also terminating: Pushing
  :default on a trap will effectively remove all layers below.
<p class="Pp">The other interesting property of :default is that it is what
    every trap starts with: In order not to include the six layers that make up
    :default, you need to push a terminating layer (such as :raw or :flow) on
    the trap.</p>
</section>
<section class="Ss">
<h2 class="Ss" id=":on_fail(m)"><a class="permalink" href="#:on_fail(m)">:on_fail(m)</a></h2>
A (non-default, non-trapping) layer that installs a callback method (by name)
  <i>m</i> to be run on test failures. To run the &quot;diag_all&quot; method
  every time a test fails:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Test::Trap qw/ :on_fail(diag_all) /;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id=":void,_:scalar,_:list"><a class="permalink" href="#:void,_:scalar,_:list">:void,
  :scalar, :list</a></h2>
These (non-default, non-trapping) layers will cause the trapped user code to be
  run in void, scalar, or list context, respectively. (By default, the trap will
  propagate context, that is, it will run the code in whatever context the trap
  itself is in.)
<p class="Pp">If more than one of these layers are pushed on the trap, the
    deepest (that is, leftmost) takes precedence:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Test::Trap qw/ :scalar:void:list /;
  trap { 42, 13 };
  $trap-&gt;return_is_deeply( [ 13 ], 'Scalar comma.' );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id=":output(a;b;c)"><a class="permalink" href="#:output(a;b;c)">:output(a;b;c)</a></h2>
A (non-default, non-trapping) layer that sets the default capture strategy for
  any output trapping (<span class="Li">&quot;:stdout&quot;</span>,
  <span class="Li">&quot;:stderr&quot;</span>, or other similarly defined)
  layers below iton the trap.
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Test::Trap qw/ :output(systemsafe) /;
  trap { system echo =&gt; 'Hello Unix!' }; # trapped!

  use Test::Trap qw/ :flow:stderr:output(systemsafe):stdout /;
  trap { system echo =&gt; 'Hello Unix!' }; # *not* trapped!
  trap { system q/ echo 'Hello Unix!' &gt;&amp;2 / }; # trapped!
</pre>
<p class="Pp">See &quot;CAPTURE STRATEGIES&quot;.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAPTURE_STRATEGIES"><a class="permalink" href="#CAPTURE_STRATEGIES">CAPTURE
  STRATEGIES</a></h1>
How output is trapped, depends on the capture strategy used. It is possible to
  register more (see Test::Trap::Builder), but the following strategies are
  pre-defined by this module:
<section class="Ss">
<h2 class="Ss" id="tempfile"><a class="permalink" href="#tempfile">tempfile</a></h2>
The default capture strategy, provided by Test::Trap::Builder::TempFile, in
  which output is temporarily redirected to (and read back from) a tempfile.
</section>
<section class="Ss">
<h2 class="Ss" id="tempfile-preserve"><a class="permalink" href="#tempfile-preserve">tempfile-preserve</a></h2>
A variant of the capture strategy provided by Test::Trap::Builder::TempFile, in
  which the handles used to write to and read from the tempfile are both
  binmoded with the same perlio layers as the trapped output handle originally
  had.
<p class="Pp">Caveat emptor: If the handle has perlio custom layers, they may
    (or may not) fail to apply to the tempfile read and write handles.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="systemsafe"><a class="permalink" href="#systemsafe">systemsafe</a></h2>
A capture strategy provided by Test::Trap::Builder::SystemSafe, like the default
  strategy, except it outputs on file handles with the same file descriptors as
  the trapped output handle originally had, and so can be used to trap output
  from forked-off processes, including <b>system()</b>.
<p class="Pp">This strategy may be &quot;safe&quot; in relation to forked-off
    processes, but it is fragile. For one, it only works with handles that have
    &quot;real&quot; file descriptors. For another, it depends on the original
    file descriptors being available after closing. (If signal handlers or
    threads open files, they may well not be.) And it may fail in other ways.
    But in relation to forked-off processes, the other pre-defined strategies
    will silently fail to trap, as will similarly simple strategies. This one,
    when not crashing, will trap that output.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="systemsafe-preserve"><a class="permalink" href="#systemsafe-preserve">systemsafe-preserve</a></h2>
A variant of the capture strategy provided by Test::Trap::Builder::SystemSafe,
  in which the handles used to write to and read from the tempfile are both
  binmoded with the same perlio layers as the trapped output handle originally
  had.
<p class="Pp">Caveat emptor: If the handle has perlio custom layers, they may
    (or may not) fail to apply to the tempfile read and write handles.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="perlio"><a class="permalink" href="#perlio">perlio</a></h2>
A capture strategy provided by Test::Trap::Builder::PerlIO, in which output is
  temporarily redirected to an in-memory file via PerlIO::scalar.
<p class="Pp">If PerlIO::scalar is not available, neither is this strategy.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RESULT_ACCESSORS"><a class="permalink" href="#RESULT_ACCESSORS">RESULT
  ACCESSORS</a></h1>
The following methods may be called on the trap objects after any trap has been
  sprung, and access the outcome of the run.
<p class="Pp">Any property will be undef if not actually trapped -- whether
    because there is no layer to trap them or because flow control passed them
    by. (If there is an active and successful trap layer, empty strings and
    empty arrays trapped will of course be defined.)</p>
<p class="Pp">When properties are set, their values will be as follows:</p>
<section class="Ss">
<h2 class="Ss" id="leaveby"><a class="permalink" href="#leaveby">leaveby</a></h2>
A string indicating how the trap terminated:
  <span class="Li">&quot;return&quot;</span>,
  <span class="Li">&quot;die&quot;</span>, or
  <span class="Li">&quot;exit&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="die"><a class="permalink" href="#die">die</a></h2>
The exception, if the latest trap threw one.
</section>
<section class="Ss">
<h2 class="Ss" id="exit"><a class="permalink" href="#exit">exit</a></h2>
The exit code, if the latest trap tried to exit (by way of the trap's own
  &amp;CORE::GLOBAL::exit only; see &quot;CAVEATS&quot;).
</section>
<section class="Ss">
<h2 class="Ss" id="return___s-1INDEX_..._s0_"><a class="permalink" href="#return___s-1INDEX_..._s0_">return
  [INDEX ...]</a></h2>
Returns undef if the latest trap did not terminate with a return; otherwise
  returns three different views of the return array:
<ul class="Bl-bullet">
  <li>if no <i>INDEX</i> is passed, returns a reference to the array (NB! an
      empty array of indices qualifies as &quot;no index&quot;)</li>
  <li>if called with at least one <i>INDEX</i> in scalar context, returns the
      array element indexed by the first <i>INDEX</i> (ignoring the rest)</li>
  <li>if called with at least one <i>INDEX</i> in list context, returns the
      slice of the array by these indices</li>
</ul>
<p class="Pp">Note: The array will hold but a single value if the trap was
    sprung in scalar context, and will be empty if it was in void context.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="stdout,_stderr"><a class="permalink" href="#stdout,_stderr">stdout,
  stderr</a></h2>
The captured output on the respective file handles.
</section>
<section class="Ss">
<h2 class="Ss" id="warn___s-1INDEX_s0_"><a class="permalink" href="#warn___s-1INDEX_s0_">warn
  [INDEX]</a></h2>
Returns undef if the latest trap had no warning-trapping layer; otherwise
  returns three different views of the warn array:
<ul class="Bl-bullet">
  <li>if no <i>INDEX</i> is passed, returns a reference to the array (NB! an
      empty array of indices qualifies as &quot;no index&quot;)</li>
  <li>if called with at least one <i>INDEX</i> in scalar context, returns the
      array element indexed by the first <i>INDEX</i> (ignoring the rest)</li>
  <li>if called with at least one <i>INDEX</i> in list context, returns the
      slice of the array by these indices</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="wantarray"><a class="permalink" href="#wantarray">wantarray</a></h2>
The context in which the latest code trapped was called. (By default a
  propagated context, but layers can override this.)
</section>
<section class="Ss">
<h2 class="Ss" id="list,_scalar,_void"><a class="permalink" href="#list,_scalar,_void">list,
  scalar, void</a></h2>
True if the latest code trapped was called in the indicated context. (By default
  the code will be called in a propagated context, but layers can override
  this.)
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RESULT_TESTS"><a class="permalink" href="#RESULT_TESTS">RESULT
  TESTS</a></h1>
For each accessor, a number of convenient standard test methods are also
  available. By default, these are a few standard tests from Test::More, plus
  the <span class="Li">&quot;nok&quot;</span> test (a negated
  <span class="Li">&quot;ok&quot;</span> test). All for convenience:
<section class="Ss">
<h2 class="Ss" id="_fI_s-1ACCESSOR_s0_fP_ok__________s-1INDEX,_s0___s-1TEST_NAME_s0"><a class="permalink" href="#_fI_s-1ACCESSOR_s0_fP_ok__________s-1INDEX,_s0___s-1TEST_NAME_s0"><i>ACCESSOR</i>_ok
  [INDEX,] TEST_NAME</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="_fI_s-1ACCESSOR_s0_fP_nok_________s-1INDEX,_s0___s-1TEST_NAME_s0"><a class="permalink" href="#_fI_s-1ACCESSOR_s0_fP_nok_________s-1INDEX,_s0___s-1TEST_NAME_s0"><i>ACCESSOR</i>_nok
  [INDEX,] TEST_NAME</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="_fI_s-1ACCESSOR_s0_fP_is__________s-1INDEX,_s0___s-1SCALAR,_TEST_NAME_s0"><a class="permalink" href="#_fI_s-1ACCESSOR_s0_fP_is__________s-1INDEX,_s0___s-1SCALAR,_TEST_NAME_s0"><i>ACCESSOR</i>_is
  [INDEX,] SCALAR, TEST_NAME</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="_fI_s-1ACCESSOR_s0_fP_isnt________s-1INDEX,_s0___s-1SCALAR,_TEST_NAME_s0"><a class="permalink" href="#_fI_s-1ACCESSOR_s0_fP_isnt________s-1INDEX,_s0___s-1SCALAR,_TEST_NAME_s0"><i>ACCESSOR</i>_isnt
  [INDEX,] SCALAR, TEST_NAME</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="_fI_s-1ACCESSOR_s0_fP_isa_ok______s-1INDEX,_s0___s-1SCALAR,_INVOCANT_NAME_s0"><a class="permalink" href="#_fI_s-1ACCESSOR_s0_fP_isa_ok______s-1INDEX,_s0___s-1SCALAR,_INVOCANT_NAME_s0"><i>ACCESSOR</i>_isa_ok
  [INDEX,] SCALAR, INVOCANT_NAME</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="_fI_s-1ACCESSOR_s0_fP_like________s-1INDEX,_s0___s-1REGEX,_TEST_NAME_s0"><a class="permalink" href="#_fI_s-1ACCESSOR_s0_fP_like________s-1INDEX,_s0___s-1REGEX,_TEST_NAME_s0"><i>ACCESSOR</i>_like
  [INDEX,] REGEX, TEST_NAME</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="_fI_s-1ACCESSOR_s0_fP_unlike______s-1INDEX,_s0___s-1REGEX,_TEST_NAME_s0"><a class="permalink" href="#_fI_s-1ACCESSOR_s0_fP_unlike______s-1INDEX,_s0___s-1REGEX,_TEST_NAME_s0"><i>ACCESSOR</i>_unlike
  [INDEX,] REGEX, TEST_NAME</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="_fI_s-1ACCESSOR_s0_fP_is_deeply___________s-1STRUCTURE,_TEST_NAME_s0"><a class="permalink" href="#_fI_s-1ACCESSOR_s0_fP_is_deeply___________s-1STRUCTURE,_TEST_NAME_s0"><i>ACCESSOR</i>_is_deeply
  STRUCTURE, TEST_NAME</a></h2>
<i>INDEX</i> is not optional: It is required for array accessors (like
  <span class="Li">&quot;return&quot;</span> and
  <span class="Li">&quot;warn&quot;</span>), and disallowed for scalar
  accessors. Note that the <span class="Li">&quot;is_deeply&quot;</span> test
  does not accept an index. Even for array accessors, it operates on the entire
  array.
<p class="Pp">For convenience and clarity, tests against a flow control
    <i>ACCESSOR</i> (<span class="Li">&quot;return&quot;</span>,
    <span class="Li">&quot;die&quot;</span>,
    <span class="Li">&quot;exit&quot;</span>, or any you define yourself) will
    first test whether the trap was left by way of the flow control mechanism in
    question, and fail with appropriate diagnostics otherwise.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="did_die,_did_exit,_did_return"><a class="permalink" href="#did_die,_did_exit,_did_return">did_die,
  did_exit, did_return</a></h2>
Conveniences: Tests whether the trap was left by way of the flow control
  mechanism in question. Much like
  <span class="Li">&quot;leaveby_is('die')&quot;</span> etc, but with better
  diagnostics and (run-time) spell checking.
</section>
<section class="Ss">
<h2 class="Ss" id="quiet"><a class="permalink" href="#quiet">quiet</a></h2>
Convenience: Passes if zero-length output was trapped on both STDOUT and STDERR,
  and generate better diagnostics otherwise.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="UTILITIES"><a class="permalink" href="#UTILITIES">UTILITIES</a></h1>
<section class="Ss">
<h2 class="Ss" id="diag_all"><a class="permalink" href="#diag_all">diag_all</a></h2>
Prints a diagnostic message (as per &quot;diag&quot; in Test::More) consisting
  of a dump (in Perl code, as per Data::Dump) of the trap object.
</section>
<section class="Ss">
<h2 class="Ss" id="diag_all_once"><a class="permalink" href="#diag_all_once">diag_all_once</a></h2>
As &quot;diag_all&quot;, except if this instance of the trap object has already
  been diag_all_once'd, the diagnostic message will instead consist of the
  string <span class="Li">&quot;(as above)&quot;</span>.
<p class="Pp">This could be useful with the
    <span class="Li">&quot;on_fail&quot;</span> layer:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Test::Trap qw/ :on_fail(diag_all_once) /;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
This module must be loaded before any code containing <b>exit()</b>s to be
  trapped is compiled. Any <b>exit()</b> already compiled won't be trappable,
  and will terminate the program anyway.
<p class="Pp">This module overrides &amp;CORE::GLOBAL::exit, so may not work
    correctly (or even at all) in the presence of other code overriding
    &amp;CORE::GLOBAL::exit. More precisely: This module installs its own
    <b>exit()</b> on entry of the block, and restores the previous one, if any,
    only upon leaving the block.</p>
<p class="Pp">If you use <b>fork()</b> in the dynamic scope of a trap, beware
    that the (default) :exit layer of that trap does not trap <b>exit()</b> in
    the children, but passes them to the outer handler. If you think about it,
    this is what you are likely to want it to do in most cases.</p>
<p class="Pp">Note that the (default) :exit layer only traps
    &amp;CORE::GLOBAL::exit calls (and bare <b>exit()</b> calls that compile to
    that). It makes no attempt to trap <b>CORE::exit()</b>,
    <b>POSIX::_exit()</b>, <b>exec()</b>, untrapped exceptions from
    <b>die()</b>, nor segfault. Nor does it attempt to trap anything else that
    might terminate the program. The trap is a block eval on steroids -- not the
    last block eval of Krypton!</p>
<p class="Pp">This module traps warnings using
    <span class="Li">$SIG{__WARN__}</span>, so may not work correctly (or even
    at all) in the presence of other code setting this handler. More precisely:
    This module installs its own __WARN__ handler on entry of the block, and
    restores the previous one, if any, only upon leaving the block.</p>
<p class="Pp">The (default) :stdout and :stderr handlers will not trap output
    from <b>system()</b> calls.</p>
<p class="Pp">Threads? No idea. It might even work correctly.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
Please report any bugs or feature requests directly to the author.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Eirik Berg Hanssen,
  <span class="Li">&quot;&lt;ebhanssen@cpan.org&gt;&quot;</span>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_&amp;_LICENSE"><a class="permalink" href="#COPYRIGHT_&amp;_LICENSE">COPYRIGHT
  &amp; LICENSE</a></h1>
Copyright 2006-2014 Eirik Berg Hanssen, All Rights Reserved.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-10-19</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
