<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright 1996 Massachusetts Institute of Technology
  
   Permission to use, copy, modify, and distribute this software and
   its documentation for any purpose and without fee is hereby
   granted, provided that both the above copyright notice and this
   permission notice appear in all copies, that both the above
   copyright notice and this permission notice appear in all
   supporting documentation, and that the name of M.I.T. not be used
   in advertising or publicity pertaining to distribution of the
   software without specific, written prior permission.  M.I.T. makes
   no representations about the suitability of this software for any
   purpose.  It is provided "as is" without express or implied
   warranty.
  
   THIS SOFTWARE IS PROVIDED BY M.I.T. ``AS IS''.  M.I.T. DISCLAIMS
   ALL EXPRESS OR IMPLIED WARRANTIES WITH REGARD TO THIS SOFTWARE,
   INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
   SHALL M.I.T. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
   SUCH DAMAGE.
  
  	$ANA: addr2ascii.3,v 1.1 1996/06/13 18:41:46 wollman Exp $
   $FreeBSD: src/lib/libc/net/addr2ascii.3,v 1.17 2004/10/09 17:13:58 maxim Exp $
   -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>ADDR2ASCII(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">ADDR2ASCII(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">ADDR2ASCII(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<code class="Nm">addr2ascii</code>, <code class="Nm">ascii2addr</code> &#x2014;
<div class="Nd">Generic address formatting routines</div>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY"><a class="permalink" href="#LIBRARY">LIBRARY</a></h1>
<span class="Lb">Standard C&#x00A0;Library (libc, -lc)</span>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<code class="In">#include &lt;<a class="In">arpa/inet.h</a>&gt;</code>
<p class="Pp"><var class="Ft">char *</var>
  <br/>
  <code class="Fn">addr2ascii</code>(<var class="Fa" style="white-space: nowrap;">int
    af</var>, <var class="Fa" style="white-space: nowrap;">const void
    *addrp</var>, <var class="Fa" style="white-space: nowrap;">int len</var>,
    <var class="Fa" style="white-space: nowrap;">char *buf</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">ascii2addr</code>(<var class="Fa" style="white-space: nowrap;">int
    af</var>, <var class="Fa" style="white-space: nowrap;">const char
    *ascii</var>, <var class="Fa" style="white-space: nowrap;">void
    *result</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The routines <code class="Fn">addr2ascii</code>() and
  <code class="Fn">ascii2addr</code>() are used to convert network addresses
  between binary form and a printable form appropriate to the address family.
  Both functions take an <var class="Fa">af</var> argument, specifying the
  address family to be used in the conversion process. (Currently, only the
  <code class="Dv">AF_INET</code> and <code class="Dv">AF_LINK</code> address
  families are supported.)
<p class="Pp">The <code class="Fn">addr2ascii</code>() function is used to
    convert binary, network-format addresses into printable form. In addition to
    <var class="Fa">af</var>, there are three other arguments. The
    <var class="Fa">addrp</var> argument is a pointer to the network address to
    be converted. The <var class="Fa">len</var> argument is the length of the
    address. The <var class="Fa">buf</var> argument is an optional pointer to a
    caller-allocated buffer to hold the result; if a null pointer is passed,
    <code class="Fn">addr2ascii</code>() uses a statically-allocated buffer.</p>
<p class="Pp">The <code class="Fn">ascii2addr</code>() function performs the
    inverse operation to <code class="Fn">addr2ascii</code>(). In addition to
    <var class="Fa">af</var>, it takes two arguments,
    <var class="Fa">ascii</var> and <var class="Fa">result</var>. The
    <var class="Fa">ascii</var> argument is a pointer to the string which is to
    be converted into binary. The <var class="Fa">result</var> argument is a
    pointer to an appropriate network address structure for the specified
    family.</p>
<p class="Pp">The following gives the appropriate structure to use for binary
    addresses in the specified family:</p>
<p class="Pp"></p>
<dl class="Bl-tag Bl-compact">
  <dt><a class="permalink" href="#AF_INET"><code class="Dv" id="AF_INET">AF_INET</code></a></dt>
  <dd><a class="permalink" href="#struct_in_addr"><code class="Li" id="struct_in_addr">struct
      in_addr</code></a> (in
      <code class="In">&lt;<a class="In">arpa/inet.h</a>&gt;</code>)</dd>
  <dt><a class="permalink" href="#AF_LINK"><code class="Dv" id="AF_LINK">AF_LINK</code></a></dt>
  <dd><a class="permalink" href="#struct_sockaddr_dl"><code class="Li" id="struct_sockaddr_dl">struct
      sockaddr_dl</code></a> (in
      <code class="In">&lt;<a class="In">net/if_dl.h</a>&gt;</code>)</dd>
</dl>
<p class="Pp"><code class="Dv">AF_INET and AF_LINK constants are defined
    in</code> <code class="In">&lt;<a class="In">sys/socket.h</a>&gt;</code></p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
The <code class="Fn">addr2ascii</code>() function returns the address of the
  buffer it was passed, or a static buffer if the a null pointer was passed; on
  failure, it returns a null pointer. The <code class="Fn">ascii2addr</code>()
  function returns the length of the binary address in bytes, or -1 on failure.
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
The <a class="Xr">inet(3)</a> functions <code class="Fn">inet_ntoa</code>() and
  <code class="Fn">inet_aton</code>() could be implemented thusly:
<div class="Bd Pp Bd-indent">
<pre>
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;

char *
inet_ntoa(struct in_addr addr)
{
	return addr2ascii(AF_INET, &amp;addr, sizeof addr, 0);
}

int
inet_aton(const char *ascii, struct in_addr *addr)
{
	return (ascii2addr(AF_INET, ascii, addr)
	    == sizeof(*addr));
}
</pre>
</div>
<p class="Pp">In actuality, this cannot be done because
    <code class="Fn">addr2ascii</code>() and
    <code class="Fn">ascii2addr</code>() are implemented in terms of the
    <a class="Xr">inet(3)</a> functions, rather than the other way around.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
When a failure is returned, <code class="Li">errno</code> is set to one of the
  following values:
<dl class="Bl-tag">
  <dt>[<a class="permalink" href="#ENAMETOOLONG"><code class="Er" id="ENAMETOOLONG">ENAMETOOLONG</code></a>]</dt>
  <dd>The <code class="Fn">addr2ascii</code>() routine was passed a
      <var class="Fa">len</var> argument which was inappropriate for the address
      family given by <var class="Fa">af</var>.</dd>
  <dt>[<a class="permalink" href="#EPROTONOSUPPORT"><code class="Er" id="EPROTONOSUPPORT">EPROTONOSUPPORT</code></a>]</dt>
  <dd>Either routine was passed an <var class="Fa">af</var> argument other than
      <code class="Dv">AF_INET</code> or <code class="Dv">AF_LINK</code>.</dd>
  <dt>[<a class="permalink" href="#EINVAL"><code class="Er" id="EINVAL">EINVAL</code></a>]</dt>
  <dd>The string passed to <code class="Fn">ascii2addr</code>() was improperly
      formatted for address family <var class="Fa">af</var>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<a class="Xr">inet(3)</a>, <a class="Xr">linkaddr(3)</a>,
  <a class="Xr">inet(4)</a>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
An interface close to this one was originally suggested by Craig Partridge. This
  particular interface originally appeared in the INRIA IPv6 implementation.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Code and documentation by <span class="An">Garrett A. Wollman</span>, MIT
  Laboratory for Computer Science.
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
The original implementations supported IPv6. This support should eventually be
  resurrected. The NRL implementation also included support for the
  <code class="Dv">AF_ISO</code> and <code class="Dv">AF_NS</code> address
  families.
<p class="Pp">The genericity of this interface is somewhat questionable. A truly
    generic interface would provide a means for determining the length of the
    buffer to be used so that it could be dynamically allocated, and would
    always require a &#x201C;<code class="Li">struct sockaddr</code>&#x201D; to
    hold the binary address. Unfortunately, this is incompatible with existing
    practice. This limitation means that a routine for printing network
    addresses from arbitrary address families must still have internal knowledge
    of the maximum buffer length needed and the appropriate part of the address
    to use as the binary address.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">June 13, 1996</td>
    <td class="foot-os">Mac OS X 10.15</td>
  </tr>
</table>
</body>
</html>
