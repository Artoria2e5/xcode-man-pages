<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Tie::Hash(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Tie::Hash(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Tie::Hash(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Tie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    package NewHash;
    require Tie::Hash;

    @ISA = qw(Tie::Hash);

    sub DELETE { ... }          # Provides needed method
    sub CLEAR { ... }           # Overrides inherited method


    package NewStdHash;
    require Tie::Hash;

    @ISA = qw(Tie::StdHash);

    # All methods provided by default, define only those needing overrides
    # Accessors access the storage in %{$_[0]};
    # TIEHASH should return a reference to the actual storage
    sub DELETE { ... }

    package NewExtraHash;
    require Tie::Hash;

    @ISA = qw(Tie::ExtraHash);

    # All methods provided by default, define only those needing overrides
    # Accessors access the storage in %{$_[0][0]};
    # TIEHASH should return an array reference with the first element being
    # the reference to the actual storage 
    sub DELETE { 
      $_[0][1]-&gt;('del', $_[0][0], $_[1]); # Call the report writer
      delete $_[0][0]-&gt;{$_[1]};           #  $_[0]-&gt;SUPER::DELETE($_[1])
    }


    package main;

    tie %new_hash, 'NewHash';
    tie %new_std_hash, 'NewStdHash';
    tie %new_extra_hash, 'NewExtraHash',
        sub {warn &quot;Doing \U$_[1]\E of $_[2].\n&quot;};
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module provides some skeletal methods for hash-tying classes. See perltie
  for a list of the functions required in order to tie a hash to a package. The
  basic <b>Tie::Hash</b> package provides a
  <span class="Li">&quot;new&quot;</span> method, as well as methods
  <span class="Li">&quot;TIEHASH&quot;</span>,
  <span class="Li">&quot;EXISTS&quot;</span> and
  <span class="Li">&quot;CLEAR&quot;</span>. The <b>Tie::StdHash</b> and
  <b>Tie::ExtraHash</b> packages provide most methods for hashes described in
  perltie (the exceptions are <span class="Li">&quot;UNTIE&quot;</span> and
  <span class="Li">&quot;DESTROY&quot;</span>). They cause tied hashes to behave
  exactly like standard hashes, and allow for selective overwriting of methods.
  <b>Tie::Hash</b> grandfathers the <span class="Li">&quot;new&quot;</span>
  method: it is used if <span class="Li">&quot;TIEHASH&quot;</span> is not
  defined in the case a class forgets to include a
  <span class="Li">&quot;TIEHASH&quot;</span> method.
<p class="Pp">For developers wishing to write their own tied hashes, the
    required methods are briefly defined below. See the perltie section for more
    detailed descriptive, as well as example code:</p>
<dl class="Bl-tag">
  <dt>TIEHASH classname, LIST</dt>
  <dd>The method invoked by the command <span class="Li">&quot;tie %hash,
      classname&quot;</span>. Associates a new hash instance with the specified
      class. <span class="Li">&quot;LIST&quot;</span> would represent additional
      arguments (along the lines of AnyDBM_File and compatriots) needed to
      complete the association.</dd>
  <dt>STORE this, key, value</dt>
  <dd>Store datum <i>value</i> into <i>key</i> for the tied hash
    <i>this</i>.</dd>
  <dt>FETCH this, key</dt>
  <dd>Retrieve the datum in <i>key</i> for the tied hash <i>this</i>.</dd>
  <dt>FIRSTKEY this</dt>
  <dd>Return the first key in the hash.</dd>
  <dt>NEXTKEY this, lastkey</dt>
  <dd>Return the next key in the hash.</dd>
  <dt>EXISTS this, key</dt>
  <dd>Verify that <i>key</i> exists with the tied hash <i>this</i>.
    <p class="Pp">The <b>Tie::Hash</b> implementation is a stub that simply
        croaks.</p>
  </dd>
  <dt>DELETE this, key</dt>
  <dd>Delete the key <i>key</i> from the tied hash <i>this</i>.</dd>
  <dt>CLEAR this</dt>
  <dd>Clear all values from the tied hash <i>this</i>.</dd>
  <dt>SCALAR this</dt>
  <dd>Returns what evaluating the hash in scalar context yields.
    <p class="Pp"><b>Tie::Hash</b> does not implement this method (but
        <b>Tie::StdHash</b> and <b>Tie::ExtraHash</b> do).</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Inheriting_from__fBTie::StdHash_fP"><a class="permalink" href="#Inheriting_from__fBTie::StdHash_fP">Inheriting
  from <b>Tie::StdHash</b></a></h1>
The accessor methods assume that the actual storage for the data in the tied
  hash is in the hash referenced by
  <span class="Li">&quot;tied(%tiedhash)&quot;</span>. Thus overwritten
  <span class="Li">&quot;TIEHASH&quot;</span> method should return a hash
  reference, and the remaining methods should operate on the hash referenced by
  the first argument:
<p class="Pp"><span class="Li"></span></p>
<pre>
  package ReportHash;
  our @ISA = 'Tie::StdHash';

  sub TIEHASH  {
    my $storage = bless {}, shift;
    warn &quot;New ReportHash created, stored in $storage.\n&quot;;
    $storage
  }
  sub STORE    {
    warn &quot;Storing data with key $_[1] at $_[0].\n&quot;;
    $_[0]{$_[1]} = $_[2]
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Inheriting_from__fBTie::ExtraHash_fP"><a class="permalink" href="#Inheriting_from__fBTie::ExtraHash_fP">Inheriting
  from <b>Tie::ExtraHash</b></a></h1>
The accessor methods assume that the actual storage for the data in the tied
  hash is in the hash referenced by
  <span class="Li">&quot;(tied(%tiedhash))-&gt;[0]&quot;</span>. Thus
  overwritten <span class="Li">&quot;TIEHASH&quot;</span> method should return
  an array reference with the first element being a hash reference, and the
  remaining methods should operate on the hash <span class="Li">&quot;%{
  $_[0]-&gt;[0] }&quot;</span>:
<p class="Pp"><span class="Li"></span></p>
<pre>
  package ReportHash;
  our @ISA = 'Tie::ExtraHash';

  sub TIEHASH  {
    my $class = shift;
    my $storage = bless [{}, @_], $class;
    warn &quot;New ReportHash created, stored in $storage.\n&quot;;
    $storage;
  }
  sub STORE    {
    warn &quot;Storing data with key $_[1] at $_[0].\n&quot;;
    $_[0][0]{$_[1]} = $_[2]
  }
</pre>
<p class="Pp">The default <span class="Li">&quot;TIEHASH&quot;</span> method
    stores &quot;extra&quot; arguments to <i>tie()</i> starting from offset 1 in
    the array referenced by <span class="Li">&quot;tied(%tiedhash)&quot;</span>;
    this is the same storage algorithm as in TIEHASH subroutine above. Hence, a
    typical package inheriting from <b>Tie::ExtraHash</b> does not need to
    overwrite this method.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="_SCALAR_,__UNTIE__and__DESTROY_"><a class="permalink" href="#_SCALAR_,__UNTIE__and__DESTROY_">&quot;SCALAR&quot;,
  &quot;UNTIE&quot; and &quot;DESTROY&quot;</a></h1>
The methods <span class="Li">&quot;UNTIE&quot;</span> and
  <span class="Li">&quot;DESTROY&quot;</span> are not defined in
  <b>Tie::Hash</b>, <b>Tie::StdHash</b>, or <b>Tie::ExtraHash</b>. Tied hashes
  do not require presence of these methods, but if defined, the methods will be
  called in proper time, see perltie.
<p class="Pp"><span class="Li">&quot;SCALAR&quot;</span> is only defined in
    <b>Tie::StdHash</b> and <b>Tie::ExtraHash</b>.</p>
<p class="Pp">If needed, these methods should be defined by the package
    inheriting from <b>Tie::Hash</b>, <b>Tie::StdHash</b>, or
    <b>Tie::ExtraHash</b>. See &quot;SCALAR&quot; in perltie to find out what
    happens when <span class="Li">&quot;SCALAR&quot;</span> does not exist.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MORE_INFORMATION"><a class="permalink" href="#MORE_INFORMATION">MORE
  INFORMATION</a></h1>
The packages relating to various DBM-related implementations (<i>DB_File</i>,
  <i>NDBM_File</i>, etc.) show examples of general tied hashes, as does the
  Config module. While these do not utilize <b>Tie::Hash</b>, they serve as good
  working examples.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
