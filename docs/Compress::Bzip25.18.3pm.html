<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Compress::Bzip2(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Compress::Bzip2(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Compress::Bzip2(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Compress::Bzip2 - Interface to Bzip2 compression library
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use Compress::Bzip2 qw(:all :constant :utilities :gzip);

    ($bz, $status) = bzdeflateInit( [PARAMS] ) ;
    ($out, $status) = $bz-&gt;bzdeflate($buffer) ;

    ($bz, $status) = bzinflateInit( [PARAMS] ) ;
    ($out, $status) = $bz-&gt;bzinflate($buffer) ;

    ($out, $status) = $bz-&gt;bzflush() ;
    ($out, $status) = $bz-&gt;bzclose() ;

    $dest = memBzip($source);
        alias compress
    $dest = memBunzip($source);
        alias decompress

    $bz = Compress::Bzip2-&gt;new( [PARAMS] );

    $bz = bzopen($filename or filehandle, $mode);
        alternate, with $bz created by new():
    $bz-&gt;bzopen($filename or filehandle, $mode);

    $bytesread = $bz-&gt;bzread($buffer [,$size]) ;
    $bytesread = $bz-&gt;bzreadline($line);
    $byteswritten = $bz-&gt;bzwrite($buffer [,$limit]);
    $errstring = $bz-&gt;bzerror(); 
    $status = $bz-&gt;bzeof();
    $status = $bz-&gt;bzflush();
    $status = $bz-&gt;bzclose() ;

    $status = $bz-&gt;bzsetparams( $param =&gt; $setting );

    $bz-&gt;total_in() ;
    $bz-&gt;total_out() ;

    $verstring = $bz-&gt;bzversion();

    $Compress::Bzip2::bzerrno
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <i>Compress::Bzip2</i> module provides a Perl interface to the <i>Bzip2</i>
  compression library (see &quot;AUTHOR&quot; for details about where to get
  <i>Bzip2</i>). A relevant subset of the functionality provided by <i>Bzip2</i>
  is available in <i>Compress::Bzip2</i>.
<p class="Pp">All string parameters can either be a scalar or a scalar
    reference.</p>
<p class="Pp">The module can be split into two general areas of functionality,
    namely in-memory compression/decompression and read/write access to
    <i>bzip2</i> files. Each of these areas will be discussed separately
  below.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FILE_READ/WRITE_INTERFACE"><a class="permalink" href="#FILE_READ/WRITE_INTERFACE">FILE
  READ/WRITE INTERFACE</a></h1>
A number of functions are supplied in <i>bzlib</i> for reading and writing
  <i>bzip2</i> files. Unfortunately, most of them are not suitable. So, this
  module provides another interface, built over top of the low level bzlib
  methods.
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$bz_fP_fB_=_bzopen(filename_or_filehandle,_mode)_fP"><a class="permalink" href="#_fB_fP_fB$bz_fP_fB_=_bzopen(filename_or_filehandle,_mode)_fP"><b></b><b>$bz</b><b>
  = bzopen(filename or filehandle, mode)</b></a></h2>
This function returns an object which is used to access the other <i>bzip2</i>
  methods.
<p class="Pp">The <b>mode</b> parameter is used to specify both whether the file
    is opened for reading or writing, with &quot;r&quot; or &quot;w&quot;
    respectively.</p>
<p class="Pp">If a reference to an open filehandle is passed in place of the
    filename, it better be positioned to the start of a
    compression/decompression sequence.</p>
<p class="Pp">WARNING: With Perl 5.6 you cannot use a filehandle because of SEGV
    in destruction with bzclose or an implicit close.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$bz_fP_fB_=_Compress::Bzip2_-_new(___s-1PARAMS_s0__)_fP"><a class="permalink" href="#_fB_fP_fB$bz_fP_fB_=_Compress::Bzip2_-_new(___s-1PARAMS_s0__)_fP"><b></b><b>$bz</b><b>
  = Compress::Bzip2-&gt;new( [PARAMS] )</b></a></h2>
Create a Compress::Bzip2 object. Optionally, provide compression/decompression
  parameters as a keyword =&gt; setting list. See
  <i></i><i>bzsetparams()</i><i></i> for a description of the parameters.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$bz_fP_fB_-_bzopen(filename_or_filehandle,_mode)_fP"><a class="permalink" href="#_fB_fP_fB$bz_fP_fB_-_bzopen(filename_or_filehandle,_mode)_fP"><b></b><b>$bz</b><b>-&gt;bzopen(filename
  or filehandle, mode)</b></a></h2>
This is bzopen, but it uses an object previously created by the new method.
  Other than that, it is identical to the above bzopen.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$bytesread_fP_fB_=__fP_fB$bz_fP_fB_-_bzread($buffer__,__fP_fB$size_fP_fB_)_;_fP"><a class="permalink" href="#_fB_fP_fB$bytesread_fP_fB_=__fP_fB$bz_fP_fB_-_bzread($buffer__,__fP_fB$size_fP_fB_)_;_fP"><b></b><b>$bytesread</b><b>
  = </b><b>$bz</b><b>-&gt;bzread($buffer [, </b><b>$size</b><b>]) ;</b></a></h2>
Reads <b></b><b>$size</b><b></b> bytes from the compressed file into
  <b></b><b>$buffer</b><b></b>. If <b></b><b>$size</b><b></b> is not specified,
  it will default to 4096. If the scalar <b></b><b>$buffer</b><b></b> is not
  large enough, it will be extended automatically.
<p class="Pp">Returns the number of bytes actually read. On EOF it returns 0 and
    in the case of an error, -1.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$bytesread_fP_fB_=__fP_fB$bz_fP_fB_-_bzreadline($line)_;_fP"><a class="permalink" href="#_fB_fP_fB$bytesread_fP_fB_=__fP_fB$bz_fP_fB_-_bzreadline($line)_;_fP"><b></b><b>$bytesread</b><b>
  = </b><b>$bz</b><b>-&gt;bzreadline($line) ;</b></a></h2>
Reads the next line from the compressed file into <b></b><b>$line</b><b></b>.
<p class="Pp">Returns the number of bytes actually read. On EOF it returns 0 and
    in the case of an error, -1.</p>
<p class="Pp">It IS legal to intermix calls to <b>bzread</b> and
    <b>bzreadline</b>.</p>
<p class="Pp">At this time <b>bzreadline</b> ignores the variable
    <span class="Li">$/</span> (<span class="Li">$INPUT_RECORD_SEPARATOR</span>
    or <span class="Li">$RS</span> when
    <span class="Li">&quot;English&quot;</span> is in use). The end of a line is
    denoted by the C character <span class="Li">'\n'</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$byteswritten_fP_fB_=__fP_fB$bz_fP_fB_-_bzwrite($buffer__,__fP_fB$limit_fP_fB_)_;_fP"><a class="permalink" href="#_fB_fP_fB$byteswritten_fP_fB_=__fP_fB$bz_fP_fB_-_bzwrite($buffer__,__fP_fB$limit_fP_fB_)_;_fP"><b></b><b>$byteswritten</b><b>
  = </b><b>$bz</b><b>-&gt;bzwrite($buffer [, </b><b>$limit</b><b>])
  ;</b></a></h2>
Writes the contents of <b></b><b>$buffer</b><b></b> to the compressed file.
  Returns the number of bytes actually written, or 0 on error.
<p class="Pp">If <span class="Li">$limit</span> is given and non-zero, then only
    that many bytes from <span class="Li">$buffer</span> will be written.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$status_fP_fB_=__fP_fB$bz_fP_fB_-_bzflush($flush)_;_fP"><a class="permalink" href="#_fB_fP_fB$status_fP_fB_=__fP_fB$bz_fP_fB_-_bzflush($flush)_;_fP"><b></b><b>$status</b><b>
  = </b><b>$bz</b><b>-&gt;bzflush($flush) ;</b></a></h2>
Flushes all pending output to the compressed file. Works identically to the
  <i>zlib</i> function it interfaces to. Note that the use of <b>bzflush</b> can
  degrade compression.
<p class="Pp">Returns <span class="Li">&quot;BZ_OK&quot;</span> if
    <b></b><b>$flush</b><b></b> is <span class="Li">&quot;BZ_FINISH&quot;</span>
    and all output could be flushed. Otherwise the bzlib error code is
  returned.</p>
<p class="Pp">Refer to the <i>bzlib</i> documentation for the valid values of
    <b></b><b>$flush</b><b></b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$status_fP_fB_=__fP_fB$bz_fP_fB_-__fP_f(BIbzeof()_fP_fB_;_fP"><a class="permalink" href="#_fB_fP_fB$status_fP_fB_=__fP_fB$bz_fP_fB_-__fP_f(BIbzeof()_fP_fB_;_fP"><b></b><b>$status</b><b>
  = </b><b>$bz</b><b>-&gt;</b><b><i>bzeof()</i></b><b> ;</b></a></h2>
Returns 1 if the end of file has been detected while reading the input file,
  otherwise returns 0.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$bz_fP_fB_-_bzclose_fP"><a class="permalink" href="#_fB_fP_fB$bz_fP_fB_-_bzclose_fP"><b></b><b>$bz</b><b>-&gt;bzclose</b></a></h2>
Closes the compressed file. Any pending data is flushed to the file before it is
  closed.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$bz_fP_fB_-_bzsetparams(___s-1PARAMS_s0__);_fP"><a class="permalink" href="#_fB_fP_fB$bz_fP_fB_-_bzsetparams(___s-1PARAMS_s0__);_fP"><b></b><b>$bz</b><b>-&gt;bzsetparams(
  [PARAMS] );</b></a></h2>
Change settings for the deflate stream <span class="Li">$bz</span>.
<p class="Pp">The list of the valid options is shown below. Options not
    specified will remain unchanged.</p>
<dl class="Bl-tag">
  <dt><b>-verbosity</b></dt>
  <dd>Defines the verbosity level. Valid values are 0 through 4,
    <p class="Pp">The default is <span class="Li">&quot;-verbosity =&gt;
        0&quot;</span>.</p>
  </dd>
  <dt><b>-blockSize100k</b></dt>
  <dd>For bzip object opened for stream deflation or write.
    <p class="Pp">Defines the buffering factor of compression method. The
        algorithm buffers all data until the buffer is full, then it flushes all
        the data out. Use -blockSize100k to specify the size of the buffer.</p>
    <p class="Pp">Valid settings are 1 through 9, representing a blocking in
        multiples of 100k.</p>
    <p class="Pp">Note that each such block has an overhead of leading and
        trailing synchronization bytes. bzip2 recovery uses this information to
        pull useable data out of a corrupted file.</p>
    <p class="Pp">A streaming application would probably want to set the
        blocking low.</p>
  </dd>
  <dt><b>-workFactor</b></dt>
  <dd>For bzip object opened for stream deflation or write.
    <p class="Pp">The workFactor setting tells the deflation algorithm how much
        work to invest to compensate for repetitive data.</p>
    <p class="Pp">workFactor may be a number from 0 to 250 inclusive. The
        default setting is 30.</p>
    <p class="Pp">See the bzip documentation for more information.</p>
  </dd>
  <dt><b>-small</b></dt>
  <dd>For bzip object opened for stream inflation or read.
    <p class="Pp"><b>small</b> may be 0 or 1. Set
        <span class="Li">&quot;small&quot;</span> to one to use a slower, less
        memory intensive algorithm.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$bz_fP_fB_-_bzerror_fP"><a class="permalink" href="#_fB_fP_fB$bz_fP_fB_-_bzerror_fP"><b></b><b>$bz</b><b>-&gt;bzerror</b></a></h2>
Returns the <i>bzlib</i> error message or number for the last operation
  associated with <b></b><b>$bz</b><b></b>. The return value will be the
  <i>bzlib</i> error number when used in a numeric context and the <i>bzlib</i>
  error message when used in a string context. The <i>bzlib</i> error number
  constants, shown below, are available for use.
<p class="Pp"><span class="Li"></span></p>
<pre>
  BZ_CONFIG_ERROR
  BZ_DATA_ERROR
  BZ_DATA_ERROR_MAGIC
  BZ_FINISH
  BZ_FINISH_OK
  BZ_FLUSH
  BZ_FLUSH_OK
  BZ_IO_ERROR
  BZ_MAX_UNUSED
  BZ_MEM_ERROR
  BZ_OK
  BZ_OUTBUFF_FULL
  BZ_PARAM_ERROR
  BZ_RUN
  BZ_RUN_OK
  BZ_SEQUENCE_ERROR
  BZ_STREAM_END
  BZ_UNEXPECTED_EOF
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$bz_fP_fB_-_bzclearerr_fP"><a class="permalink" href="#_fB_fP_fB$bz_fP_fB_-_bzclearerr_fP"><b></b><b>$bz</b><b>-&gt;bzclearerr</b></a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$bzerrno_fP_fB_fP"><a class="permalink" href="#_fB_fP_fB$bzerrno_fP_fB_fP"><b></b><b>$bzerrno</b><b></b></a></h2>
The <b></b><b>$bzerrno</b><b></b> scalar holds the error code associated with
  the most recent <i>bzip2</i> routine. Note that unlike
  <b></b><b><i>bzerror()</i></b> <b></b>, the error is <i>not</i> associated
  with a particular file.
<p class="Pp">As with <b></b><b><i>bzerror()</i></b><b></b> it returns an error
    number in numeric context and an error message in string context. Unlike
    <b></b> <b><i>bzerror()</i></b><b></b> though, the error message will
    correspond to the <i>bzlib</i> message when the error is associated with
    <i>bzlib</i> itself, or the UNIX error message when it is not (i.e.
    <i>bzlib</i> returned <span class="Li">&quot;Z_ERRORNO&quot;</span>).</p>
<p class="Pp">As there is an overlap between the error numbers used by
    <i>bzlib</i> and UNIX, <b></b><b>$bzerrno</b><b></b> should only be used to
    check for the presence of <i>an</i> error in numeric context. Use
    <b></b><b><i>bzerror()</i></b><b></b> to check for specific <i>bzlib</i>
    errors. The <i>bzcat</i> example below shows how the variable can be used
    safely.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$bz_fP_fB_-_prefix_fP"><a class="permalink" href="#_fB_fP_fB$bz_fP_fB_-_prefix_fP"><b></b><b>$bz</b><b>-&gt;prefix</b></a></h2>
Returns the additional 5 byte header which is prepended to the bzip2 header
  starting with <span class="Li">&quot;BZh&quot;</span> when using
  memBzip/compress.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Compress::Bzip2_Utilities"><a class="permalink" href="#Compress::Bzip2_Utilities">Compress::Bzip2
  Utilities</a></h1>
Options: -d -c -z -f -v -k -s -1..9
<section class="Ss">
<h2 class="Ss" id="bzip2(___s-1OPTS_s0_,_filename)"><a class="permalink" href="#bzip2(___s-1OPTS_s0_,_filename)">bzip2(
  [OPTS], filename)</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="bunzip2(filename)"><a class="permalink" href="#bunzip2(filename)">bunzip2(filename)</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="bzcat(filenames...)"><a class="permalink" href="#bzcat(filenames...)">bzcat(filenames...)</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIbzlibversion()_fP"><a class="permalink" href="#_fIbzlibversion()_fP"><i>bzlibversion()</i></a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="bzinflateInit(_opts..._)"><a class="permalink" href="#bzinflateInit(_opts..._)">bzinflateInit(
  opts... )</a></h2>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Internal_Utilties"><a class="permalink" href="#Internal_Utilties">Internal
  Utilties</a></h1>
<section class="Ss">
<h2 class="Ss" id="bz_seterror(errno,_msg)_=head2_$bz_-__fIis_read()_fP_=head2_$bz_-__fIis_stream()_fP_=head2_$bz_-__fIis_write()_fP_=head2_$bz_-__fItotal_in()_fP_=head2_$bz_-__fItotal_out()_fP_=head2__fIversion()_fP"><a class="permalink" href="#bz_seterror(errno,_msg)_=head2_$bz_-__fIis_read()_fP_=head2_$bz_-__fIis_stream()_fP_=head2_$bz_-__fIis_write()_fP_=head2_$bz_-__fItotal_in()_fP_=head2_$bz_-__fItotal_out()_fP_=head2__fIversion()_fP">bz_seterror(errno,
  msg) =head2 $bz-&gt;<i>is_read()</i> =head2 $bz-&gt;<i>is_stream()</i> =head2
  $bz-&gt;<i>is_write()</i> =head2 $bz-&gt;<i>total_in()</i> =head2
  $bz-&gt;<i>total_out()</i> =head2 <i>version()</i></a></h2>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Compress::Bzip2_1.03_COMPATIBILITY"><a class="permalink" href="#Compress::Bzip2_1.03_COMPATIBILITY">Compress::Bzip2
  1.03 COMPATIBILITY</a></h1>
While the 2.x thread forked off of 1.00, another line of development came to a
  head at 1.03. The 1.03 version worked with bzlib 1.0.2, had improvements to
  the error handling, single buffer inflate/deflate, a streaming interface to
  inflate/deflate, and a cpan style test suite.
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$dest_fP_fB_=_compress(__fP_fB$string_fP_fB,__$level__)_fP"><a class="permalink" href="#_fB_fP_fB$dest_fP_fB_=_compress(__fP_fB$string_fP_fB,__$level__)_fP"><b></b><b>$dest</b><b>
  = compress( </b><b>$string</b><b>, [$level] )</b></a></h2>
Alias to memBzip, this compresses string, using the optional compression level,
  1 through 9, the default being 6. Returns a string containing the compressed
  data.
<p class="Pp">On error <i>undef</i> is returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$dest_fP_fB_=_decompress($string,__$level_)_fP"><a class="permalink" href="#_fB_fP_fB$dest_fP_fB_=_decompress($string,__$level_)_fP"><b></b><b>$dest</b><b>
  = decompress($string, [$level])</b></a></h2>
Alias to memBunzip, this decompresses the data in string, returning a string
  containing the decompressed data.
<p class="Pp">On error <i>undef</i> is returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="uncompress($string,__$level_)"><a class="permalink" href="#uncompress($string,__$level_)">uncompress($string,
  [$level])</a></h2>
Another alias to memBunzip
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$stream_fP_fB_=_compress_init(___s-1PARAMS_s0__)_fP"><a class="permalink" href="#_fB_fP_fB$stream_fP_fB_=_compress_init(___s-1PARAMS_s0__)_fP"><b></b><b>$stream</b><b>
  = compress_init( [PARAMS] )</b></a></h2>
Alias to bzdeflateInit. In addition to the named parameters documented for
  bzdeflateInit, the following are accepted:
<p class="Pp"><span class="Li"></span></p>
<pre>
   -level, alias to -blockSize100k
   -buffer, to set the buffer size.
</pre>
<p class="Pp">The -buffer option is ignored. The intermediate buffer size is not
    changeable.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$stream_fP_fB_=_decompress_init(___s-1PARAMS_s0__)_fP"><a class="permalink" href="#_fB_fP_fB$stream_fP_fB_=_decompress_init(___s-1PARAMS_s0__)_fP"><b></b><b>$stream</b><b>
  = decompress_init( [PARAMS] )</b></a></h2>
Alias to bzinflateInit. See bzinflateInit for a description of the parameters.
  The option &quot;-buffer&quot; is accepted, but ignored.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$output_fP_fB_=__fP_fB$stream_fP_fB_-_add(__fP_fB$string_fP_fB_)_fP"><a class="permalink" href="#_fB_fP_fB$output_fP_fB_=__fP_fB$stream_fP_fB_-_add(__fP_fB$string_fP_fB_)_fP"><b></b><b>$output</b><b>
  = </b><b>$stream</b><b>-&gt;add( </b><b>$string</b><b> )</b></a></h2>
Add data to be compressed/decompressed. Returns whatever output is available
  (possibly none, if it's still buffering it), or undef on error.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$output_fP_fB_=__fP_fB$stream_fP_fB_-_finish(__$string__)_fP"><a class="permalink" href="#_fB_fP_fB$output_fP_fB_=__fP_fB$stream_fP_fB_-_finish(__$string__)_fP"><b></b><b>$output</b><b>
  = </b><b>$stream</b><b>-&gt;finish( [$string] )</b></a></h2>
Finish the operation; takes an optional final data string. Whatever is returned
  completes the output; returns undef on error.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$stream_fP_fB_-_error_fP"><a class="permalink" href="#_fB_fP_fB$stream_fP_fB_-_error_fP"><b></b><b>$stream</b><b>-&gt;error</b></a></h2>
Like the function, but applies to the current object only. Note that errors in a
  stream object are also returned by the function.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$stream_fP_fB_-_input_size_fP"><a class="permalink" href="#_fB_fP_fB$stream_fP_fB_-_input_size_fP"><b></b><b>$stream</b><b>-&gt;input_size</b></a></h2>
Alias to total_in. Total bytes passed to the stream.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$stream_fP_fB_-_output_size_fP"><a class="permalink" href="#_fB_fP_fB$stream_fP_fB_-_output_size_fP"><b></b><b>$stream</b><b>-&gt;output_size</b></a></h2>
Alias to total_out. Total bytes received from the stream.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="GZIP_COMPATIBILITY_INTERFACE"><a class="permalink" href="#GZIP_COMPATIBILITY_INTERFACE">GZIP
  COMPATIBILITY INTERFACE</a></h1>
Except for the exact state and error numbers, this package presents an interface
  very much like that given by the Compress::Zlib package. Mostly, if you take
  the method name, state or error number from Compress::Zlib and replace the
  &quot;g&quot; with a &quot;b&quot;, your code should work.
<p class="Pp">To make the interoperability even easier, all the Compress::Zlib
    method names have been used as aliases or cover functions for the bzip2
    methods.</p>
<p class="Pp">Therefore, most code that uses Compress::Zlib should be able to
    use this package, with a one line change.</p>
<p class="Pp">Simply change</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   $gz = Compress::Zlib::gzopen( &quot;filename&quot;, &quot;w&quot; );
</pre>
<p class="Pp">to</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   $gz = Compress::Bzip2::gzopen( &quot;filename&quot;, &quot;w&quot; );
</pre>
<p class="Pp">Some of the Compress::Zlib aliases don't return anything useful,
    like crc32 or adler32, cause bzip2 doesn't do that sort of thing.</p>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$gz_fP_fB_=_gzopen(__fP_fB$filename_fP_fB,__fP_fB$mode_fP_fB_)__fP"><a class="permalink" href="#_fB__fP_fB$gz_fP_fB_=_gzopen(__fP_fB$filename_fP_fB,__fP_fB$mode_fP_fB_)__fP"><b>
  </b><b>$gz</b><b> = gzopen( </b><b>$filename</b><b>, </b><b>$mode</b><b> )
  </b></a></h2>
Alias for bzopen.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$gz_fP_fB_-_gzread(__fP_fB$buffer_fP_fB,____fP_fB$length_fP_fB___)__fP"><a class="permalink" href="#_fB__fP_fB$gz_fP_fB_-_gzread(__fP_fB$buffer_fP_fB,____fP_fB$length_fP_fB___)__fP"><b>
  </b><b>$gz</b><b>-&gt;gzread( </b><b>$buffer</b><b>, [ </b><b>$length</b><b> ]
  ) </b></a></h2>
Alias for bzread.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$gz_fP_fB_-_gzreadline(__fP_fB$buffer_fP_fB_)__fP"><a class="permalink" href="#_fB__fP_fB$gz_fP_fB_-_gzreadline(__fP_fB$buffer_fP_fB_)__fP"><b>
  </b><b>$gz</b><b>-&gt;gzreadline( </b><b>$buffer</b><b> ) </b></a></h2>
Alias for bzreadline.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$gz_fP_fB_-_gzwrite(__fP_fB$buffer_fP_fB_)__fP"><a class="permalink" href="#_fB__fP_fB$gz_fP_fB_-_gzwrite(__fP_fB$buffer_fP_fB_)__fP"><b>
  </b><b>$gz</b><b>-&gt;gzwrite( </b><b>$buffer</b><b> ) </b></a></h2>
Alias for bzwrite.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$gz_fP_fB_-_gzflush(__$flushtype__)__fP"><a class="permalink" href="#_fB__fP_fB$gz_fP_fB_-_gzflush(__$flushtype__)__fP"><b>
  </b><b>$gz</b><b>-&gt;gzflush( [$flushtype] ) </b></a></h2>
Alias for bzflush, with return code translation.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$gz_fP_fB_-_gzclose(_)__fP"><a class="permalink" href="#_fB__fP_fB$gz_fP_fB_-_gzclose(_)__fP"><b>
  </b><b>$gz</b><b>-&gt;gzclose( ) </b></a></h2>
Alias for bzclose.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$gz_fP_fB_-_gzeof(_)__fP"><a class="permalink" href="#_fB__fP_fB$gz_fP_fB_-_gzeof(_)__fP"><b>
  </b><b>$gz</b><b>-&gt;gzeof( ) </b></a></h2>
Alias for bzeof.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$gz_fP_fB_-_gzerror(_)__fP"><a class="permalink" href="#_fB__fP_fB$gz_fP_fB_-_gzerror(_)__fP"><b>
  </b><b>$gz</b><b>-&gt;gzerror( ) </b></a></h2>
Alias for bzerror.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$gz_fP_fB_-_gzsetparams(__fP_fB$level_fP_fB,__fP_fB$strategy_fP_fB_)__fP"><a class="permalink" href="#_fB__fP_fB$gz_fP_fB_-_gzsetparams(__fP_fB$level_fP_fB,__fP_fB$strategy_fP_fB_)__fP"><b>
  </b><b>$gz</b><b>-&gt;gzsetparams( </b><b>$level</b><b>,
  </b><b>$strategy</b><b> ) </b></a></h2>
This is a no-op.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$d_fP_fB_=_deflateInit(___s-1OPTS_s0__)__fP"><a class="permalink" href="#_fB__fP_fB$d_fP_fB_=_deflateInit(___s-1OPTS_s0__)__fP"><b>
  </b><b>$d</b><b> = deflateInit( [OPTS] ) </b></a></h2>
Alias for bzdeflateInit, with return code translation.
<p class="Pp">All OPTS are ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$d_fP_fB_-_deflate(__fP_fB$buffer_fP_fB_)__fP"><a class="permalink" href="#_fB__fP_fB$d_fP_fB_-_deflate(__fP_fB$buffer_fP_fB_)__fP"><b>
  </b><b>$d</b><b>-&gt;deflate( </b><b>$buffer</b><b> ) </b></a></h2>
Alias for bzdeflate, with return code translation.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$d_fP_fB_-_deflateParams(___s-1OPTS_s0__)__fP"><a class="permalink" href="#_fB__fP_fB$d_fP_fB_-_deflateParams(___s-1OPTS_s0__)__fP"><b>
  </b><b>$d</b><b>-&gt;deflateParams( [OPTS] ) </b></a></h2>
This is a no-op.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$d_fP_fB_-_flush(__$flushtype__)__fP"><a class="permalink" href="#_fB__fP_fB$d_fP_fB_-_flush(__$flushtype__)__fP"><b>
  </b><b>$d</b><b>-&gt;flush( [$flushtype] ) </b></a></h2>
Cover function for bzflush or bzclose, depending on
  <span class="Li">$flushtype</span>.
<p class="Pp">See the Compress::Zlib documentation for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$d_fP_fB_-_dict_adler(_)__fP"><a class="permalink" href="#_fB__fP_fB$d_fP_fB_-_dict_adler(_)__fP"><b>
  </b><b>$d</b><b>-&gt;dict_adler( ) </b></a></h2>
This is a no-op.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$d_fP_fB_-_msg(_)__fP"><a class="permalink" href="#_fB__fP_fB$d_fP_fB_-_msg(_)__fP"><b>
  </b><b>$d</b><b>-&gt;msg( ) </b></a></h2>
This is a no-op.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$d_fP_fB_=_inflateInit(___s-1OPTS_s0__)__fP"><a class="permalink" href="#_fB__fP_fB$d_fP_fB_=_inflateInit(___s-1OPTS_s0__)__fP"><b>
  </b><b>$d</b><b> = inflateInit( [OPTS] ) </b></a></h2>
Alias for bzinflateInit, with return code translation.
<p class="Pp">All OPTS are ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$d_fP_fB_-_inflate(_)__fP"><a class="permalink" href="#_fB__fP_fB$d_fP_fB_-_inflate(_)__fP"><b>
  </b><b>$d</b><b>-&gt;inflate( ) </b></a></h2>
Alias for bzinflate, with return code translation.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$d_fP_fB_-_inflateSync(_)__fP"><a class="permalink" href="#_fB__fP_fB$d_fP_fB_-_inflateSync(_)__fP"><b>
  </b><b>$d</b><b>-&gt;inflateSync( ) </b></a></h2>
This is a no-op.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$d_fP_fB_-_adler32(__fP_fB$crc_fP_fB_)__fP"><a class="permalink" href="#_fB__fP_fB$d_fP_fB_-_adler32(__fP_fB$crc_fP_fB_)__fP"><b>
  </b><b>$d</b><b>-&gt;adler32( </b><b>$crc</b><b> ) </b></a></h2>
This is a no-op.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$d_fP_fB_-_crc32(__fP_fB$crc_fP_fB_)__fP"><a class="permalink" href="#_fB__fP_fB$d_fP_fB_-_crc32(__fP_fB$crc_fP_fB_)__fP"><b>
  </b><b>$d</b><b>-&gt;crc32( </b><b>$crc</b><b> ) </b></a></h2>
This is a no-op.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$buffer_fP_fB_=_memGzip(__fP_fB$buffer_fP_fB_)__fP"><a class="permalink" href="#_fB__fP_fB$buffer_fP_fB_=_memGzip(__fP_fB$buffer_fP_fB_)__fP"><b>
  </b><b>$buffer</b><b> = memGzip( </b><b>$buffer</b><b> ) </b></a></h2>
Alias for memBzip.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB__fP_fB$buffer_fP_fB_=_memGunzip(__fP_fB$buffer_fP_fB_)__fP"><a class="permalink" href="#_fB__fP_fB$buffer_fP_fB_=_memGunzip(__fP_fB$buffer_fP_fB_)__fP"><b>
  </b><b>$buffer</b><b> = memGunzip( </b><b>$buffer</b><b> ) </b></a></h2>
Alias for memBunzip.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="IN-MEMORY_COMPRESS/UNCOMPRESS"><a class="permalink" href="#IN-MEMORY_COMPRESS/UNCOMPRESS">IN-MEMORY
  COMPRESS/UNCOMPRESS</a></h1>
Two high-level functions are provided by <i>bzlib</i> to perform in-memory
  compression. They are <b>memBzip</b> and <b>memBunzip</b>. Two Perl subs are
  provided which provide similar functionality.
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$compressed_fP_fB_=_memBzip($buffer);_fP"><a class="permalink" href="#_fB_fP_fB$compressed_fP_fB_=_memBzip($buffer);_fP"><b></b><b>$compressed</b><b>
  = memBzip($buffer);</b></a></h2>
Compresses <b></b><b>$buffer</b><b></b>. If successful it returns the compressed
  data. Otherwise it returns <i>undef</i>.
<p class="Pp">The buffer parameter can either be a scalar or a scalar
  reference.</p>
<p class="Pp">Essentially, an in-memory bzip file is created. It creates a
    minimal bzip header, which adds 5 bytes before the bzip2 specific BZh
    header.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_fB$uncompressed_fP_fB_=_memBunzip($buffer);_fP"><a class="permalink" href="#_fB_fP_fB$uncompressed_fP_fB_=_memBunzip($buffer);_fP"><b></b><b>$uncompressed</b><b>
  = memBunzip($buffer);</b></a></h2>
Uncompresses <b></b><b>$buffer</b><b></b>. If successful it returns the
  uncompressed data. Otherwise it returns <i>undef</i>.
<p class="Pp">The source buffer can either be a scalar or a scalar
  reference.</p>
<p class="Pp">The buffer parameter can either be a scalar or a scalar reference.
    The contents of the buffer parameter are destroyed after calling this
    function.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="STREAM_DEFLATE"><a class="permalink" href="#STREAM_DEFLATE">STREAM
  DEFLATE</a></h1>
The Perl interface will <i>always</i> consume the complete input buffer before
  returning. Also the output buffer returned will be automatically grown to fit
  the amount of output available.
<p class="Pp">Here is a definition of the interface available:</p>
<section class="Ss">
<h2 class="Ss" id="_fB($d,__fP_fB$status_fP_fB)_=_bzdeflateInit(___s-1PARAMS_s0__)_fP"><a class="permalink" href="#_fB($d,__fP_fB$status_fP_fB)_=_bzdeflateInit(___s-1PARAMS_s0__)_fP"><b>($d,
  </b><b>$status</b><b>) = bzdeflateInit( [PARAMS] )</b></a></h2>
Initialises a deflation stream.
<p class="Pp">If successful, it will return the initialised deflation stream,
    <b></b><b>$d</b><b></b> and <b></b><b>$status</b><b></b> of
    <span class="Li">&quot;BZ_OK&quot;</span> in a list context. In scalar
    context it returns the deflation stream, <b></b><b>$d</b><b></b>, only.</p>
<p class="Pp">If not successful, the returned deflation stream
    (<b></b><b>$d</b><b></b>) will be <i>undef</i> and
    <b></b><b>$status</b><b></b> will hold the exact <i>bzip2</i> error
  code.</p>
<p class="Pp">The function optionally takes a number of named options specified
    as <span class="Li">&quot;-Name=&gt;value&quot;</span> pairs. This allows
    individual options to be tailored without having to specify them all in the
    parameter list.</p>
<p class="Pp">Here is a list of the valid options:</p>
<dl class="Bl-tag">
  <dt><b>-verbosity</b></dt>
  <dd>Defines the verbosity level. Valid values are 0 through 4,
    <p class="Pp">The default is <span class="Li">&quot;-verbosity =&gt;
        0&quot;</span>.</p>
  </dd>
  <dt><b>-blockSize100k</b></dt>
  <dd>Defines the buffering factor of compression method. The algorithm buffers
      all data until the buffer is full, then it flushes all the data out. Use
      -blockSize100k to specify the size of the buffer.
    <p class="Pp">Valid settings are 1 through 9, representing a blocking in
        multiples of 100k.</p>
    <p class="Pp">Note that each such block has an overhead of leading and
        trailing synchronization bytes. bzip2 recovery uses this information to
        pull useable data out of a corrupted file.</p>
    <p class="Pp">A streaming application would probably want to set the
        blocking low.</p>
  </dd>
  <dt><b>-workFactor</b></dt>
  <dd>The workFactor setting tells the deflation algorithm how much work to
      invest to compensate for repetitive data.
    <p class="Pp">workFactor may be a number from 0 to 250 inclusive. The
        default setting is 30.</p>
    <p class="Pp">See the bzip documentation for more information.</p>
  </dd>
</dl>
<p class="Pp">Here is an example of using the <b>deflateInit</b> optional
    parameter list to override the default buffer size and compression level.
    All other options will take their default values.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    bzdeflateInit( -blockSize100k =&gt; 1, -verbosity =&gt; 1 );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB($out,__fP_fB$status_fP_fB)_=__fP_fB$d_fP_fB_-_bzdeflate($buffer)_fP"><a class="permalink" href="#_fB($out,__fP_fB$status_fP_fB)_=__fP_fB$d_fP_fB_-_bzdeflate($buffer)_fP"><b>($out,
  </b><b>$status</b><b>) = </b><b>$d</b><b>-&gt;bzdeflate($buffer)</b></a></h2>
Deflates the contents of <b></b><b>$buffer</b><b></b>. The buffer can either be
  a scalar or a scalar reference. When finished, <b></b><b>$buffer</b><b></b>
  will be completely processed (assuming there were no errors). If the deflation
  was successful it returns deflated output, <b></b><b>$out</b><b></b>, and a
  status value, <b></b><b>$status</b><b></b>, of
  <span class="Li">&quot;Z_OK&quot;</span>.
<p class="Pp">On error, <b></b><b>$out</b><b></b> will be <i>undef</i> and
    <b></b> <b>$status</b><b></b> will contain the <i>zlib</i> error code.</p>
<p class="Pp">In a scalar context <b>bzdeflate</b> will return
    <b></b><b>$out</b> <b></b> only.</p>
<p class="Pp">As with the internal buffering of the <i>deflate</i> function in
    <i>bzip2</i>, it is not necessarily the case that any output will be
    produced by this method. So don't rely on the fact that
    <b></b><b>$out</b><b></b> is empty for an error test. In fact, given the
    size of bzdeflates internal buffer, with most files it's likely you won't
    see any output at all until flush or close.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB($out,__fP_fB$status_fP_fB)_=__fP_fB$d_fP_fB_-_bzflush(_flush_type_)_fP"><a class="permalink" href="#_fB($out,__fP_fB$status_fP_fB)_=__fP_fB$d_fP_fB_-_bzflush(_flush_type_)_fP"><b>($out,
  </b><b>$status</b><b>) =
  </b><b>$d</b><b>-&gt;bzflush([flush_type])</b></a></h2>
Typically used to finish the deflation. Any pending output will be returned via
  <b></b><b>$out</b><b></b>. <b></b><b>$status</b><b></b> will have a value
  <span class="Li">&quot;BZ_OK&quot;</span> if successful.
<p class="Pp">In a scalar context <b>bzflush</b> will return
    <b></b><b>$out</b><b></b> only.</p>
<p class="Pp">Note that flushing can seriously degrade the compression ratio, so
    it should only be used to terminate a decompression (using
    <span class="Li">&quot;BZ_FLUSH&quot;</span>) or when you want to create a
    <i>full flush point</i> (using
    <span class="Li">&quot;BZ_FINISH&quot;</span>).</p>
<p class="Pp">The allowable values for
    <span class="Li">&quot;flush_type&quot;</span> are
    <span class="Li">&quot;BZ_FLUSH&quot;</span> and
    <span class="Li">&quot;BZ_FINISH&quot;</span>.</p>
<p class="Pp">For a handle opened for &quot;w&quot; (bzwrite), the default is
    <span class="Li">&quot;BZ_FLUSH&quot;</span>. For a stream, the default for
    <span class="Li">&quot;flush_type&quot;</span> is
    <span class="Li">&quot;BZ_FINISH&quot;</span> (which is essentially a close
    and reopen).</p>
<p class="Pp">It is strongly recommended that you only set the
    <span class="Li">&quot;flush_type&quot;</span> parameter if you fully
    understand the implications of what it does. See the
    <span class="Li">&quot;bzip2&quot;</span> documentation for details.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Example"><a class="permalink" href="#Example">Example</a></h2>
Here is a trivial example of using <b>bzdeflate</b>. It simply reads standard
  input, deflates it and writes it to standard output.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict ;
    use warnings ;

    use Compress::Bzip2 ;

    binmode STDIN;
    binmode STDOUT;
    my $x = bzdeflateInit()
       or die &quot;Cannot create a deflation stream\n&quot; ;

    my ($output, $status) ;
    while (&lt;&gt;)
    {
        ($output, $status) = $x-&gt;bzdeflate($_) ;
    
        $status == BZ_OK
            or die &quot;deflation failed\n&quot; ;
    
        print $output ;
    }
    
    ($output, $status) = $x-&gt;bzclose() ;
    
    $status == BZ_OK
        or die &quot;deflation failed\n&quot; ;
    
    print $output ;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="STREAM_INFLATE"><a class="permalink" href="#STREAM_INFLATE">STREAM
  INFLATE</a></h1>
Here is a definition of the interface:
<section class="Ss">
<h2 class="Ss" id="_fB($i,__fP_fB$status_fP_fB)_=__fP_f(BIinflateInit()_fP_fB_fP"><a class="permalink" href="#_fB($i,__fP_fB$status_fP_fB)_=__fP_f(BIinflateInit()_fP_fB_fP"><b>($i,
  </b><b>$status</b><b>) = </b><b><i>inflateInit()</i></b><b></b></a></h2>
Initialises an inflation stream.
<p class="Pp">In a list context it returns the inflation stream,
    <b></b><b>$i</b> <b></b>, and the <i>zlib</i> status code
    (<b></b><b>$status</b> <b></b>). In a scalar context it returns the
    inflation stream only.</p>
<p class="Pp">If successful, <b></b><b>$i</b><b></b> will hold the inflation
    stream and <b></b><b>$status</b><b></b> will be
    <span class="Li">&quot;BZ_OK&quot;</span>.</p>
<p class="Pp">If not successful, <b></b><b>$i</b><b></b> will be <i>undef</i>
    and <b></b><b>$status</b><b></b> will hold the <i>bzlib.h</i> error
  code.</p>
<p class="Pp">The function optionally takes a number of named options specified
    as <span class="Li">&quot;-Name=&gt;value&quot;</span> pairs. This allows
    individual options to be tailored without having to specify them all in the
    parameter list.</p>
<p class="Pp">For backward compatibility, it is also possible to pass the
    parameters as a reference to a hash containing the name=&gt;value pairs.</p>
<p class="Pp">The function takes one optional parameter, a reference to a hash.
    The contents of the hash allow the deflation interface to be tailored.</p>
<p class="Pp">Here is a list of the valid options:</p>
<dl class="Bl-tag">
  <dt><b>-small</b></dt>
  <dd><b>small</b> may be 0 or 1. Set <span class="Li">&quot;small&quot;</span>
      to one to use a slower, less memory intensive algorithm.</dd>
  <dt><b>-verbosity</b></dt>
  <dd>Defines the verbosity level. Valid values are 0 through 4,
    <p class="Pp">The default is <span class="Li">&quot;-verbosity =&gt;
        0&quot;</span>.</p>
  </dd>
</dl>
<p class="Pp">Here is an example of using the <b>bzinflateInit</b> optional
    parameter.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    bzinflateInit( -small =&gt; 1, -verbosity =&gt; 1 );
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fB($out,__fP_fB$status_fP_fB)_=__fP_fB$i_fP_fB_-_bzinflate($buffer)_fP"><a class="permalink" href="#_fB($out,__fP_fB$status_fP_fB)_=__fP_fB$i_fP_fB_-_bzinflate($buffer)_fP"><b>($out,
  </b><b>$status</b><b>) = </b><b>$i</b><b>-&gt;bzinflate($buffer)</b></a></h2>
Inflates the complete contents of <b></b><b>$buffer</b><b></b>. The buffer can
  either be a scalar or a scalar reference.
<p class="Pp">Returns <span class="Li">&quot;BZ_OK&quot;</span> if successful
    and <span class="Li">&quot;BZ_STREAM_END&quot;</span> if the end of the
    compressed data has been successfully reached. If not successful,
    <b></b><b>$out</b><b></b> will be <i>undef</i> and
    <b></b><b>$status</b><b></b> will hold the <i>bzlib</i> error code.</p>
<p class="Pp">The <span class="Li">$buffer</span> parameter is modified by
    <span class="Li">&quot;bzinflate&quot;</span>. On completion it will contain
    what remains of the input buffer after inflation. This means that
    <span class="Li">$buffer</span> will be an empty string when the return
    status is <span class="Li">&quot;BZ_OK&quot;</span>. When the return status
    is <span class="Li">&quot;BZ_STREAM_END&quot;</span> the
    <span class="Li">$buffer</span> parameter will contains what (if anything)
    was stored in the input buffer after the deflated data stream.</p>
<p class="Pp">This feature is useful when processing a file format that
    encapsulates a compressed data stream.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Example_2"><a class="permalink" href="#Example_2">Example</a></h2>
Here is an example of using <b>bzinflate</b>.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use strict ;
    use warnings ;
    
    use Compress::Bzip2;
    
    my $x = bzinflateInit()
       or die &quot;Cannot create a inflation stream\n&quot; ;
    
    my $input = '' ;
    binmode STDIN;
    binmode STDOUT;
    
    my ($output, $status) ;
    while (read(STDIN, $input, 4096))
    {
        ($output, $status) = $x-&gt;bzinflate(\$input) ;
    
        print $output 
            if $status == BZ_OK or $status == BZ_STREAM_END ;
    
        last if $status != BZ_OK ;
    }
    
    die &quot;inflation failed\n&quot;
        unless $status == BZ_STREAM_END ;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
Here are some example scripts of using the interface.
<section class="Ss">
<h2 class="Ss" id="_fBA_bzcat_function_fP"><a class="permalink" href="#_fBA_bzcat_function_fP"><b>A
  bzcat function</b></a></h2>
<span class="Li"></span>
<pre>
  use strict ;
  use warnings ;
    
  use Compress::Bzip2 ;
    
  die &quot;Usage: bzcat file...\n&quot; unless @ARGV ;
    
  my $file ;
    
  foreach $file (@ARGV) {
    my $buffer ;
    
    my $bz = bzopen($file, &quot;rb&quot;) 
       or die &quot;Cannot open $file: $bzerrno\n&quot; ;
    
    print $buffer while $bz-&gt;bzread($buffer) &gt; 0 ;
    
    die &quot;Error reading from $file: $bzerrno&quot; . ($bzerrno+0) . &quot;\n&quot; 
       if $bzerrno != BZ_STREAM_END ;
        
    $bz-&gt;bzclose() ;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBA_grep_using_bzreadline_fP"><a class="permalink" href="#_fBA_grep_using_bzreadline_fP"><b>A
  grep using bzreadline</b></a></h2>
<span class="Li"></span>
<pre>
  use strict ;
  use warnings ;
    
  use Compress::Bzip2 ;
    
  die &quot;Usage: bzgrep pattern file...\n&quot; unless @ARGV &gt;= 2;
    
  my $pattern = shift ;
    
  my $file ;
    
  foreach $file (@ARGV) {
    my $bz = bzopen($file, &quot;rb&quot;) 
       or die &quot;Cannot open $file: $bzerrno\n&quot; ;
    
    while ($bz-&gt;bzreadline($_) &gt; 0) {
      print if /$pattern/ ;
    }
    
    die &quot;Error reading from $file: $bzerrno\n&quot; 
      if $bzerrno != Z_STREAM_END ;
        
    $bz-&gt;bzclose() ;
  }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBStreaming_Compression_fP"><a class="permalink" href="#_fBStreaming_Compression_fP"><b>Streaming
  Compression</b></a></h2>
This script, <i>bzstream</i>, does the opposite of the <i>bzcat</i> script
  above. It reads from standard input and writes a bzip file to standard output.
<p class="Pp"><span class="Li"></span></p>
<pre>
  use strict ;
  use warnings ;
    
  use Compress::Bzip2 ;
    
  binmode STDOUT;       # bzopen only sets it on the fd
    
  my $bz = bzopen(\*STDOUT, &quot;wb&quot;)
     or die &quot;Cannot open stdout: $bzerrno\n&quot; ;
    
  while (&lt;&gt;) {
    $bz-&gt;bzwrite($_) or die &quot;error writing: $bzerrno\n&quot; ;
  }

  $bz-&gt;bzclose ;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORT"><a class="permalink" href="#EXPORT">EXPORT</a></h1>
Use the tags :all, :utilities, :constants, :bzip1 and :gzip.
<section class="Ss">
<h2 class="Ss" id="Export_tag_:all"><a class="permalink" href="#Export_tag_:all">Export
  tag :all</a></h2>
This exports all the exportable methods.
</section>
<section class="Ss">
<h2 class="Ss" id="Export_tag_:constants"><a class="permalink" href="#Export_tag_:constants">Export
  tag :constants</a></h2>
This exports only the BZ_* constants.
</section>
<section class="Ss">
<h2 class="Ss" id="Export_tag_:bzip1"><a class="permalink" href="#Export_tag_:bzip1">Export
  tag :bzip1</a></h2>
This exports the Compress::Bzip2 1.x functions, for compatibility.
<p class="Pp"><span class="Li"></span></p>
<pre>
   compress
   decompress
   compress_init
   decompress_init
   version
</pre>
<p class="Pp">These are actually aliases to memBzip and memBunzip.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Export_tag_:utilities"><a class="permalink" href="#Export_tag_:utilities">Export
  tag :utilities</a></h2>
This gives an interface to the bzip2 methods.
<p class="Pp"><span class="Li"></span></p>
<pre>
    bzopen
    bzinflateInit
    bzdeflateInit
    memBzip
    memBunzip
    bzip2
    bunzip2
    bzcat
    bzlibversion
    $bzerrno
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Export_tag_:gzip"><a class="permalink" href="#Export_tag_:gzip">Export
  tag :gzip</a></h2>
This gives compatibility with Compress::Zlib.
<p class="Pp"><span class="Li"></span></p>
<pre>
    gzopen
    gzinflateInit
    gzdeflateInit
    memGzip
    memGunzip
    $gzerrno
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Exportable_constants"><a class="permalink" href="#Exportable_constants">Exportable
  constants</a></h1>
All the <i>bzlib</i> constants are automatically imported when you make use of
  <i>Compress::Bzip2</i>.
<p class="Pp"><span class="Li"></span></p>
<pre>
  BZ_CONFIG_ERROR
  BZ_DATA_ERROR
  BZ_DATA_ERROR_MAGIC
  BZ_FINISH
  BZ_FINISH_OK
  BZ_FLUSH
  BZ_FLUSH_OK
  BZ_IO_ERROR
  BZ_MAX_UNUSED
  BZ_MEM_ERROR
  BZ_OK
  BZ_OUTBUFF_FULL
  BZ_PARAM_ERROR
  BZ_RUN
  BZ_RUN_OK
  BZ_SEQUENCE_ERROR
  BZ_STREAM_END
  BZ_UNEXPECTED_EOF
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
The documentation for zlib, bzip2 and Compress::Zlib.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Rob Janes, &lt;arjay at cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
Copyright (C) 2005 by Rob Janes
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself, either Perl version 5.8.3 or,
    at your option, any later version of Perl 5 you may have available.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR_2"><a class="permalink" href="#AUTHOR_2">AUTHOR</a></h1>
The <i>Compress::Bzip2</i> module was originally written by Gawdi Azem
  <i>azemgi@rupert.informatik.uni-stuttgart.de</i>.
<p class="Pp">The first <i>Compress::Bzip2</i> module was written by Gawdi Azem
    <i>azemgi@rupert.informatik.uni-stuttgart.de</i>. It provided an interface
    to the in memory inflate and deflate routines.</p>
<p class="Pp"><i>Compress::Bzip2</i> was subsequently passed on to Marco Carnut
    <i>kiko@tempest.com.br</i> who shepherded it through to version 1.03, a set
    of changes which included upgrades to handle bzlib 1.0.2, and improvements
    to the in memory inflate and deflate routines. The streaming interface and
    error information were added by David Robins
    <i>dbrobins@davidrobins.net</i>.</p>
<p class="Pp">Version 2 of <i>Compress::Bzip2</i> is due to Rob Janes, of
    arjay@cpan.org. This release is intended to give an interface close to that
    of Compress::Zlib. It's development forks from 1.00, not 1.03, so the
    streaming interface is not the same as that in 1.03, although apparently
    compatible as it passes the 1.03 test suite.</p>
<p class="Pp">Minor subsequent fixes and releases were done by Reini Urban,
    rurban@cpan.org.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MODIFICATION_HISTORY"><a class="permalink" href="#MODIFICATION_HISTORY">MODIFICATION
  HISTORY</a></h1>
See the Changes file.
<p class="Pp">2.00 Second public release of <i>Compress::Bzip2</i>.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-08-28</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
