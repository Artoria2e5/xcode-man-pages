<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   -*- nroff -*-
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>MPSCNNConvolution(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MPSCNNConvolution(3)</td>
    <td class="head-vol">MetalPerformanceShaders.framework</td>
    <td class="head-rtitle">MPSCNNConvolution(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
MPSCNNConvolution
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">#import &lt;MPSCNNConvolution.h&gt;</p>
<p class="Pp">Inherits <b>MPSCNNKernel</b>.</p>
<p class="Pp">Inherited by <b>MPSCNNFullyConnected</b>.</p>
<section class="Ss">
<h2 class="Ss" id="Instance_Methods"><a class="permalink" href="#Instance_Methods">Instance
  Methods</a></h2>
<br/>
(nonnull instancetype) - <b>initWithDevice:weights:</b>
<br/>
(nonnull instancetype) -
  <b>initWithDevice:convolutionDescriptor:kernelWeights:biasTerms:flags:</b>
<br/>
(nullable instancetype) - <b>initWithCoder:device:</b>
<br/>
(nonnull instancetype) - <b>initWithDevice:</b>
<br/>
(<b>MPSCNNConvolutionGradientState</b> *__nullable) -
  <b>resultStateForSourceImage:sourceStates:destinationImage:</b>
<br/>
(<b>MPSCNNConvolutionGradientStateBatch</b> *__nullable) -
  <b>resultStateBatchForSourceImage:sourceStates:destinationImage:</b>
<br/>
(<b>MPSCNNConvolutionGradientState</b> *__nullable) -
  <b>temporaryResultStateForCommandBuffer:sourceImage:sourceStates:destinationImage:</b>
<br/>
(<b>MPSCNNConvolutionGradientStateBatch</b> *__nullable) -
  <b>temporaryResultStateBatchForCommandBuffer:sourceImage:sourceStates:destinationImage:</b>
<br/>
(void) - <b>reloadWeightsAndBiasesFromDataSource</b>
<br/>
(void) - <b>reloadWeightsAndBiasesWithDataSource:</b>
<br/>
(void) - <b>reloadWeightsAndBiasesWithCommandBuffer:state:</b>
<br/>
(<b>MPSCNNConvolutionWeightsAndBiasesState</b> *__nonnull) -
  <b>exportWeightsAndBiasesWithCommandBuffer:resultStateCanBeTemporary:</b>
<br/>
<br/>
</section>
<section class="Ss">
<h2 class="Ss" id="Properties"><a class="permalink" href="#Properties">Properties</a></h2>
<br/>
NSUInteger <b>inputFeatureChannels</b>
<br/>
NSUInteger <b>outputFeatureChannels</b>
<br/>
NSUInteger <b>groups</b>
<br/>
id&lt; <b>MPSCNNConvolutionDataSource</b> &gt; <b>dataSource</b>
<br/>
NSUInteger <b>subPixelScaleFactor</b>
<br/>
const <b>MPSCNNNeuron</b> *__nullable <b>neuron</b>
<br/>
const <b>MPSCNNNeuron</b> *__nullable <b>MPSCNNNeuronType</b> <b>neuronType</b>
<br/>
const <b>MPSCNNNeuron</b> *__nullable <b>MPSCNNNeuronType</b> float
  <b>neuronParameterA</b>
<br/>
const <b>MPSCNNNeuron</b> *__nullable <b>MPSCNNNeuronType</b> float float
  <b>neuronParameterB</b>
<br/>
const <b>MPSCNNNeuron</b> *__nullable <b>MPSCNNNeuronType</b> float float float
  <b>neuronParameterC</b>
<br/>
const <b>MPSCNNNeuron</b> *__nullable <b>MPSCNNNeuronType</b> float float float
  <b>MPSNNNeuronDescriptor</b> *__nullable <b>fusedNeuronDescriptor</b>
<br/>
const <b>MPSCNNNeuron</b> *__nullable <b>MPSCNNNeuronType</b> float float float
  <b>MPSNNNeuronDescriptor</b> *__nullable NSUInteger <b>channelMultiplier</b>
<br/>
<b>MPSNNConvolutionAccumulatorPrecisionOption</b>
  <b>accumulatorPrecisionOption</b>
<br/>
<br/>
</section>
<section class="Ss">
<h2 class="Ss" id="Additional_Inherited_Members"><a class="permalink" href="#Additional_Inherited_Members">Additional
  Inherited Members</a></h2>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Detailed_Description"><a class="permalink" href="#Detailed_Description">Detailed
  Description</a></h1>
This depends on Metal.framework The <b>MPSCNNConvolution</b> specifies a
  convolution. The <b>MPSCNNConvolution</b> convolves the input image with a set
  of filters, each producing one feature map in the output image.
</section>
<section class="Sh">
<h1 class="Sh" id="Method_Documentation"><a class="permalink" href="#Method_Documentation">Method
  Documentation</a></h1>
<section class="Ss">
<h2 class="Ss" id="_-_(_fBMPSCNNConvolutionWeightsAndBiasesState_fP*___nonnull)_exportWeightsAndBiasesWithCommandBuffer:_(__nonnull_id__MTLCommandBuffer__)_commandBuffer(BOOL)_resultStateCanBeTemporary"><a class="permalink" href="#_-_(_fBMPSCNNConvolutionWeightsAndBiasesState_fP*___nonnull)_exportWeightsAndBiasesWithCommandBuffer:_(__nonnull_id__MTLCommandBuffer__)_commandBuffer(BOOL)_resultStateCanBeTemporary">-
  (<b>MPSCNNConvolutionWeightsAndBiasesState</b>* __nonnull)
  exportWeightsAndBiasesWithCommandBuffer: (__nonnull id&lt; MTLCommandBuffer
  &gt;) commandBuffer(BOOL) resultStateCanBeTemporary</a></h2>
GPU side export. Enqueue a kernel to export current weights and biases stored in
  MPSCNNConvoltion's internal buffers into weights and biases MTLBuffer returned
  in <b>MPSCNNConvolutionWeightsAndBiasesState</b>.
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>commandBuffer</i> Metal command buffer on which export
  kernel is enqueued.
<br/>
<i>resultStateCanBeTemporary</i> If FALSE, state returned will be non-temporary.
  If TRUE, returned state may or may not be temporary.</div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent"><b>MPSCNNConvolutionWeightsAndBiasesState</b> containing
  weights and biases buffer to which weights got exported. This state and be
  temporary or non-temporary depending on the flag
  resultStateCanBeTemporary</div>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(nullable_instancetype)__fBinitWithCoder:_fP_(NSCoder_*__nonnull)_aDecoder(nonnull_id__MTLDevice__)_device"><a class="permalink" href="#_-_(nullable_instancetype)__fBinitWithCoder:_fP_(NSCoder_*__nonnull)_aDecoder(nonnull_id__MTLDevice__)_device">-
  (nullable instancetype) <b>initWithCoder:</b> (NSCoder *__nonnull)
  aDecoder(nonnull id&lt; MTLDevice &gt;) device</a></h2>
<b>NSSecureCoding</b> compatability While the standard NSSecureCoding/NSCoding
  method -initWithCoder: should work, since the file can't know which device
  your data is allocated on, we have to guess and may guess incorrectly. To
  avoid that problem, use initWithCoder:device instead.
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>aDecoder</i> The NSCoder subclass with your serialized
  <b>MPSKernel</b>
<br/>
<i>device</i> The MTLDevice on which to make the <b>MPSKernel</b></div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent"><b>A</b> new <b>MPSKernel</b> object, or nil if
  failure.</div>
<p class="Pp">Reimplemented from <b>MPSCNNKernel</b>.</p>
<p class="Pp">Reimplemented in <b>MPSCNNFullyConnected</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(nonnull_instancetype)_initWithDevice:_(nonnull_id__MTLDevice__)_device"><a class="permalink" href="#_-_(nonnull_instancetype)_initWithDevice:_(nonnull_id__MTLDevice__)_device">-
  (nonnull instancetype) initWithDevice: (nonnull id&lt; MTLDevice &gt;)
  device</a></h2>
Standard init with default properties per filter type
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>device</i> The device that the filter will be used on.
  May not be NULL.</div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent"><b>A</b> pointer to the newly initialized object. This
  will fail, returning nil if the device is not supported. Devices must be
  MTLFeatureSet_iOS_GPUFamily2_v1 or later.</div>
<p class="Pp">Reimplemented from <b>MPSCNNKernel</b>.</p>
<p class="Pp">Reimplemented in <b>MPSCNNFullyConnected</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(nonnull_instancetype)__fBinitWithDevice:_fP_(nonnull_id__MTLDevice__)_device(const__fBMPSCNNConvolutionDescriptor_fP_*__nonnull)_convolutionDescriptor(const_float_*__nonnull)_kernelWeights(const_float_*__nullable)_biasTerms(_fBMPSCNNConvolutionFlags_fP)_flags"><a class="permalink" href="#_-_(nonnull_instancetype)__fBinitWithDevice:_fP_(nonnull_id__MTLDevice__)_device(const__fBMPSCNNConvolutionDescriptor_fP_*__nonnull)_convolutionDescriptor(const_float_*__nonnull)_kernelWeights(const_float_*__nullable)_biasTerms(_fBMPSCNNConvolutionFlags_fP)_flags">-
  (nonnull instancetype) <b>initWithDevice:</b> (nonnull id&lt; MTLDevice &gt;)
  device(const <b>MPSCNNConvolutionDescriptor</b> *__nonnull)
  convolutionDescriptor(const float *__nonnull) kernelWeights(const float
  *__nullable) biasTerms(<b>MPSCNNConvolutionFlags</b>) flags</a></h2>
Initializes a convolution kernel WARNING: This API is depreated and will be
  removed in the future. It cannot be used when training. Also
  serialization/unserialization wont work for <b>MPSCNNConvolution</b> objects
  created with this init. Please move onto using initWithDevice:weights:.
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>device</i> The MTLDevice on which this
  <b>MPSCNNConvolution</b> filter will be used
<br/>
<i>convolutionDescriptor</i> <b>A</b> pointer to a
  <b>MPSCNNConvolutionDescriptor</b>.
<br/>
<i>kernelWeights</i> <b>A</b> pointer to a weights array. Each entry is a float
  value. The number of entries is = inputFeatureChannels * outputFeatureChannels
  * kernelHeight * kernelWidth The layout of filter weight is so that it can be
  reinterpreted as 4D tensor (array) weight[ outputChannels ][ kernelHeight ][
  kernelWidth ][ inputChannels / groups ] Weights are converted to half float
  (fp16) internally for best performance.
<br/>
<i>biasTerms</i> <b>A</b> pointer to bias terms to be applied to the convolution
  output. Each entry is a float value. The number of entries is =
  numberOfOutputFeatureMaps
<br/>
<i>flags</i> Currently unused. Pass MPSCNNConvolutionFlagsNone</div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent"><b>A</b> valid <b>MPSCNNConvolution</b> object or nil, if
  failure.</div>
<p class="Pp">Reimplemented in <b>MPSCNNFullyConnected</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(nonnull_instancetype)__fBinitWithDevice:_fP_(nonnull_id__MTLDevice__)_device(nonnull_id___fBMPSCNNConvolutionDataSource_fP__)_weights"><a class="permalink" href="#_-_(nonnull_instancetype)__fBinitWithDevice:_fP_(nonnull_id__MTLDevice__)_device(nonnull_id___fBMPSCNNConvolutionDataSource_fP__)_weights">-
  (nonnull instancetype) <b>initWithDevice:</b> (nonnull id&lt; MTLDevice &gt;)
  device(nonnull id&lt; <b>MPSCNNConvolutionDataSource</b> &gt;)
  weights</a></h2>
Initializes a convolution kernel
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>device</i> The MTLDevice on which this
  <b>MPSCNNConvolution</b> filter will be used
<br/>
<i>weights</i> <b>A</b> pointer to a object that conforms to the
  <b>MPSCNNConvolutionDataSource</b> protocol. The
  <b>MPSCNNConvolutionDataSource</b> protocol declares the methods that an
  instance of <b>MPSCNNConvolution</b> uses to obtain the weights and bias terms
  for the CNN convolution filter.</div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent"><b>A</b> valid <b>MPSCNNConvolution</b> object or nil, if
  failure.</div>
<p class="Pp">Reimplemented in <b>MPSCNNFullyConnected</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(void)_reloadWeightsAndBiasesFromDataSource"><a class="permalink" href="#_-_(void)_reloadWeightsAndBiasesFromDataSource">-
  (void) reloadWeightsAndBiasesFromDataSource </a></h2>
CPU side reload. Reload the updated weights and biases from data provider into
  internal weights and bias buffers. Weights and biases gradients needed for
  update are obtained from <b>MPSCNNConvolutionGradientState</b> object. Data
  provider passed in init call is used for this purpose.
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(void)_reloadWeightsAndBiasesWithCommandBuffer:_(__nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSCNNConvolutionWeightsAndBiasesState_fP_*__nonnull)_state"><a class="permalink" href="#_-_(void)_reloadWeightsAndBiasesWithCommandBuffer:_(__nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSCNNConvolutionWeightsAndBiasesState_fP_*__nonnull)_state">-
  (void) reloadWeightsAndBiasesWithCommandBuffer: (__nonnull id&lt;
  MTLCommandBuffer &gt;)
  commandBuffer(<b>MPSCNNConvolutionWeightsAndBiasesState</b> *__nonnull)
  state</a></h2>
GPU side reload. Reload the updated weights and biases from update buffer
  produced by application enqueued metal kernel into internal weights and biases
  buffer. Weights and biases gradients needed for update are obtained from
  <b>MPSCNNConvolutionGradientState</b> object's gradientForWeights and
  gradientForBiases metal buffer.
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>commandBuffer</i> Metal command buffer on which
  application update kernel was enqueued consuming
  <b>MPSCNNConvolutionGradientState</b>'s gradientForWeights and
  gradientForBiases buffers and producing updateBuffer metal buffer.
<br/>
<i>state</i> <b>MPSCNNConvolutionWeightsAndBiasesState</b> containing weights
  and biases buffers which have updated weights produced by application's update
  kernel. The state readcount will be decremented.</div>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(void)_reloadWeightsAndBiasesWithDataSource:_(__nonnull_id___fBMPSCNNConvolutionDataSource_fP__)_dataSource"><a class="permalink" href="#_-_(void)_reloadWeightsAndBiasesWithDataSource:_(__nonnull_id___fBMPSCNNConvolutionDataSource_fP__)_dataSource">-
  (void) reloadWeightsAndBiasesWithDataSource: (__nonnull id&lt;
  <b>MPSCNNConvolutionDataSource</b> &gt;) dataSource</a></h2>
Deprecated. dataSource will be ignored.
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(_fBMPSCNNConvolutionGradientStateBatch_fP_*___nullable)_resultStateBatchForSourceImage:_(_fBMPSImageBatch_fP_*__nonnull)_sourceImage(NSArray___fBMPSStateBatch_fP_*___*__nullable)_sourceStates(_fBMPSImageBatch_fP_*_Nonnull)_destinationImage"><a class="permalink" href="#_-_(_fBMPSCNNConvolutionGradientStateBatch_fP_*___nullable)_resultStateBatchForSourceImage:_(_fBMPSImageBatch_fP_*__nonnull)_sourceImage(NSArray___fBMPSStateBatch_fP_*___*__nullable)_sourceStates(_fBMPSImageBatch_fP_*_Nonnull)_destinationImage">-
  (<b>MPSCNNConvolutionGradientStateBatch</b> * __nullable)
  resultStateBatchForSourceImage: (<b>MPSImageBatch</b> *__nonnull)
  sourceImage(NSArray&lt; <b>MPSStateBatch</b> * &gt; *__nullable)
  sourceStates(<b>MPSImageBatch</b> *_Nonnull) destinationImage</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(_fBMPSCNNConvolutionGradientState_fP_*___nullable)_resultStateForSourceImage:_(_fBMPSImage_fP_*__nonnull)_sourceImage(NSArray___fBMPSState_fP_*___*__nullable)_sourceStates(_fBMPSImage_fP_*__nonnull)_destinationImage"><a class="permalink" href="#_-_(_fBMPSCNNConvolutionGradientState_fP_*___nullable)_resultStateForSourceImage:_(_fBMPSImage_fP_*__nonnull)_sourceImage(NSArray___fBMPSState_fP_*___*__nullable)_sourceStates(_fBMPSImage_fP_*__nonnull)_destinationImage">-
  (<b>MPSCNNConvolutionGradientState</b> * __nullable)
  resultStateForSourceImage: (<b>MPSImage</b> *__nonnull)
  sourceImage(NSArray&lt; <b>MPSState</b> * &gt; *__nullable)
  sourceStates(<b>MPSImage</b> *__nonnull) destinationImage</a></h2>
Allocate a MPCNNConvolutionGradientSState to hold the results from a
  -encodeBatchToCommandBuffer... operation
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>sourceImage</i> The <b>MPSImage</b> consumed by the
  associated -encode call.
<br/>
<i>sourceStates</i> The list of MPSStates consumed by the associated -encode
  call, for a batch size of 1.</div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent">The list of states produced by the -encode call for batch
  size of 1. -isResultStateReusedAcrossBatch returns YES for
  <b>MPSCNNConvolution</b> so same state is used across entire batch. State
  object is not reusasable across batches.</div>
<p class="Pp">Reimplemented from <b>MPSCNNKernel</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(_fBMPSCNNConvolutionGradientStateBatch_fP_*___nullable)_temporaryResultStateBatchForCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImageBatch_fP_*__nonnull)_sourceImage(NSArray___fBMPSStateBatch_fP_*___*__nullable)_sourceStates(_fBMPSImageBatch_fP_*__nonnull)_destinationImage"><a class="permalink" href="#_-_(_fBMPSCNNConvolutionGradientStateBatch_fP_*___nullable)_temporaryResultStateBatchForCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImageBatch_fP_*__nonnull)_sourceImage(NSArray___fBMPSStateBatch_fP_*___*__nullable)_sourceStates(_fBMPSImageBatch_fP_*__nonnull)_destinationImage">-
  (<b>MPSCNNConvolutionGradientStateBatch</b> * __nullable)
  temporaryResultStateBatchForCommandBuffer: (nonnull id&lt; MTLCommandBuffer
  &gt;) commandBuffer(<b>MPSImageBatch</b> *__nonnull) sourceImage(NSArray&lt;
  <b>MPSStateBatch</b> * &gt; *__nullable) sourceStates(<b>MPSImageBatch</b>
  *__nonnull) destinationImage</a></h2>
Reimplemented from <b>MPSCNNKernel</b>.
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(_fBMPSCNNConvolutionGradientState_fP_*___nullable)_temporaryResultStateForCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImage_fP_*__nonnull)_sourceImage(NSArray___fBMPSState_fP_*___*__nullable)_sourceStates(_fBMPSImage_fP_*__nonnull)_destinationImage"><a class="permalink" href="#_-_(_fBMPSCNNConvolutionGradientState_fP_*___nullable)_temporaryResultStateForCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImage_fP_*__nonnull)_sourceImage(NSArray___fBMPSState_fP_*___*__nullable)_sourceStates(_fBMPSImage_fP_*__nonnull)_destinationImage">-
  (<b>MPSCNNConvolutionGradientState</b> * __nullable)
  temporaryResultStateForCommandBuffer: (nonnull id&lt; MTLCommandBuffer &gt;)
  commandBuffer(<b>MPSImage</b> *__nonnull) sourceImage(NSArray&lt;
  <b>MPSState</b> * &gt; *__nullable) sourceStates(<b>MPSImage</b> *__nonnull)
  destinationImage</a></h2>
Allocate a temporary <b>MPSState</b> (subclass) to hold the results from a
  -encodeBatchToCommandBuffer... operation <b>A</b> graph may need to allocate
  storage up front before executing. This may be necessary to avoid using too
  much memory and to manage large batches. The function should allocate any
  <b>MPSState</b> objects that will be produced by an -encode call with the
  indicated sourceImages and sourceStates inputs. Though the states can be
  further adjusted in the ensuing -encode call, the states should be initialized
  with all important data and all MTLResource storage allocated. The data stored
  in the MTLResource need not be initialized, unless the ensuing -encode call
  expects it to be.
<p class="Pp">The MTLDevice used by the result is derived from the command
    buffer. The padding policy will be applied to the filter before this is
    called to give it the chance to configure any properties like
    <b>MPSCNNKernel.offset</b>.</p>
<p class="Pp">CAUTION: The kernel must have all properties set to values that
    will ultimately be passed to the -encode call that writes to the state,
    before -resultStateForSourceImages:sourceStates:destinationImage: is called
    or behavior is undefined. Please note that
    -destinationImageDescriptorForSourceImages:sourceStates:destinationImage:
    will alter some of these properties automatically based on the padding
    policy. If you intend to call that to make the destination image, then you
    should call that before
    -resultStateForSourceImages:sourceStates:destinationImage:. This will ensure
    the properties used in the encode call and in the destination image creation
    match those used to configure the state.</p>
<p class="Pp">The following order is recommended:</p>
<p class="Pp"></p>
<pre>
// Configure MPSCNNKernel properties first
kernel.edgeMode = MPSImageEdgeModeZero;
kernel.destinationFeatureChannelOffset = 128; // concatenation without the copy
// ALERT: will change MPSCNNKernel properties
MPSImageDescriptor * d = [kernel destinationImageDescriptorForSourceImage: source
                                                             sourceStates: states];
MPSTemporaryImage * dest = [MPSTemporaryImage temporaryImageWithCommandBuffer: cmdBuf
                                                              imageDescriptor: d];
// Now that all properties are configured properly, we can make the result state
// and call encode.
MPSState * __nullable destState = [kernel temporaryResultStateForCommandBuffer: cmdBuf
                                                                   sourceImage: source
                                                                  sourceStates: states];
// This form of -encode will be declared by the MPSCNNKernel subclass
[kernel encodeToCommandBuffer: cmdBuf
                  sourceImage: source
             destinationState: destState
             destinationImage: dest ];
</pre>
<p class="Pp">Default: returns nil</p>
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>commandBuffer</i> The command buffer to allocate the
  temporary storage against The state will only be valid on this command buffer.
<br/>
<i>sourceImage</i> The <b>MPSImage</b> consumed by the associated -encode call.
<br/>
<i>sourceStates</i> The list of MPSStates consumed by the associated -encode
  call, for a batch size of 1.
<br/>
<i>destinationImage</i> The destination image for the encode call</div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent">The list of states produced by the -encode call for batch
  size of 1. When the batch size is not 1, this function will be called
  repeatedly unless -isResultStateReusedAcrossBatch returns YES. If
  -isResultStateReusedAcrossBatch returns YES, then it will be called once per
  batch and the MPSStateBatch array will contain MPSStateBatch.length references
  to the same object.</div>
<p class="Pp">Reimplemented from <b>MPSCNNKernel</b>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Property_Documentation"><a class="permalink" href="#Property_Documentation">Property
  Documentation</a></h1>
<section class="Ss">
<h2 class="Ss" id="_-_(_fBMPSNNConvolutionAccumulatorPrecisionOption_fP)_accumulatorPrecisionOption_fC__read__fP,__fC__write__fP,__fC__nonatomic__fP,__fC__assign__fP"><a class="permalink" href="#_-_(_fBMPSNNConvolutionAccumulatorPrecisionOption_fP)_accumulatorPrecisionOption_fC__read__fP,__fC__write__fP,__fC__nonatomic__fP,__fC__assign__fP">-
  (<b>MPSNNConvolutionAccumulatorPrecisionOption</b>) accumulatorPrecisionOption
  [read]<b>, [write]</b>, [nonatomic]<b>, [assign]</b></a></h2>
Precision of accumulator used in convolution. See <b>MPSNeuralNetworkTypes.h</b>
  for discussion. Default is MPSNNConvolutionAccumulatorPrecisionOptionFloat.
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(const__fBMPSCNNNeuron_fP*___nullable__fBMPSCNNNeuronType_fP_float_float_float__fBMPSNNNeuronDescriptor_fP*___nullable_NSUInteger)_channelMultiplier_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP"><a class="permalink" href="#_-_(const__fBMPSCNNNeuron_fP*___nullable__fBMPSCNNNeuronType_fP_float_float_float__fBMPSNNNeuronDescriptor_fP*___nullable_NSUInteger)_channelMultiplier_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP">-
  (const <b>MPSCNNNeuron</b>* __nullable <b>MPSCNNNeuronType</b> float float
  float <b>MPSNNNeuronDescriptor</b>* __nullable NSUInteger) channelMultiplier
  [read]<b>, [nonatomic]</b>, [assign]<b></b></a></h2>
Channel multiplier. For convolution created with
  <b>MPSCNNDepthWiseConvolutionDescriptor</b>, it is the number of output
  feature channels for each input channel. See
  <b>MPSCNNDepthWiseConvolutionDescriptor</b> for more details. Default is 0
  which means regular CNN convolution.
</section>
<section class="Ss">
<h2 class="Ss" id="_-_dataSource_fC__read__fP,__fC__nonatomic__fP,__fC__retain__fP"><a class="permalink" href="#_-_dataSource_fC__read__fP,__fC__nonatomic__fP,__fC__retain__fP">-
  dataSource [read]<b>, [nonatomic]</b>, [retain]<b></b></a></h2>
dataSource with which convolution object was created
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(const__fBMPSCNNNeuron_fP*___nullable__fBMPSCNNNeuronType_fP_float_float_float__fBMPSNNNeuronDescriptor_fP*___nullable)_fusedNeuronDescriptor_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP"><a class="permalink" href="#_-_(const__fBMPSCNNNeuron_fP*___nullable__fBMPSCNNNeuronType_fP_float_float_float__fBMPSNNNeuronDescriptor_fP*___nullable)_fusedNeuronDescriptor_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP">-
  (const <b>MPSCNNNeuron</b>* __nullable <b>MPSCNNNeuronType</b> float float
  float <b>MPSNNNeuronDescriptor</b>* __nullable) fusedNeuronDescriptor
  [read]<b>, [nonatomic]</b>, [assign]<b></b></a></h2>
Fused neuron descritor passed in convolution descriptor for fusion with
  convolution. Please see class description for interpretation of c.
</section>
<section class="Ss">
<h2 class="Ss" id="_-_groups_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP"><a class="permalink" href="#_-_groups_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP">-
  groups [read]<b>, [nonatomic]</b>, [assign]<b></b></a></h2>
Number of groups input and output channels are divided into.
</section>
<section class="Ss">
<h2 class="Ss" id="_-_inputFeatureChannels_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP"><a class="permalink" href="#_-_inputFeatureChannels_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP">-
  inputFeatureChannels [read]<b>, [nonatomic]</b>, [assign]<b></b></a></h2>
The number of feature channels per pixel in the input image.
</section>
<section class="Ss">
<h2 class="Ss" id="_-_neuron_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP"><a class="permalink" href="#_-_neuron_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP">-
  neuron [read]<b>, [nonatomic]</b>, [assign]<b></b></a></h2>
<b>MPSCNNNeuron</b> filter to be applied as part of convolution. Can be nil in
  wich case no neuron activation fuction is applied.
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(const__fBMPSCNNNeuron_fP*___nullable__fBMPSCNNNeuronType_fP_float)_neuronParameterA_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP"><a class="permalink" href="#_-_(const__fBMPSCNNNeuron_fP*___nullable__fBMPSCNNNeuronType_fP_float)_neuronParameterA_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP">-
  (const <b>MPSCNNNeuron</b>* __nullable <b>MPSCNNNeuronType</b> float)
  neuronParameterA [read]<b>, [nonatomic]</b>, [assign]<b></b></a></h2>
Parameter 'a' for the neuron. Default: 1.0f Please see class description for
  interpretation of a.
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(const__fBMPSCNNNeuron_fP*___nullable__fBMPSCNNNeuronType_fP_float_float)_neuronParameterB_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP"><a class="permalink" href="#_-_(const__fBMPSCNNNeuron_fP*___nullable__fBMPSCNNNeuronType_fP_float_float)_neuronParameterB_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP">-
  (const <b>MPSCNNNeuron</b>* __nullable <b>MPSCNNNeuronType</b> float float)
  neuronParameterB [read]<b>, [nonatomic]</b>, [assign]<b></b></a></h2>
Parameter 'b' for the neuron. Default: 1.0f Please see class description for
  interpretation of b.
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(const__fBMPSCNNNeuron_fP*___nullable__fBMPSCNNNeuronType_fP_float_float_float)_neuronParameterC_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP"><a class="permalink" href="#_-_(const__fBMPSCNNNeuron_fP*___nullable__fBMPSCNNNeuronType_fP_float_float_float)_neuronParameterC_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP">-
  (const <b>MPSCNNNeuron</b>* __nullable <b>MPSCNNNeuronType</b> float float
  float) neuronParameterC [read]<b>, [nonatomic]</b>, [assign]<b></b></a></h2>
Parameter 'c' for the neuron. Default: 1.0f Please see class description for
  interpretation of c.
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(const__fBMPSCNNNeuron_fP*___nullable__fBMPSCNNNeuronType_fP)_neuronType_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP"><a class="permalink" href="#_-_(const__fBMPSCNNNeuron_fP*___nullable__fBMPSCNNNeuronType_fP)_neuronType_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP">-
  (const <b>MPSCNNNeuron</b>* __nullable <b>MPSCNNNeuronType</b>) neuronType
  [read]<b>, [nonatomic]</b>, [assign]<b></b></a></h2>
The type of neuron to append to the convolution Please see class description for
  a full list. Default is MPSCNNNeuronTypeNone.
</section>
<section class="Ss">
<h2 class="Ss" id="_-_outputFeatureChannels_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP"><a class="permalink" href="#_-_outputFeatureChannels_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP">-
  outputFeatureChannels [read]<b>, [nonatomic]</b>, [assign]<b></b></a></h2>
The number of feature channels per pixel in the output image.
</section>
<section class="Ss">
<h2 class="Ss" id="_-_subPixelScaleFactor_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP"><a class="permalink" href="#_-_subPixelScaleFactor_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP">-
  subPixelScaleFactor [read]<b>, [nonatomic]</b>, [assign]<b></b></a></h2>
Sub pixel scale factor which was passed in as part of
  <b>MPSCNNConvolutionDescriptor</b> when creating this <b>MPSCNNConvolution</b>
  object.
<p class="Pp"></p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Author"><a class="permalink" href="#Author">Author</a></h1>
Generated automatically by Doxygen for MetalPerformanceShaders.framework from
  the source code.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">Mon Jul 9 2018</td>
    <td class="foot-os">Version MetalPerformanceShaders-119.3</td>
  </tr>
</table>
</body>
</html>
