<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Socket(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Socket(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Socket(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
&quot;Socket&quot; - networking constants and support functions
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li">&quot;Socket&quot;</span> a low-level module used by, among
  other things, the IO::Socket family of modules. The following examples
  demonstrate some low-level uses but a practical program would likely use the
  higher-level API provided by <span class="Li">&quot;IO::Socket&quot;</span> or
  similar instead.
<p class="Pp"><span class="Li"></span></p>
<pre>
 use Socket qw(PF_INET SOCK_STREAM pack_sockaddr_in inet_aton);

 socket(my $socket, PF_INET, SOCK_STREAM, 0)
     or die &quot;socket: $!&quot;;

 my $port = getservbyname &quot;echo&quot;, &quot;tcp&quot;;
 connect($socket, pack_sockaddr_in($port, inet_aton(&quot;localhost&quot;)))
     or die &quot;connect: $!&quot;;

 print $socket &quot;Hello, world!\n&quot;;
 print &lt;$socket&gt;;
</pre>
<p class="Pp">See also the &quot;EXAMPLES&quot; section.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module provides a variety of constants, structure manipulators and other
  functions related to socket-based networking. The values and functions
  provided are useful when used in conjunction with Perl core functions such as
  <i>socket()</i>, <i>setsockopt()</i> and <i>bind()</i>. It also provides
  several other support functions, mostly for dealing with conversions of
  network addresses between human-readable and native binary forms, and for
  hostname resolver operations.
<p class="Pp">Some constants and functions are exported by default by this
    module; but for backward-compatibility any recently-added symbols are not
    exported by default and must be requested explicitly. When an import list is
    provided to the <span class="Li">&quot;use Socket&quot;</span> line, the
    default exports are not automatically imported. It is therefore best
    practice to always to explicitly list all the symbols required.</p>
<p class="Pp">Also, some common socket &quot;newline&quot; constants are
    provided: the constants <span class="Li">&quot;CR&quot;</span>,
    <span class="Li">&quot;LF&quot;</span>, and
    <span class="Li">&quot;CRLF&quot;</span>, as well as
    <span class="Li">$CR</span>, <span class="Li">$LF</span>, and
    <span class="Li">$CRLF</span>, which map to
    <span class="Li">&quot;\015&quot;</span>,
    <span class="Li">&quot;\012&quot;</span>, and
    <span class="Li">&quot;\015\012&quot;</span>. If you do not want to use the
    literal characters in your programs, then use the constants provided here.
    They are not exported by default, but can be imported individually, and with
    the <span class="Li">&quot;:crlf&quot;</span> export tag:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 use Socket qw(:DEFAULT :crlf);

 $sock-&gt;print(&quot;GET / HTTP/1.0$CRLF&quot;);
</pre>
<p class="Pp">The entire <i>getaddrinfo()</i> subsystem can be exported using
    the tag <span class="Li">&quot;:addrinfo&quot;</span>; this exports the
    <i>getaddrinfo()</i> and <i>getnameinfo()</i> functions, and all the
    <span class="Li">&quot;AI_*&quot;</span>,
    <span class="Li">&quot;NI_*&quot;</span>,
    <span class="Li">&quot;NIx_*&quot;</span> and
    <span class="Li">&quot;EAI_*&quot;</span> constants.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSTANTS"><a class="permalink" href="#CONSTANTS">CONSTANTS</a></h1>
In each of the following groups, there may be many more constants provided than
  just the ones given as examples in the section heading. If the heading ends
  <span class="Li">&quot;...&quot;</span> then this means there are likely more;
  the exact constants provided will depend on the OS and headers found at
  compile-time.
<section class="Ss">
<h2 class="Ss" id="_s-1PF_INET,_PF_INET6,_PF_UNIX,_..._s0"><a class="permalink" href="#_s-1PF_INET,_PF_INET6,_PF_UNIX,_..._s0">PF_INET,
  PF_INET6, PF_UNIX, ...</a></h2>
Protocol family constants to use as the first argument to <i>socket()</i> or the
  value of the <span class="Li">&quot;SO_DOMAIN&quot;</span> or
  <span class="Li">&quot;SO_FAMILY&quot;</span> socket option.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1AF_INET,_AF_INET6,_AF_UNIX,_..._s0"><a class="permalink" href="#_s-1AF_INET,_AF_INET6,_AF_UNIX,_..._s0">AF_INET,
  AF_INET6, AF_UNIX, ...</a></h2>
Address family constants used by the socket address structures, to pass to such
  functions as <i>inet_pton()</i> or <i>getaddrinfo()</i>, or are returned by
  such functions as <i>sockaddr_family()</i>.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1SOCK_STREAM,_SOCK_DGRAM,_SOCK_RAW,_..._s0"><a class="permalink" href="#_s-1SOCK_STREAM,_SOCK_DGRAM,_SOCK_RAW,_..._s0">SOCK_STREAM,
  SOCK_DGRAM, SOCK_RAW, ...</a></h2>
Socket type constants to use as the second argument to <i>socket()</i>, or the
  value of the <span class="Li">&quot;SO_TYPE&quot;</span> socket option.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1SOCK_NONBLOCK._SOCK_CLOEXEC_s0"><a class="permalink" href="#_s-1SOCK_NONBLOCK._SOCK_CLOEXEC_s0">SOCK_NONBLOCK.
  SOCK_CLOEXEC</a></h2>
Linux-specific shortcuts to specify the
  <span class="Li">&quot;O_NONBLOCK&quot;</span> and
  <span class="Li">&quot;FD_CLOEXEC&quot;</span> flags during a
  <span class="Li">socket(2)</span> call.
<p class="Pp"><span class="Li"></span></p>
<pre>
 socket( my $sockh, PF_INET, SOCK_DGRAM|SOCK_NONBLOCK, 0 )
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1SOL_SOCKET_s0"><a class="permalink" href="#_s-1SOL_SOCKET_s0">SOL_SOCKET</a></h2>
Socket option level constant for <i>setsockopt()</i> and <i>getsockopt()</i>.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1SO_ACCEPTCONN,_SO_BROADCAST,_SO_ERROR,_..._s0"><a class="permalink" href="#_s-1SO_ACCEPTCONN,_SO_BROADCAST,_SO_ERROR,_..._s0">SO_ACCEPTCONN,
  SO_BROADCAST, SO_ERROR, ...</a></h2>
Socket option name constants for <i>setsockopt()</i> and <i>getsockopt()</i> at
  the <span class="Li">&quot;SOL_SOCKET&quot;</span> level.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1IP_OPTIONS,_IP_TOS,_IP_TTL,_..._s0"><a class="permalink" href="#_s-1IP_OPTIONS,_IP_TOS,_IP_TTL,_..._s0">IP_OPTIONS,
  IP_TOS, IP_TTL, ...</a></h2>
Socket option name constants for IPv4 socket options at the
  <span class="Li">&quot;IPPROTO_IP&quot;</span> level.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1MSG_BCAST,_MSG_OOB,_MSG_TRUNC,_..._s0"><a class="permalink" href="#_s-1MSG_BCAST,_MSG_OOB,_MSG_TRUNC,_..._s0">MSG_BCAST,
  MSG_OOB, MSG_TRUNC, ...</a></h2>
Message flag constants for <i>send()</i> and <i>recv()</i>.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1SHUT_RD,_SHUT_RDWR,_SHUT_WR_s0"><a class="permalink" href="#_s-1SHUT_RD,_SHUT_RDWR,_SHUT_WR_s0">SHUT_RD,
  SHUT_RDWR, SHUT_WR</a></h2>
Direction constants for <i>shutdown()</i>.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1INADDR_ANY,_INADDR_BROADCAST,_INADDR_LOOPBACK,_INADDR_NONE_s0"><a class="permalink" href="#_s-1INADDR_ANY,_INADDR_BROADCAST,_INADDR_LOOPBACK,_INADDR_NONE_s0">INADDR_ANY,
  INADDR_BROADCAST, INADDR_LOOPBACK, INADDR_NONE</a></h2>
Constants giving the special <span class="Li">&quot;AF_INET&quot;</span>
  addresses for wildcard, broadcast, local loopback, and invalid addresses.
<p class="Pp">Normally equivalent to inet_aton('0.0.0.0'),
    inet_aton('255.255.255.255'), inet_aton('localhost') and
    inet_aton('255.255.255.255') respectively.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1IPPROTO_IP,_IPPROTO_IPV6,_IPPROTO_TCP,_..._s0"><a class="permalink" href="#_s-1IPPROTO_IP,_IPPROTO_IPV6,_IPPROTO_TCP,_..._s0">IPPROTO_IP,
  IPPROTO_IPV6, IPPROTO_TCP, ...</a></h2>
IP protocol constants to use as the third argument to <i>socket()</i>, the level
  argument to <i>getsockopt()</i> or <i>setsockopt()</i>, or the value of the
  <span class="Li">&quot;SO_PROTOCOL&quot;</span> socket option.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1TCP_CORK,_TCP_KEEPALIVE,_TCP_NODELAY,_..._s0"><a class="permalink" href="#_s-1TCP_CORK,_TCP_KEEPALIVE,_TCP_NODELAY,_..._s0">TCP_CORK,
  TCP_KEEPALIVE, TCP_NODELAY, ...</a></h2>
Socket option name constants for TCP socket options at the
  <span class="Li">&quot;IPPROTO_TCP&quot;</span> level.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1IN6ADDR_ANY,_IN6ADDR_LOOPBACK_s0"><a class="permalink" href="#_s-1IN6ADDR_ANY,_IN6ADDR_LOOPBACK_s0">IN6ADDR_ANY,
  IN6ADDR_LOOPBACK</a></h2>
Constants giving the special <span class="Li">&quot;AF_INET6&quot;</span>
  addresses for wildcard and local loopback.
<p class="Pp">Normally equivalent to inet_pton(AF_INET6, &quot;::&quot;) and
    inet_pton(AF_INET6, &quot;::1&quot;) respectively.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1IPV6_ADD_MEMBERSHIP,_IPV6_MTU,_IPV6_V6ONLY,_..._s0"><a class="permalink" href="#_s-1IPV6_ADD_MEMBERSHIP,_IPV6_MTU,_IPV6_V6ONLY,_..._s0">IPV6_ADD_MEMBERSHIP,
  IPV6_MTU, IPV6_V6ONLY, ...</a></h2>
Socket option name constants for IPv6 socket options at the
  <span class="Li">&quot;IPPROTO_IPV6&quot;</span> level.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="STRUCTURE_MANIPULATORS"><a class="permalink" href="#STRUCTURE_MANIPULATORS">STRUCTURE
  MANIPULATORS</a></h1>
The following functions convert between lists of Perl values and packed binary
  strings representing structures.
<section class="Ss">
<h2 class="Ss" id="$family_=_sockaddr_family_$sockaddr"><a class="permalink" href="#$family_=_sockaddr_family_$sockaddr">$family
  = sockaddr_family $sockaddr</a></h2>
Takes a packed socket address (as returned by <i>pack_sockaddr_in()</i>,
  <i>pack_sockaddr_un()</i> or the perl builtin functions <i>getsockname()</i>
  and <i>getpeername()</i>). Returns the address family tag. This will be one of
  the <span class="Li">&quot;AF_*&quot;</span> constants, such as
  <span class="Li">&quot;AF_INET&quot;</span> for a
  <span class="Li">&quot;sockaddr_in&quot;</span> addresses or
  <span class="Li">&quot;AF_UNIX&quot;</span> for a
  <span class="Li">&quot;sockaddr_un&quot;</span>. It can be used to figure out
  what unpack to use for a sockaddr of unknown type.
</section>
<section class="Ss">
<h2 class="Ss" id="$sockaddr_=_pack_sockaddr_in_$port,_$ip_address"><a class="permalink" href="#$sockaddr_=_pack_sockaddr_in_$port,_$ip_address">$sockaddr
  = pack_sockaddr_in $port, $ip_address</a></h2>
Takes two arguments, a port number and an opaque string (as returned by
  <i>inet_aton()</i>, or a v-string). Returns the
  <span class="Li">&quot;sockaddr_in&quot;</span> structure with those arguments
  packed in and <span class="Li">&quot;AF_INET&quot;</span> filled in. For
  Internet domain sockets, this structure is normally what you need for the
  arguments in <i>bind()</i>, <i>connect()</i>, and <i>send()</i>.
</section>
<section class="Ss">
<h2 class="Ss" id="($port,_$ip_address)_=_unpack_sockaddr_in_$sockaddr"><a class="permalink" href="#($port,_$ip_address)_=_unpack_sockaddr_in_$sockaddr">($port,
  $ip_address) = unpack_sockaddr_in $sockaddr</a></h2>
Takes a <span class="Li">&quot;sockaddr_in&quot;</span> structure (as returned
  by <i>pack_sockaddr_in()</i>, <i>getpeername()</i> or <i>recv()</i>). Returns
  a list of two elements: the port and an opaque string representing the IP
  address (you can use <i>inet_ntoa()</i> to convert the address to the
  four-dotted numeric format). Will croak if the structure does not represent an
  <span class="Li">&quot;AF_INET&quot;</span> address.
<p class="Pp">In scalar context will return just the IP address.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$sockaddr_=_sockaddr_in_$port,_$ip_address"><a class="permalink" href="#$sockaddr_=_sockaddr_in_$port,_$ip_address">$sockaddr
  = sockaddr_in $port, $ip_address</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="($port,_$ip_address)_=_sockaddr_in_$sockaddr"><a class="permalink" href="#($port,_$ip_address)_=_sockaddr_in_$sockaddr">($port,
  $ip_address) = sockaddr_in $sockaddr</a></h2>
A wrapper of <i>pack_sockaddr_in()</i> or <i>unpack_sockaddr_in()</i>. In list
  context, unpacks its argument and returns a list consisting of the port and IP
  address. In scalar context, packs its port and IP address arguments as a
  <span class="Li">&quot;sockaddr_in&quot;</span> and returns it.
<p class="Pp">Provided largely for legacy compatibility; it is better to use
    <i>pack_sockaddr_in()</i> or <i>unpack_sockaddr_in()</i> explicitly.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$sockaddr_=_pack_sockaddr_in6_$port,_$ip6_address,__$scope_id,__$flowinfo__"><a class="permalink" href="#$sockaddr_=_pack_sockaddr_in6_$port,_$ip6_address,__$scope_id,__$flowinfo__">$sockaddr
  = pack_sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]</a></h2>
Takes two to four arguments, a port number, an opaque string (as returned by
  <i>inet_pton()</i>), optionally a scope ID number, and optionally a flow label
  number. Returns the <span class="Li">&quot;sockaddr_in6&quot;</span> structure
  with those arguments packed in and
  <span class="Li">&quot;AF_INET6&quot;</span> filled in. IPv6 equivalent of
  <i>pack_sockaddr_in()</i>.
</section>
<section class="Ss">
<h2 class="Ss" id="($port,_$ip6_address,_$scope_id,_$flowinfo)_=_unpack_sockaddr_in6_$sockaddr"><a class="permalink" href="#($port,_$ip6_address,_$scope_id,_$flowinfo)_=_unpack_sockaddr_in6_$sockaddr">($port,
  $ip6_address, $scope_id, $flowinfo) = unpack_sockaddr_in6 $sockaddr</a></h2>
Takes a <span class="Li">&quot;sockaddr_in6&quot;</span> structure. Returns a
  list of four elements: the port number, an opaque string representing the IPv6
  address, the scope ID, and the flow label. (You can use <i>inet_ntop()</i> to
  convert the address to the usual string format). Will croak if the structure
  does not represent an <span class="Li">&quot;AF_INET6&quot;</span> address.
<p class="Pp">In scalar context will return just the IP address.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$sockaddr_=_sockaddr_in6_$port,_$ip6_address,__$scope_id,__$flowinfo__"><a class="permalink" href="#$sockaddr_=_sockaddr_in6_$port,_$ip6_address,__$scope_id,__$flowinfo__">$sockaddr
  = sockaddr_in6 $port, $ip6_address, [$scope_id, [$flowinfo]]</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="($port,_$ip6_address,_$scope_id,_$flowinfo)_=_sockaddr_in6_$sockaddr"><a class="permalink" href="#($port,_$ip6_address,_$scope_id,_$flowinfo)_=_sockaddr_in6_$sockaddr">($port,
  $ip6_address, $scope_id, $flowinfo) = sockaddr_in6 $sockaddr</a></h2>
A wrapper of <i>pack_sockaddr_in6()</i> or <i>unpack_sockaddr_in6()</i>. In list
  context, unpacks its argument according to <i>unpack_sockaddr_in6()</i>. In
  scalar context, packs its arguments according to <i>pack_sockaddr_in6()</i>.
<p class="Pp">Provided largely for legacy compatibility; it is better to use
    <i>pack_sockaddr_in6()</i> or <i>unpack_sockaddr_in6()</i> explicitly.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$sockaddr_=_pack_sockaddr_un_$path"><a class="permalink" href="#$sockaddr_=_pack_sockaddr_un_$path">$sockaddr
  = pack_sockaddr_un $path</a></h2>
Takes one argument, a pathname. Returns the
  <span class="Li">&quot;sockaddr_un&quot;</span> structure with that path
  packed in with <span class="Li">&quot;AF_UNIX&quot;</span> filled in. For
  <span class="Li">&quot;PF_UNIX&quot;</span> sockets, this structure is
  normally what you need for the arguments in <i>bind()</i>, <i>connect()</i>,
  and <i>send()</i>.
</section>
<section class="Ss">
<h2 class="Ss" id="($path)_=_unpack_sockaddr_un_$sockaddr"><a class="permalink" href="#($path)_=_unpack_sockaddr_un_$sockaddr">($path)
  = unpack_sockaddr_un $sockaddr</a></h2>
Takes a <span class="Li">&quot;sockaddr_un&quot;</span> structure (as returned
  by <i>pack_sockaddr_un()</i>, <i>getpeername()</i> or <i>recv()</i>). Returns
  a list of one element: the pathname. Will croak if the structure does not
  represent an <span class="Li">&quot;AF_UNIX&quot;</span> address.
</section>
<section class="Ss">
<h2 class="Ss" id="$sockaddr_=_sockaddr_un_$path"><a class="permalink" href="#$sockaddr_=_sockaddr_un_$path">$sockaddr
  = sockaddr_un $path</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="($path)_=_sockaddr_un_$sockaddr"><a class="permalink" href="#($path)_=_sockaddr_un_$sockaddr">($path)
  = sockaddr_un $sockaddr</a></h2>
A wrapper of <i>pack_sockaddr_un()</i> or <i>unpack_sockaddr_un()</i>. In a list
  context, unpacks its argument and returns a list consisting of the pathname.
  In a scalar context, packs its pathname as a
  <span class="Li">&quot;sockaddr_un&quot;</span> and returns it.
<p class="Pp">Provided largely for legacy compatibility; it is better to use
    <i>pack_sockaddr_un()</i> or <i>unpack_sockaddr_un()</i> explicitly.</p>
<p class="Pp">These are only supported if your system has
    &lt;<i>sys/un.h</i>&gt;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$ip_mreq_=_pack_ip_mreq_$multiaddr,_$interface"><a class="permalink" href="#$ip_mreq_=_pack_ip_mreq_$multiaddr,_$interface">$ip_mreq
  = pack_ip_mreq $multiaddr, $interface</a></h2>
Takes an IPv4 multicast address and optionally an interface address (or
  <span class="Li">&quot;INADDR_ANY&quot;</span>). Returns the
  <span class="Li">&quot;ip_mreq&quot;</span> structure with those arguments
  packed in. Suitable for use with the
  <span class="Li">&quot;IP_ADD_MEMBERSHIP&quot;</span> and
  <span class="Li">&quot;IP_DROP_MEMBERSHIP&quot;</span> sockopts.
</section>
<section class="Ss">
<h2 class="Ss" id="($multiaddr,_$interface)_=_unpack_ip_mreq_$ip_mreq"><a class="permalink" href="#($multiaddr,_$interface)_=_unpack_ip_mreq_$ip_mreq">($multiaddr,
  $interface) = unpack_ip_mreq $ip_mreq</a></h2>
Takes an <span class="Li">&quot;ip_mreq&quot;</span> structure. Returns a list
  of two elements; the IPv4 multicast address and interface address.
</section>
<section class="Ss">
<h2 class="Ss" id="$ip_mreq_source_=_pack_ip_mreq_source_$multiaddr,_$source,_$interface"><a class="permalink" href="#$ip_mreq_source_=_pack_ip_mreq_source_$multiaddr,_$source,_$interface">$ip_mreq_source
  = pack_ip_mreq_source $multiaddr, $source, $interface</a></h2>
Takes an IPv4 multicast address, source address, and optionally an interface
  address (or <span class="Li">&quot;INADDR_ANY&quot;</span>). Returns the
  <span class="Li">&quot;ip_mreq_source&quot;</span> structure with those
  arguments packed in. Suitable for use with the
  <span class="Li">&quot;IP_ADD_SOURCE_MEMBERSHIP&quot;</span> and
  <span class="Li">&quot;IP_DROP_SOURCE_MEMBERSHIP&quot;</span> sockopts.
</section>
<section class="Ss">
<h2 class="Ss" id="($multiaddr,_$source,_$interface)_=_unpack_ip_mreq_source_$ip_mreq"><a class="permalink" href="#($multiaddr,_$source,_$interface)_=_unpack_ip_mreq_source_$ip_mreq">($multiaddr,
  $source, $interface) = unpack_ip_mreq_source $ip_mreq</a></h2>
Takes an <span class="Li">&quot;ip_mreq_source&quot;</span> structure. Returns a
  list of three elements; the IPv4 multicast address, source address and
  interface address.
</section>
<section class="Ss">
<h2 class="Ss" id="$ipv6_mreq_=_pack_ipv6_mreq_$multiaddr6,_$ifindex"><a class="permalink" href="#$ipv6_mreq_=_pack_ipv6_mreq_$multiaddr6,_$ifindex">$ipv6_mreq
  = pack_ipv6_mreq $multiaddr6, $ifindex</a></h2>
Takes an IPv6 multicast address and an interface number. Returns the
  <span class="Li">&quot;ipv6_mreq&quot;</span> structure with those arguments
  packed in. Suitable for use with the
  <span class="Li">&quot;IPV6_ADD_MEMBERSHIP&quot;</span> and
  <span class="Li">&quot;IPV6_DROP_MEMBERSHIP&quot;</span> sockopts.
</section>
<section class="Ss">
<h2 class="Ss" id="($multiaddr6,_$ifindex)_=_unpack_ipv6_mreq_$ipv6_mreq"><a class="permalink" href="#($multiaddr6,_$ifindex)_=_unpack_ipv6_mreq_$ipv6_mreq">($multiaddr6,
  $ifindex) = unpack_ipv6_mreq $ipv6_mreq</a></h2>
Takes an <span class="Li">&quot;ipv6_mreq&quot;</span> structure. Returns a list
  of two elements; the IPv6 address and an interface number.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="$ip_address_=_inet_aton_$string"><a class="permalink" href="#$ip_address_=_inet_aton_$string">$ip_address
  = inet_aton $string</a></h2>
Takes a string giving the name of a host, or a textual representation of an IP
  address and translates that to an packed binary address structure suitable to
  pass to <i>pack_sockaddr_in()</i>. If passed a hostname that cannot be
  resolved, returns <span class="Li">&quot;undef&quot;</span>. For multi-homed
  hosts (hosts with more than one address), the first address found is returned.
<p class="Pp">For portability do not assume that the result of
    <i>inet_aton()</i> is 32 bits wide, in other words, that it would contain
    only the IPv4 address in network order.</p>
<p class="Pp">This IPv4-only function is provided largely for legacy reasons.
    Newly-written code should use <i>getaddrinfo()</i> or <i>inet_pton()</i>
    instead for IPv6 support.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$string_=_inet_ntoa_$ip_address"><a class="permalink" href="#$string_=_inet_ntoa_$ip_address">$string
  = inet_ntoa $ip_address</a></h2>
Takes a packed binary address structure such as returned by
  <i>unpack_sockaddr_in()</i> (or a v-string representing the four octets of the
  IPv4 address in network order) and translates it into a string of the form
  <span class="Li">&quot;d.d.d.d&quot;</span> where the
  <span class="Li">&quot;d&quot;</span>s are numbers less than 256 (the normal
  human-readable four dotted number notation for Internet addresses).
<p class="Pp">This IPv4-only function is provided largely for legacy reasons.
    Newly-written code should use <i>getnameinfo()</i> or <i>inet_ntop()</i>
    instead for IPv6 support.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$address_=_inet_pton_$family,_$string"><a class="permalink" href="#$address_=_inet_pton_$family,_$string">$address
  = inet_pton $family, $string</a></h2>
Takes an address family (such as <span class="Li">&quot;AF_INET&quot;</span> or
  <span class="Li">&quot;AF_INET6&quot;</span>) and a string containing a
  textual representation of an address in that family and translates that to an
  packed binary address structure.
<p class="Pp">See also <i>getaddrinfo()</i> for a more powerful and flexible
    function to look up socket addresses given hostnames or textual
  addresses.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$string_=_inet_ntop_$family,_$address"><a class="permalink" href="#$string_=_inet_ntop_$family,_$address">$string
  = inet_ntop $family, $address</a></h2>
Takes an address family and a packed binary address structure and translates it
  into a human-readable textual representation of the address; typically in
  <span class="Li">&quot;d.d.d.d&quot;</span> form for
  <span class="Li">&quot;AF_INET&quot;</span> or
  <span class="Li">&quot;hhhh:hhhh::hhhh&quot;</span> form for
  <span class="Li">&quot;AF_INET6&quot;</span>.
<p class="Pp">See also <i>getnameinfo()</i> for a more powerful and flexible
    function to turn socket addresses into human-readable textual
    representations.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="($err,_@result)_=_getaddrinfo_$host,_$service,__$hints_"><a class="permalink" href="#($err,_@result)_=_getaddrinfo_$host,_$service,__$hints_">($err,
  @result) = getaddrinfo $host, $service, [$hints]</a></h2>
Given both a hostname and service name, this function attempts to resolve the
  host name into a list of network addresses, and the service name into a
  protocol and port number, and then returns a list of address structures
  suitable to <i>connect()</i> to it.
<p class="Pp">Given just a host name, this function attempts to resolve it to a
    list of network addresses, and then returns a list of address structures
    giving these addresses.</p>
<p class="Pp">Given just a service name, this function attempts to resolve it to
    a protocol and port number, and then returns a list of address structures
    that represent it suitable to <i>bind()</i> to. This use should be combined
    with the <span class="Li">&quot;AI_PASSIVE&quot;</span> flag; see below.</p>
<p class="Pp">Given neither name, it generates an error.</p>
<p class="Pp">If present, <span class="Li">$hints</span> should be a reference
    to a hash, where the following keys are recognised:</p>
<dl class="Bl-tag">
  <dt>flags =&gt; INT</dt>
  <dd>A bitfield containing <span class="Li">&quot;AI_*&quot;</span> constants;
      see below.</dd>
  <dt>family =&gt; INT</dt>
  <dd>Restrict to only generating addresses in this address family</dd>
  <dt>socktype =&gt; INT</dt>
  <dd>Restrict to only generating addresses of this socket type</dd>
  <dt>protocol =&gt; INT</dt>
  <dd>Restrict to only generating addresses for this protocol</dd>
</dl>
<p class="Pp">The return value will be a list; the first value being an error
    indication, followed by a list of address structures (if no error
  occurred).</p>
<p class="Pp">The error value will be a dualvar; comparable to the
    <span class="Li">&quot;EI_*&quot;</span> error constants, or printable as a
    human-readable error message string. If no error occurred it will be zero
    numerically and an empty string.</p>
<p class="Pp">Each value in the results list will be a hash reference containing
    the following fields:</p>
<dl class="Bl-tag">
  <dt>family =&gt; INT</dt>
  <dd>The address family (e.g. <span class="Li">&quot;AF_INET&quot;</span>)</dd>
  <dt>socktype =&gt; INT</dt>
  <dd>The socket type (e.g.
    <span class="Li">&quot;SOCK_STREAM&quot;</span>)</dd>
  <dt>protocol =&gt; INT</dt>
  <dd>The protocol (e.g. <span class="Li">&quot;IPPROTO_TCP&quot;</span>)</dd>
  <dt>addr =&gt; STRING</dt>
  <dd>The address in a packed string (such as would be returned by
      <i>pack_sockaddr_in()</i>)</dd>
  <dt>canonname =&gt; STRING</dt>
  <dd>The canonical name for the host if the
      <span class="Li">&quot;AI_CANONNAME&quot;</span> flag was provided, or
      <span class="Li">&quot;undef&quot;</span> otherwise. This field will only
      be present on the first returned address.</dd>
</dl>
<p class="Pp">The following flag constants are recognised in the
    <span class="Li">$hints</span> hash. Other flag constants may exist as
    provided by the OS.</p>
<dl class="Bl-tag">
  <dt>AI_PASSIVE</dt>
  <dd>Indicates that this resolution is for a local <i>bind()</i> for a passive
      (i.e. listening) socket, rather than an active (i.e. connecting)
    socket.</dd>
  <dt>AI_CANONNAME</dt>
  <dd>Indicates that the caller wishes the canonical hostname
      (<span class="Li">&quot;canonname&quot;</span>) field of the result to be
      filled in.</dd>
  <dt>AI_NUMERICHOST</dt>
  <dd>Indicates that the caller will pass a numeric address, rather than a
      hostname, and that <i>getaddrinfo()</i> must not perform a resolve
      operation on this name. This flag will prevent a possibly-slow network
      lookup operation, and instead return an error if a hostname is
    passed.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="($err,_$hostname,_$servicename)_=_getnameinfo_$sockaddr,__$flags,__$xflags__"><a class="permalink" href="#($err,_$hostname,_$servicename)_=_getnameinfo_$sockaddr,__$flags,__$xflags__">($err,
  $hostname, $servicename) = getnameinfo $sockaddr, [$flags, [$xflags]]</a></h2>
Given a packed socket address (such as from <i>getsockname()</i>,
  <i>getpeername()</i>, or returned by <i>getaddrinfo()</i> in a
  <span class="Li">&quot;addr&quot;</span> field), returns the hostname and
  symbolic service name it represents. <span class="Li">$flags</span> may be a
  bitmask of <span class="Li">&quot;NI_*&quot;</span> constants, or defaults to
  0 if unspecified.
<p class="Pp">The return value will be a list; the first value being an error
    condition, followed by the hostname and service name.</p>
<p class="Pp">The error value will be a dualvar; comparable to the
    <span class="Li">&quot;EI_*&quot;</span> error constants, or printable as a
    human-readable error message string. The host and service names will be
    plain strings.</p>
<p class="Pp">The following flag constants are recognised as
    <span class="Li">$flags</span>. Other flag constants may exist as provided
    by the OS.</p>
<dl class="Bl-tag">
  <dt>NI_NUMERICHOST</dt>
  <dd>Requests that a human-readable string representation of the numeric
      address be returned directly, rather than performing a name resolve
      operation that may convert it into a hostname. This will also avoid
      potentially-blocking network IO.</dd>
  <dt>NI_NUMERICSERV</dt>
  <dd>Requests that the port number be returned directly as a number
      representation rather than performing a name resolve operation that may
      convert it into a service name.</dd>
  <dt>NI_NAMEREQD</dt>
  <dd>If a name resolve operation fails to provide a name, then this flag will
      cause <i>getnameinfo()</i> to indicate an error, rather than returning the
      numeric representation as a human-readable string.</dd>
  <dt>NI_DGRAM</dt>
  <dd>Indicates that the socket address relates to a
      <span class="Li">&quot;SOCK_DGRAM&quot;</span> socket, for the services
      whose name differs between TCP and UDP protocols.</dd>
</dl>
<p class="Pp">The following constants may be supplied as
    <span class="Li">$xflags</span>.</p>
<dl class="Bl-tag">
  <dt>NIx_NOHOST</dt>
  <dd>Indicates that the caller is not interested in the hostname of the result,
      so it does not have to be converted.
      <span class="Li">&quot;undef&quot;</span> will be returned as the
      hostname.</dd>
  <dt>NIx_NOSERV</dt>
  <dd>Indicates that the caller is not interested in the service name of the
      result, so it does not have to be converted.
      <span class="Li">&quot;undef&quot;</span> will be returned as the service
      name.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="_fIgetaddrinfo()_fP_/__fIgetnameinfo()_fP_ERROR_CONSTANTS"><a class="permalink" href="#_fIgetaddrinfo()_fP_/__fIgetnameinfo()_fP_ERROR_CONSTANTS"><i>getaddrinfo()</i>
  / <i>getnameinfo()</i> ERROR CONSTANTS</a></h1>
The following constants may be returned by <i>getaddrinfo()</i> or
  <i>getnameinfo()</i>. Others may be provided by the OS.
<dl class="Bl-tag">
  <dt>EAI_AGAIN</dt>
  <dd>A temporary failure occurred during name resolution. The operation may be
      successful if it is retried later.</dd>
  <dt>EAI_BADFLAGS</dt>
  <dd>The value of the <span class="Li">&quot;flags&quot;</span> hint to
      <i>getaddrinfo()</i>, or the <span class="Li">$flags</span> parameter to
      <i>getnameinfo()</i> contains unrecognised flags.</dd>
  <dt>EAI_FAMILY</dt>
  <dd>The <span class="Li">&quot;family&quot;</span> hint to
      <i>getaddrinfo()</i>, or the family of the socket address passed to
      <i>getnameinfo()</i> is not supported.</dd>
  <dt>EAI_NODATA</dt>
  <dd>The host name supplied to <i>getaddrinfo()</i> did not provide any usable
      address data.</dd>
  <dt>EAI_NONAME</dt>
  <dd>The host name supplied to <i>getaddrinfo()</i> does not exist, or the
      address supplied to <i>getnameinfo()</i> is not associated with a host
      name and the <span class="Li">&quot;NI_NAMEREQD&quot;</span> flag was
      supplied.</dd>
  <dt>EAI_SERVICE</dt>
  <dd>The service name supplied to <i>getaddrinfo()</i> is not available for the
      socket type given in the <span class="Li">$hints</span>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Lookup_for__fIconnect()_fP"><a class="permalink" href="#Lookup_for__fIconnect()_fP">Lookup
  for <i>connect()</i></a></h2>
The <i>getaddrinfo()</i> function converts a hostname and a service name into a
  list of structures, each containing a potential way to <i>connect()</i> to the
  named service on the named host.
<p class="Pp"><span class="Li"></span></p>
<pre>
 use IO::Socket;
 use Socket qw(SOCK_STREAM getaddrinfo);

 my %hints = (socktype =&gt; SOCK_STREAM);
 my ($err, @res) = getaddrinfo(&quot;localhost&quot;, &quot;echo&quot;, \%hints);
 die &quot;Cannot getaddrinfo - $err&quot; if $err;

 my $sock;

 foreach my $ai (@res) {
     my $candidate = IO::Socket-&gt;new();

     $candidate-&gt;socket($ai-&gt;{family}, $ai-&gt;{socktype}, $ai-&gt;{protocol})
         or next;

     $candidate-&gt;connect($ai-&gt;{addr})
         or next;

     $sock = $candidate;
     last;
 }

 die &quot;Cannot connect to localhost:echo&quot; unless $sock;

 $sock-&gt;print(&quot;Hello, world!\n&quot;);
 print &lt;$sock&gt;;
</pre>
<p class="Pp">Because a list of potential candidates is returned, the
    <span class="Li">&quot;while&quot;</span> loop tries each in turn until it
    it finds one that succeeds both the <i>socket()</i> and <i>connect()</i>
    calls.</p>
<p class="Pp">This function performs the work of the legacy functions
    <i>gethostbyname()</i>, <i>getservbyname()</i>, <i>inet_aton()</i> and
    <i>pack_sockaddr_in()</i>.</p>
<p class="Pp">In practice this logic is better performed by IO::Socket::IP.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Making_a_human-readable_string_out_of_an_address"><a class="permalink" href="#Making_a_human-readable_string_out_of_an_address">Making
  a human-readable string out of an address</a></h2>
The <i>getnameinfo()</i> function converts a socket address, such as returned by
  <i>getsockname()</i> or <i>getpeername()</i>, into a pair of human-readable
  strings representing the address and service name.
<p class="Pp"><span class="Li"></span></p>
<pre>
 use IO::Socket::IP;
 use Socket qw(getnameinfo);

 my $server = IO::Socket::IP-&gt;new(LocalPort =&gt; 12345, Listen =&gt; 1) or
     die &quot;Cannot listen - $@&quot;;

 my $socket = $server-&gt;accept or die &quot;accept: $!&quot;;

 my ($err, $hostname, $servicename) = getnameinfo($socket-&gt;peername);
 die &quot;Cannot getnameinfo - $err&quot; if $err;

 print &quot;The peer is connected from $hostname\n&quot;;
</pre>
<p class="Pp">Since in this example only the hostname was used, the redundant
    conversion of the port number into a service name may be omitted by passing
    the <span class="Li">&quot;NIx_NOSERV&quot;</span> flag.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 use Socket qw(getnameinfo NIx_NOSERV);

 my ($err, $hostname) = getnameinfo($socket-&gt;peername, 0, NIx_NOSERV);
</pre>
<p class="Pp">This function performs the work of the legacy functions
    <i>unpack_sockaddr_in()</i>, <i>inet_ntoa()</i>, <i>gethostbyaddr()</i> and
    <i>getservbyport()</i>.</p>
<p class="Pp">In practice this logic is better performed by IO::Socket::IP.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Resolving_hostnames_into__s-1IP_s0_addresses"><a class="permalink" href="#Resolving_hostnames_into__s-1IP_s0_addresses">Resolving
  hostnames into IP addresses</a></h2>
To turn a hostname into a human-readable plain IP address use
  <i>getaddrinfo()</i> to turn the hostname into a list of socket structures,
  then <i>getnameinfo()</i> on each one to make it a readable IP address again.
<p class="Pp"><span class="Li"></span></p>
<pre>
 use Socket qw(:addrinfo SOCK_RAW);

 my ($err, @res) = getaddrinfo($hostname, &quot;&quot;, {socktype =&gt; SOCK_RAW});
 die &quot;Cannot getaddrinfo - $err&quot; if $err;

 while( my $ai = shift @res ) {
     my ($err, $ipaddr) = getnameinfo($ai-&gt;{addr}, NI_NUMERICHOST, NIx_NOSERV);
     die &quot;Cannot getnameinfo - $err&quot; if $err;

     print &quot;$ipaddr\n&quot;;
 }
</pre>
<p class="Pp">The <span class="Li">&quot;socktype&quot;</span> hint to
    <i>getaddrinfo()</i> filters the results to only include one socket type and
    protocol. Without this most OSes return three combinations, for
    <span class="Li">&quot;SOCK_STREAM&quot;</span>,
    <span class="Li">&quot;SOCK_DGRAM&quot;</span> and
    <span class="Li">&quot;SOCK_RAW&quot;</span>, resulting in triplicate output
    of addresses. The <span class="Li">&quot;NI_NUMERICHOST&quot;</span> flag to
    <i>getnameinfo()</i> causes it to return a string-formatted plain IP
    address, rather than reverse resolving it back into a hostname.</p>
<p class="Pp">This combination performs the work of the legacy functions
    <i>gethostbyname()</i> and <i>inet_ntoa()</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Accessing_socket_options"><a class="permalink" href="#Accessing_socket_options">Accessing
  socket options</a></h2>
The many <span class="Li">&quot;SO_*&quot;</span> and other constants provide
  the socket option names for <i>getsockopt()</i> and <i>setsockopt()</i>.
<p class="Pp"><span class="Li"></span></p>
<pre>
 use IO::Socket::INET;
 use Socket qw(SOL_SOCKET SO_RCVBUF IPPROTO_IP IP_TTL);

 my $socket = IO::Socket::INET-&gt;new(LocalPort =&gt; 0, Proto =&gt; 'udp')
     or die &quot;Cannot create socket: $@&quot;;

 $socket-&gt;setsockopt(SOL_SOCKET, SO_RCVBUF, 64*1024) or
     die &quot;setsockopt: $!&quot;;

 print &quot;Receive buffer is &quot;, $socket-&gt;getsockopt(SOL_SOCKET, SO_RCVBUF),
     &quot; bytes\n&quot;;

 print &quot;IP TTL is &quot;, $socket-&gt;getsockopt(IPPROTO_IP, IP_TTL), &quot;\n&quot;;
</pre>
<p class="Pp">As a convenience, IO::Socket's <i>setsockopt()</i> method will
    convert a number into a packed byte buffer, and <i>getsockopt()</i> will
    unpack a byte buffer of the correct size back into a number.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
This module was originally maintained in Perl core by the Perl 5 Porters.
<p class="Pp">It was extracted to dual-life on CPAN at version 1.95 by Paul
    Evans &lt;leonerd@leonerd.org.uk&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
