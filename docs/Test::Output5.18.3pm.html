<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Test::Output(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test::Output(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Test::Output(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Test::Output - Utilities to test STDOUT and STDERR messages.
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
Version 0.16
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use Test::More tests =&gt; 4;
    use Test::Output;

    sub writer {
      print &quot;Write out.\n&quot;;
      print STDERR &quot;Error out.\n&quot;;
    }

    stdout_is(\&amp;writer,&quot;Write out.\n&quot;,'Test STDOUT');

    stderr_isnt(\&amp;writer,&quot;No error out.\n&quot;,'Test STDERR');

    combined_is(
                \&amp;writer,
                &quot;Write out.\nError out.\n&quot;,
                'Test STDOUT &amp; STDERR combined'
               );

    output_is(
              \&amp;writer,
              &quot;Write out.\n&quot;,
              &quot;Error out.\n&quot;,
              'Test STDOUT &amp; STDERR'
            );

   # Use bare blocks.

   stdout_is { print &quot;test&quot; } &quot;test&quot;, &quot;Test STDOUT&quot;;
   stderr_isnt { print &quot;bad test&quot; } &quot;test&quot;, &quot;Test STDERR&quot;;
   output_is { print 'STDOUT'; print STDERR 'STDERR' }
     &quot;STDOUT&quot;, &quot;STDERR&quot;, &quot;Test output&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Test::Output provides a simple interface for testing output sent to STDOUT or
  STDERR. A number of different utilities are included to try and be as flexible
  as possible to the tester.
<p class="Pp">Originally this module was designed not to have external
    requirements, however, the features provided by Sub::Exporter over what
    Exporter provides is just to great to pass up.</p>
<p class="Pp">Likewise, Capture::Tiny provides a much more robust capture
    mechanism without than the original Test::Output::Tie.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TESTS"><a class="permalink" href="#TESTS">TESTS</a></h1>
<section class="Ss">
<h2 class="Ss" id="_s-1STDOUT_s0"><a class="permalink" href="#_s-1STDOUT_s0">STDOUT</a></h2>
<dl class="Bl-tag">
  <dt><b>stdout_is</b></dt>
  <dd></dd>
  <dt><b>stdout_isnt</b></dt>
  <dd><span class="Li"></span>
    <pre>
   stdout_is  ( $coderef, $expected, 'description' );
   stdout_is    { ... } $expected, 'description';
   stdout_isnt( $coderef, $expected, 'description' );
   stdout_isnt  { ... } $expected, 'description';
    </pre>
    <p class="Pp"><i>stdout_is()</i> captures output sent to STDOUT from
        <span class="Li">$coderef</span> and compares it against
        <span class="Li">$expected</span>. The test passes if equal.</p>
    <p class="Pp"><i>stdout_isnt()</i> passes if STDOUT is not equal to
        <span class="Li">$expected</span>.</p>
  </dd>
  <dt><b>stdout_like</b></dt>
  <dd></dd>
  <dt><b>stdout_unlike</b></dt>
  <dd><span class="Li"></span>
    <pre>
   stdout_like  ( $coderef, qr/$expected/, 'description' );
   stdout_like    { ... } qr/$expected/, 'description';
   stdout_unlike( $coderef, qr/$expected/, 'description' );
   stdout_unlike  { ... } qr/$expected/, 'description';
    </pre>
    <p class="Pp"><i>stdout_like()</i> captures the output sent to STDOUT from
        <span class="Li">$coderef</span> and compares it to the regex in
        <span class="Li">$expected</span>. The test passes if the regex
      matches.</p>
    <p class="Pp"><i>stdout_unlike()</i> passes if STDOUT does not match the
        regex.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1STDERR_s0"><a class="permalink" href="#_s-1STDERR_s0">STDERR</a></h2>
<dl class="Bl-tag">
  <dt><b>stderr_is</b></dt>
  <dd></dd>
  <dt><b>stderr_isnt</b></dt>
  <dd><span class="Li"></span>
    <pre>
   stderr_is  ( $coderef, $expected, 'description' );
   stderr_is    {... } $expected, 'description';

   stderr_isnt( $coderef, $expected, 'description' );
   stderr_isnt  {... } $expected, 'description';
    </pre>
    <p class="Pp"><i>stderr_is()</i> is similar to stdout_is, except that it
        captures STDERR. The test passes if STDERR from
        <span class="Li">$coderef</span> equals
        <span class="Li">$expected</span>.</p>
    <p class="Pp"><i>stderr_isnt()</i> passes if STDERR is not equal to
        <span class="Li">$expected</span>.</p>
  </dd>
  <dt><b>stderr_like</b></dt>
  <dd></dd>
  <dt><b>stderr_unlike</b></dt>
  <dd><span class="Li"></span>
    <pre>
   stderr_like  ( $coderef, qr/$expected/, 'description' );
   stderr_like   { ...} qr/$expected/, 'description';
   stderr_unlike( $coderef, qr/$expected/, 'description' );
   stderr_unlike  { ...} qr/$expected/, 'description';
    </pre>
    <p class="Pp"><i>stderr_like()</i> is similar to <i>stdout_like()</i> except
        that it compares the regex <span class="Li">$expected</span> to STDERR
        captured from <span class="Li">$codref</span>. The test passes if the
        regex matches.</p>
    <p class="Pp"><i>stderr_unlike()</i> passes if STDERR does not match the
        regex.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1COMBINED_OUTPUT_s0"><a class="permalink" href="#_s-1COMBINED_OUTPUT_s0">COMBINED
  OUTPUT</a></h2>
<dl class="Bl-tag">
  <dt><b>combined_is</b></dt>
  <dd></dd>
  <dt><b>combined_isnt</b></dt>
  <dd><span class="Li"></span>
    <pre>
   combined_is   ( $coderef, $expected, 'description' );
   combined_is   {... } $expected, 'description';
   combined_isnt ( $coderef, $expected, 'description' );
   combined_isnt {... } $expected, 'description';
    </pre>
    <p class="Pp"><i>combined_is()</i> directs STDERR to STDOUT then captures
        STDOUT. This is equivalent to UNIXs 2&gt;&amp;1. The test passes if the
        combined STDOUT and STDERR from <span class="Li">$coderef</span> equals
        <span class="Li">$expected</span>.</p>
    <p class="Pp"><i>combined_isnt()</i> passes if combined STDOUT and STDERR
        are not equal to <span class="Li">$expected</span>.</p>
  </dd>
  <dt><b>combined_like</b></dt>
  <dd></dd>
  <dt><b>combined_unlike</b></dt>
  <dd><span class="Li"></span>
    <pre>
   combined_like   ( $coderef, qr/$expected/, 'description' );
   combined_like   { ...} qr/$expected/, 'description';
   combined_unlike ( $coderef, qr/$expected/, 'description' );
   combined_unlike { ...} qr/$expected/, 'description';
    </pre>
    <p class="Pp"><i>combined_like()</i> is similar to <i>combined_is()</i>
        except that it compares a regex ($expected) to STDOUT and STDERR
        captured from <span class="Li">$codref</span>. The test passes if the
        regex matches.</p>
    <p class="Pp"><i>combined_unlike()</i> passes if the combined STDOUT and
        STDERR does not match the regex.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1OUTPUT_s0"><a class="permalink" href="#_s-1OUTPUT_s0">OUTPUT</a></h2>
<dl class="Bl-tag">
  <dt><b>output_is</b></dt>
  <dd></dd>
  <dt><b>output_isnt</b></dt>
  <dd><span class="Li"></span>
    <pre>
   output_is  ( $coderef, $expected_stdout, $expected_stderr, 'description' );
   output_is    {... } $expected_stdout, $expected_stderr, 'description';
   output_isnt( $coderef, $expected_stdout, $expected_stderr, 'description' );
   output_isnt  {... } $expected_stdout, $expected_stderr, 'description';
    </pre>
    <p class="Pp">The <i>output_is()</i> function is a combination of the
        <i>stdout_is()</i> and <i>stderr_is()</i> functions. For example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  output_is(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},'foo','bar');
    </pre>
    <p class="Pp">is functionally equivalent to</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  stdout_is(sub {print &quot;foo&quot;;},'foo') 
    &amp;&amp; stderr_is(sub {print STDERR &quot;bar&quot;;'bar');
    </pre>
    <p class="Pp">except that <span class="Li">$coderef</span> is only executed
        once.</p>
    <p class="Pp">Unlike, <i>stdout_is()</i> and <i>stderr_is()</i> which ignore
        STDERR and STDOUT respectively, <i>output_is()</i> requires both STDOUT
        and STDERR to match in order to pass. Setting either
        <span class="Li">$expected_stdout</span> or
        <span class="Li">$expected_stderr</span> to
        <span class="Li">&quot;undef&quot;</span> ignores STDOUT or STDERR
        respectively.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  output_is(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},'foo',undef);
    </pre>
    <p class="Pp">is the same as</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  stdout_is(sub {print &quot;foo&quot;;},'foo')
    </pre>
    <p class="Pp"><i>output_isnt()</i> provides the opposite function of
        <i>output_is()</i>. It is a combination of <i>stdout_isnt()</i> and
        <i>stderr_isnt()</i>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  output_isnt(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},'bar','foo');
    </pre>
    <p class="Pp">is functionally equivalent to</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  stdout_is(sub {print &quot;foo&quot;;},'bar') 
    &amp;&amp; stderr_is(sub {print STDERR &quot;bar&quot;;'foo');
    </pre>
    <p class="Pp">As with <i>output_is()</i>, setting either
        <span class="Li">$expected_stdout</span> or
        <span class="Li">$expected_stderr</span> to
        <span class="Li">&quot;undef&quot;</span> ignores the output to that
        facility.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  output_isnt(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},undef,'foo');
    </pre>
    <p class="Pp">is the same as</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  stderr_is(sub {print STDERR &quot;bar&quot;;},'foo')
    </pre>
  </dd>
  <dt><b>output_like</b></dt>
  <dd></dd>
  <dt><b>output_unlike</b></dt>
  <dd><span class="Li"></span>
    <pre>
  output_like  ( $coderef, $regex_stdout, $regex_stderr, 'description' );
  output_like  { ... } $regex_stdout, $regex_stderr, 'description';
  output_unlike( $coderef, $regex_stdout, $regex_stderr, 'description' );
  output_unlike { ... } $regex_stdout, $regex_stderr, 'description';
    </pre>
    <p class="Pp"><i>output_like()</i> and <i>output_unlike()</i> follow the
        same principles as <i>output_is()</i> and <i>output_isnt()</i> except
        they use a regular expression for matching.</p>
    <p class="Pp"><i>output_like()</i> attempts to match
        <span class="Li">$regex_stdout</span> and
        <span class="Li">$regex_stderr</span> against STDOUT and STDERR produced
        by <span class="Li">$coderef</span>. The test passes if both match.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  output_like(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},qr/foo/,qr/bar/);
    </pre>
    <p class="Pp">The above test is successful.</p>
    <p class="Pp">Like <i>output_is()</i>, setting either
        <span class="Li">$regex_stdout</span> or
        <span class="Li">$regex_stderr</span> to
        <span class="Li">&quot;undef&quot;</span> ignores the output to that
        facility.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  output_like(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},qr/foo/,undef);
    </pre>
    <p class="Pp">is the same as</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  stdout_like(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},qr/foo/);
    </pre>
    <p class="Pp"><i>output_unlike()</i> test pass if output from
        <span class="Li">$coderef</span> doesn't match
        <span class="Li">$regex_stdout</span> and
        <span class="Li">$regex_stderr</span>.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
By default, all tests are exported, however with the switch to Sub::Exporter
  export groups are now available to better limit imports.
<p class="Pp">To import tests for STDOUT:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Test::Output qw(:stdout);
</pre>
<p class="Pp">To import tests STDERR:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Test::Output qw(:stderr);
</pre>
<p class="Pp">To import just the functions:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Test::Output qw(:functions);
</pre>
<p class="Pp">And to import all tests:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Test::Output;
</pre>
<p class="Pp">The following is a list of group names and which functions are
    exported:</p>
<dl class="Bl-tag">
  <dt>stdout</dt>
  <dd>stdout_is stdout_isnt stdout_like stdout_unlike</dd>
  <dt>stderr</dt>
  <dd>stderr_is stderr_isnt stderr_like stderr_unlike</dd>
  <dt>output</dt>
  <dd>output_is output_isnt output_like output_unlike</dd>
  <dt>combined</dt>
  <dd>combined_is combined_isnt combined_like combined_unlike</dd>
  <dt>tests</dt>
  <dd>All of the above, this is the default when no options are given.</dd>
</dl>
<p class="Pp">Sub::Exporter allows for many other options, I encourage reading
    its documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="stdout_from"><a class="permalink" href="#stdout_from">stdout_from</a></h2>
<span class="Li"></span>
<pre>
  my $stdout = stdout_from($coderef)
  my $stdout = stdout_from { ... };
</pre>
<p class="Pp"><i>stdout_from()</i> executes <span class="Li">$coderef</span> and
    captures STDOUT.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="stderr_from"><a class="permalink" href="#stderr_from">stderr_from</a></h2>
<span class="Li"></span>
<pre>
  my $stderr = stderr_from($coderef)
  my $stderr = stderr_from { ... };
</pre>
<p class="Pp"><i>stderr_from()</i> executes <span class="Li">$coderef</span> and
    captures STDERR.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="output_from"><a class="permalink" href="#output_from">output_from</a></h2>
<span class="Li"></span>
<pre>
  my ($stdout, $stderr) = output_from($coderef)
  my ($stdout, $stderr) = output_from {...};
</pre>
<p class="Pp"><i>output_from()</i> executes <span class="Li">$coderef</span> one
    time capturing both STDOUT and STDERR.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="combined_from"><a class="permalink" href="#combined_from">combined_from</a></h2>
<span class="Li"></span>
<pre>
  my $combined = combined_from($coderef);
  my $combined = combined_from {...};
</pre>
<p class="Pp"><i>combined_from()</i> executes <span class="Li">$coderef</span>
    one time combines STDOUT and STDERR, and captures them.
    <i>combined_from()</i> is equivalent to using 2&gt;&amp;1 in UNIX.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Currently maintained by brian d foy,
  <span class="Li">&quot;bdfoy@cpan.org&quot;</span>.
<p class="Pp">Shawn Sorichetti,
    <span class="Li">&quot;&lt;ssoriche@cpan.org&gt;&quot;</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SOURCE_AVAILABILITY"><a class="permalink" href="#SOURCE_AVAILABILITY">SOURCE
  AVAILABILITY</a></h1>
This module is in Github:
<p class="Pp"><span class="Li"></span></p>
<pre>
        http://github.com/briandfoy/test-output/tree/master
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
Please report any bugs or feature requests to
  <span class="Li">&quot;bug-test-output@rt.cpan.org&quot;</span>, or through
  the web interface at &lt;http://rt.cpan.org&gt;. I will be notified, and then
  you'll automatically be notified of progress on your bug as I make changes.
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
Thanks to chromatic whose TieOut.pm was the basis for capturing output.
<p class="Pp">Also thanks to rjbs for his help cleaning the documentation, and
    pushing me to Sub::Exporter.</p>
<p class="Pp">Thanks to David Wheeler for providing code block support and
    tests.</p>
<p class="Pp">Thanks to Michael G Schwern for the solution to combining STDOUT
    and STDERR.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_&amp;_LICENSE"><a class="permalink" href="#COPYRIGHT_&amp;_LICENSE">COPYRIGHT
  &amp; LICENSE</a></h1>
Copyright 2005-2013 Shawn Sorichetti, All Rights Reserved.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-03</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
