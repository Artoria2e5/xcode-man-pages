<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>MIME::Field::ContType(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MIME::Field::ContType(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">MIME::Field::ContType(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
MIME::Field::ContType - a &quot;Content-type&quot; field
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
A subclass of Mail::Field.
<p class="Pp"><i>Don't use this class directly... its name may change in the
    future!</i> Instead, ask Mail::Field for new instances based on the field
    name!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use Mail::Field;
    use MIME::Head;

    # Create an instance from some text:
    $field = Mail::Field-&gt;new('Content-type',
                              'text/HTML; charset=&quot;US-ASCII&quot;');

    # Get the MIME type, like 'text/plain' or 'x-foobar'.
    # Returns 'text/plain' as default, as per RFC 2045:
    my ($type, $subtype) = split('/', $field-&gt;type);

    # Get generic information:
    print $field-&gt;name;

    # Get information related to &quot;message&quot; type:
    if ($type eq 'message') {
        print $field-&gt;id;
        print $field-&gt;number;
        print $field-&gt;total;
    }

    # Get information related to &quot;multipart&quot; type:
    if ($type eq 'multipart') {
        print $field-&gt;boundary;            # the basic value, fixed up
        print $field-&gt;multipart_boundary;  # empty if not a multipart message!
    }

    # Get information related to &quot;text&quot; type:
    if ($type eq 'text') {
        print $field-&gt;charset;      # returns 'us-ascii' as default
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="PUBLIC_INTERFACE"><a class="permalink" href="#PUBLIC_INTERFACE">PUBLIC
  INTERFACE</a></h1>
<dl class="Bl-tag">
  <dt>boundary</dt>
  <dd>Return the boundary field. The boundary is returned exactly as given in
      the <span class="Li">&quot;Content-type:&quot;</span> field; that is, the
      leading double-hyphen (<span class="Li">&quot;--&quot;</span>) is
      <i>not</i> prepended.
    <p class="Pp">(Well, <i>almost</i> exactly... from RFC 2046:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   (If a boundary appears to end with white space, the white space
   must be presumed to have been added by a gateway, and must be deleted.)
    </pre>
    <p class="Pp">so we oblige and remove any trailing spaces.)</p>
    <p class="Pp">Returns the empty string if there is no boundary, or if the
        boundary is illegal (e.g., if it is empty after all trailing whitespace
        has been removed).</p>
  </dd>
  <dt>multipart_boundary</dt>
  <dd>Like <span class="Li">&quot;boundary()&quot;</span>, except that this will
      also return the empty string if the message is not a multipart message. In
      other words, there's an automatic sanity check.</dd>
  <dt>type</dt>
  <dd>Try real hard to determine the content type (e.g.,
      <span class="Li">&quot;text/plain&quot;</span>,
      <span class="Li">&quot;image/gif&quot;</span>,
      <span class="Li">&quot;x-weird-type&quot;</span>, which is returned in
      all-lowercase.
    <p class="Pp">A happy thing: the following code will work just as you would
        want, even if there's no subtype (as in
        <span class="Li">&quot;x-weird-type&quot;</span>)... in such a case, the
        <span class="Li">$subtype</span> would simply be the empty string:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    ($type, $subtype) = split('/', $head-&gt;mime_type);
    </pre>
    <p class="Pp">If the content-type information is missing, it defaults to
        <span class="Li">&quot;text/plain&quot;</span>, as per RFC 2045:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Default RFC 2822 messages are typed by this protocol as plain text in
    the US-ASCII character set, which can be explicitly specified as
    &quot;Content-type: text/plain; charset=us-ascii&quot;.  If no Content-Type is
    specified, this default is assumed.
    </pre>
    <p class="Pp"><b>Note:</b> under the &quot;be liberal in what we
        accept&quot; principle, this routine no longer syntax-checks the content
        type. If it ain't empty, just downcase and return it.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
Since nearly all (if not all) parameters must have non-empty values to be
  considered valid, we just return the empty string to signify missing fields.
  If you need to get the <i>real</i> underlying value, use the inherited
  <span class="Li">&quot;param()&quot;</span> method (which returns undef if the
  parameter is missing).
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
MIME::Field::ParamVal, Mail::Field
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Eryq (<i>eryq@zeegee.com</i>), ZeeGee Software Inc
  (<i>http://www.zeegee.com</i>). Dianne Skoll (dfs@roaringpenguin.com)
  http://www.roaringpenguin.com
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-04-05</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
