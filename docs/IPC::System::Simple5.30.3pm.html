<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>IPC::System::Simple(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IPC::System::Simple(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">IPC::System::Simple(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
IPC::System::Simple - Run commands simply, with detailed diagnostics
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use IPC::System::Simple qw(system systemx capture capturex);

  system(&quot;some_command&quot;);        # Command succeeds or dies!

  system(&quot;some_command&quot;,@args);  # Succeeds or dies, avoids shell if @args

  systemx(&quot;some_command&quot;,@args); # Succeeds or dies, NEVER uses the shell


  # Capture the output of a command (just like backticks). Dies on error.
  my $output = capture(&quot;some_command&quot;);

  # Just like backticks in list context.  Dies on error.
  my @output = capture(&quot;some_command&quot;);

  # As above, but avoids the shell if @args is non-empty
  my $output = capture(&quot;some_command&quot;, @args);

  # As above, but NEVER invokes the shell.
  my $output = capturex(&quot;some_command&quot;, @args);
  my @output = capturex(&quot;some_command&quot;, @args);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Calling Perl's in-built <span class="Li">&quot;system()&quot;</span> function is
  easy, determining if it was successful is <i>hard</i>. Let's face it,
  <span class="Li">$?</span> isn't the nicest variable in the world to play
  with, and even if you <i>do</i> check it, producing a well-formatted error
  string takes a lot of work.
<p class="Pp"><span class="Li">&quot;IPC::System::Simple&quot;</span> takes the
    hard work out of calling external commands. In fact, if you want to be
    really lazy, you can just write:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use IPC::System::Simple qw(system);
</pre>
<p class="Pp">and all of your <span class="Li">&quot;system&quot;</span>
    commands will either succeed (run to completion and return a zero exit
    value), or die with rich diagnostic messages.</p>
<p class="Pp">The <span class="Li">&quot;IPC::System::Simple&quot;</span> module
    also provides a simple replacement to Perl's backticks operator. Simply
    write:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use IPC::System::Simple qw(capture);
</pre>
<p class="Pp">and then use the &quot;<b>capture()</b>&quot; command just like
    you'd use backticks. If there's an error, it will die with a detailed
    description of what went wrong. Better still, you can even use
    <span class="Li">&quot;capturex()&quot;</span> to run the equivalent of
    backticks, but without the shell:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use IPC::System::Simple qw(capturex);

    my $result = capturex($command, @args);
</pre>
<p class="Pp">If you want more power than the basic interface, including the
    ability to specify which exit values are acceptable, trap errors, or process
    diagnostics, then read on!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ADVANCED_SYNOPSIS"><a class="permalink" href="#ADVANCED_SYNOPSIS">ADVANCED
  SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use IPC::System::Simple qw(
    capture capturex system systemx run runx $EXITVAL EXIT_ANY
  );

  # Run a command, throwing exception on failure

  run(&quot;some_command&quot;);

  runx(&quot;some_command&quot;,@args);  # Run a command, avoiding the shell

  # Do the same thing, but with the drop-in system replacement.

  system(&quot;some_command&quot;);

  systemx(&quot;some_command&quot;, @args);

  # Run a command which must return 0..5, avoid the shell, and get the
  # exit value (we could also look at $EXITVAL)

  my $exit_value = runx([0..5], &quot;some_command&quot;, @args);

  # The same, but any exit value will do.

  my $exit_value = runx(EXIT_ANY, &quot;some_command&quot;, @args);

  # Capture output into $result and throw exception on failure

  my $result = capture(&quot;some_command&quot;); 

  # Check exit value from captured command

  print &quot;some_command exited with status $EXITVAL\n&quot;;

  # Captures into @lines, splitting on $/
  my @lines = capture(&quot;some_command&quot;); 

  # Run a command which must return 0..5, capture the output into
  # @lines, and avoid the shell.

  my @lines  = capturex([0..5], &quot;some_command&quot;, @args);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="ADVANCED_USAGE"><a class="permalink" href="#ADVANCED_USAGE">ADVANCED
  USAGE</a></h1>
<section class="Ss">
<h2 class="Ss" id="_fBrun()_fP_and__fBsystem()_fP"><a class="permalink" href="#_fBrun()_fP_and__fBsystem()_fP"><b>run()</b>
  and <b>system()</b></a></h2>
<span class="Li">&quot;IPC::System::Simple&quot;</span> provides a subroutine
  called <span class="Li">&quot;run&quot;</span>, that executes a command using
  the same semantics as Perl's built-in
  <span class="Li">&quot;system&quot;</span>:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use IPC::System::Simple qw(run);

    run(&quot;cat *.txt&quot;);           # Execute command via the shell
    run(&quot;cat&quot;,&quot;/etc/motd&quot;);     # Execute command without shell
</pre>
<p class="Pp">The primary difference between Perl's in-built system and the
    <span class="Li">&quot;run&quot;</span> command is that
    <span class="Li">&quot;run&quot;</span> will throw an exception on failure,
    and allows a list of acceptable exit values to be set. See &quot;Exit
    values&quot; for further information.</p>
<p class="Pp">In fact, you can even have
    <span class="Li">&quot;IPC::System::Simple&quot;</span> replace the default
    <span class="Li">&quot;system&quot;</span> function for your package so it
    has the same behaviour:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use IPC::System::Simple qw(system);

    system(&quot;cat *.txt&quot;);  # system now succeeds or dies!
</pre>
<p class="Pp"><span class="Li">&quot;system&quot;</span> and
    <span class="Li">&quot;run&quot;</span> are aliases to each other.</p>
<p class="Pp">See also &quot;<b>runx()</b>, <b>systemx()</b> and
    <b>capturex()</b>&quot; for variants of
    <span class="Li">&quot;system()&quot;</span> and
    <span class="Li">&quot;run()&quot;</span> that never invoke the shell, even
    with a single argument.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBcapture()_fP"><a class="permalink" href="#_fBcapture()_fP"><b>capture()</b></a></h2>
A second subroutine, named <span class="Li">&quot;capture&quot;</span> executes
  a command with the same semantics as Perl's built-in backticks (and
  <span class="Li">&quot;qx()&quot;</span>):
<p class="Pp"><span class="Li"></span></p>
<pre>
    use IPC::System::Simple qw(capture);

    # Capture text while invoking the shell.
    my $file  = capture(&quot;cat /etc/motd&quot;);
    my @lines = capture(&quot;cat /etc/passwd&quot;);
</pre>
<p class="Pp">However unlike regular backticks, which always use the shell,
    <span class="Li">&quot;capture&quot;</span> will bypass the shell when
    called with multiple arguments:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    # Capture text while avoiding the shell.
    my $file  = capture(&quot;cat&quot;, &quot;/etc/motd&quot;);
    my @lines = capture(&quot;cat&quot;, &quot;/etc/passwd&quot;);
</pre>
<p class="Pp">See also &quot;<b>runx()</b>, <b>systemx()</b> and
    <b>capturex()</b>&quot; for a variant of
    <span class="Li">&quot;capture()&quot;</span> that never invokes the shell,
    even with a single argument.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBrunx()_fP,__fBsystemx()_fP_and__fBcapturex()_fP"><a class="permalink" href="#_fBrunx()_fP,__fBsystemx()_fP_and__fBcapturex()_fP"><b>runx()</b>,
  <b>systemx()</b> and <b>capturex()</b></a></h2>
The <span class="Li">&quot;runx()&quot;</span>,
  <span class="Li">&quot;systemx()&quot;</span> and
  <span class="Li">&quot;capturex()&quot;</span> commands are identical to the
  multi-argument forms of <span class="Li">&quot;run()&quot;</span>,
  <span class="Li">&quot;system()&quot;</span> and
  <span class="Li">&quot;capture()&quot;</span> respectively, but <i>never</i>
  invoke the shell, even when called with a single argument. These forms are
  particularly useful when a command's argument list <i>might</i> be empty, for
  example:
<p class="Pp"><span class="Li"></span></p>
<pre>
    systemx($cmd, @args);
</pre>
<p class="Pp">The use of <span class="Li">&quot;systemx()&quot;</span> here
    guarantees that the shell will <i>never</i> be invoked, even if
    <span class="Li">@args</span> is empty.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Exception_handling"><a class="permalink" href="#Exception_handling">Exception
  handling</a></h2>
In the case where the command returns an unexpected status, both
  <span class="Li">&quot;run&quot;</span> and
  <span class="Li">&quot;capture&quot;</span> will throw an exception, which if
  not caught will terminate your program with an error.
<p class="Pp">Capturing the exception is easy:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    eval {
        run(&quot;cat *.txt&quot;);
    };

    if ($@) {
        print &quot;Something went wrong - $@\n&quot;;
    }
</pre>
<p class="Pp">See the diagnostics section below for more details.</p>
<p class="Pp"><i>Exception cases</i></p>
<p class="Pp"><span class="Li">&quot;IPC::System::Simple&quot;</span> considers
    the following to be unexpected, and worthy of exception:</p>
<ul class="Bl-bullet">
  <li>Failing to start entirely (eg, command not found, permission denied).</li>
  <li>Returning an exit value other than zero (but see below).</li>
  <li>Being killed by a signal.</li>
  <li>Being passed tainted data (in taint mode).</li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="Exit_values"><a class="permalink" href="#Exit_values">Exit
  values</a></h2>
Traditionally, system commands return a zero status for success and a non-zero
  status for failure. <span class="Li">&quot;IPC::System::Simple&quot;</span>
  will default to throwing an exception if a non-zero exit value is returned.
<p class="Pp">You may specify a range of values which are considered acceptable
    exit values by passing an <i>array reference</i> as the first argument. The
    special constant <span class="Li">&quot;EXIT_ANY&quot;</span> can be used to
    allow <i>any</i> exit value to be returned.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use IPC::System::Simple qw(run system capture EXIT_ANY);

        run( [0..5], &quot;cat *.txt&quot;);             # Exit values 0-5 are OK

        system( [0..5], &quot;cat *.txt&quot;);          # This works the same way

        my @lines = capture( EXIT_ANY, &quot;cat *.txt&quot;); # Any exit is fine.
</pre>
<p class="Pp">The <span class="Li">&quot;run&quot;</span> and replacement
    <span class="Li">&quot;system&quot;</span> subroutines returns the exit
    value of the process:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        my $exit_value = run( [0..5], &quot;cat *.txt&quot;);

        # OR:

        my $exit_value = system( [0..5] &quot;cat *.txt&quot;);

        print &quot;Program exited with value $exit_value\n&quot;;
</pre>
<p class="Pp"><i></i><i>$EXITVAL</i><i></i></p>
<p class="Pp">The exit value of any command executed by
    <span class="Li">&quot;IPC::System::Simple&quot;</span> can always be
    retrieved from the <span class="Li">$IPC::System::Simple::EXITVAL</span>
    variable:</p>
<p class="Pp">This is particularly useful when inspecting results from
    <span class="Li">&quot;capture&quot;</span>, which returns the captured text
    from the command.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use IPC::System::Simple qw(capture $EXITVAL EXIT_ANY);

        my @enemies_defeated = capture(EXIT_ANY, &quot;defeat_evil&quot;, &quot;/dev/mordor&quot;);

        print &quot;Program exited with value $EXITVAL\n&quot;;
</pre>
<p class="Pp"><span class="Li">$EXITVAL</span> will be set to
    <span class="Li">&quot;-1&quot;</span> if the command did not exit normally
    (eg, being terminated by a signal) or did not start. In this situation an
    exception will also be thrown.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="WINDOWS-SPECIFIC__s-1NOTES_s0"><a class="permalink" href="#WINDOWS-SPECIFIC__s-1NOTES_s0">WINDOWS-SPECIFIC
  NOTES</a></h2>
The <span class="Li">&quot;run&quot;</span> subroutine make available the full
  32-bit exit value on Win32 systems. This has been true since
  <span class="Li">&quot;IPC::System::Simple&quot;</span> v0.06 when called with
  multiple arguments, and since v1.25 when called with a single argument. This
  is different from the previous versions of
  <span class="Li">&quot;IPC::System::Simple&quot;</span> and from Perl's
  in-build <span class="Li">&quot;system()&quot;</span> function, which can only
  handle 8-bit return values.
<p class="Pp">The <span class="Li">&quot;capture&quot;</span> subroutine always
    returns the 32-bit exit value under Windows. The
    <span class="Li">&quot;capture&quot;</span> subroutine also never uses the
    shell, even when passed a single argument.</p>
<p class="Pp">The <span class="Li">&quot;run&quot;</span> subroutine always uses
    a shell when passed a single argument. On NT systems, it uses
    <span class="Li">&quot;cmd.exe&quot;</span> in the system root, and on
    non-NT systems it uses <span class="Li">&quot;command.com&quot;</span> in
    the system root.</p>
<p class="Pp">As of <span class="Li">&quot;IPC::System::Simple&quot;</span>
    v1.25, the <span class="Li">&quot;runx&quot;</span> and
    <span class="Li">&quot;capturex&quot;</span> subroutines, as well as
    multiple-argument calls to the <span class="Li">&quot;run&quot;</span> and
    <span class="Li">&quot;capture&quot;</span> subroutines, have their
    arguments properly quoted, so that arugments with spaces and the like work
    properly. Unfortunately, this breaks any attempt to invoke the shell itself.
    If you really need to execute <span class="Li">&quot;cmd.exe&quot;</span> or
    <span class="Li">&quot;command.com&quot;</span>, use the single-argument
    form. For single-argument calls to <span class="Li">&quot;run&quot;</span>
    and <span class="Li">&quot;capture&quot;</span>, the argument must be
    properly shell-quoted in advance of the call.</p>
<p class="Pp">Versions of
    <span class="Li">&quot;IPC::System::Simple&quot;</span> before v0.09 would
    not search the <span class="Li">&quot;PATH&quot;</span> environment variable
    when the multi-argument form of <span class="Li">&quot;run()&quot;</span>
    was called. Versions from v0.09 onwards correctly search the path provided
    the command is provided including the extension (eg,
    <span class="Li">&quot;notepad.exe&quot;</span> rather than just
    <span class="Li">&quot;notepad&quot;</span>, or
    <span class="Li">&quot;gvim.bat&quot;</span> rather than just
    <span class="Li">&quot;gvim&quot;</span>). If no extension is provided,
    <span class="Li">&quot;.exe&quot;</span> is assumed.</p>
<p class="Pp">Signals are not supported on Windows systems. Sending a signal to
    a Windows process will usually cause it to exit with the signal number
  used.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DIAGNOSTICS"><a class="permalink" href="#DIAGNOSTICS">DIAGNOSTICS</a></h1>
<dl class="Bl-tag">
  <dt>&quot;%s&quot; failed to start: &quot;%s&quot;</dt>
  <dd>The command specified did not even start. It may not exist, or you may not
      have permission to use it. The reason it could not start (as determined
      from <span class="Li">$!</span>) will be provided.</dd>
  <dt>&quot;%s&quot; unexpectedly returned exit value %d</dt>
  <dd>The command ran successfully, but returned an exit value we did not
      expect. The value returned is reported.</dd>
  <dt>&quot;%s&quot; died to signal &quot;%s&quot; (%d) %s</dt>
  <dd>The command was killed by a signal. The name of the signal will be
      reported, or <span class="Li">&quot;UNKNOWN&quot;</span> if it cannot be
      determined. The signal number is always reported. If we detected that the
      process dumped core, then the string <span class="Li">&quot;and dumped
      core&quot;</span> is appended.</dd>
  <dt>IPC::System::Simple::%s called with no arguments</dt>
  <dd>You attempted to call <span class="Li">&quot;run&quot;</span> or
      <span class="Li">&quot;capture&quot;</span> but did not provide any
      arguments at all. At the very lease you need to supply a command to
    run.</dd>
  <dt>IPC::System::Simple::%s called with no command</dt>
  <dd>You called <span class="Li">&quot;run&quot;</span> or
      <span class="Li">&quot;capture&quot;</span> with a list of acceptable exit
      values, but no actual command.</dd>
  <dt>IPC::System::Simple::%s called with tainted argument &quot;%s&quot;</dt>
  <dd>You called <span class="Li">&quot;run&quot;</span> or
      <span class="Li">&quot;capture&quot;</span> with tainted (untrusted)
      arguments, which is almost certainly a bad idea. To untaint your arguments
      you'll need to pass your data through a regular expression and use the
      resulting match variables. See &quot;Laundering and Detecting Tainted
      Data&quot; in perlsec for more information.</dd>
  <dt>IPC::System::Simple::%s called with tainted environment $ENV{%s}</dt>
  <dd>You called <span class="Li">&quot;run&quot;</span> or
      <span class="Li">&quot;capture&quot;</span> but part of your environment
      was tainted (untrusted). You should either delete the named environment
      variable before calling <span class="Li">&quot;run&quot;</span>, or set it
      to an untainted value (usually one set inside your program). See
      &quot;Cleaning Up Your Path&quot; in perlsec for more information.</dd>
  <dt>Error in IPC::System::Simple plumbing: &quot;%s&quot; -
    &quot;%s&quot;</dt>
  <dd>Implementing the <span class="Li">&quot;capture&quot;</span> command
      involves dark and terrible magicks involving pipes, and one of them has
      sprung a leak. This could be due to a lack of file descriptors, although
      there are other possibilities.
    <p class="Pp">If you are able to reproduce this error, you are encouraged to
        submit a bug report according to the &quot;Reporting bugs&quot; section
        below.</p>
  </dd>
  <dt>Internal error in IPC::System::Simple: &quot;%s&quot;</dt>
  <dd>You've found a bug in
      <span class="Li">&quot;IPC::System::Simple&quot;</span>. Please check to
      see if an updated version of
      <span class="Li">&quot;IPC::System::Simple&quot;</span> is available. If
      not, please file a bug report according to the &quot;Reporting bugs&quot;
      section below.</dd>
  <dt>IPC::System::Simple::%s called with undefined command</dt>
  <dd>You've passed the undefined value as a command to be executed. While this
      is a very Zen-like action, it's not supported by Perl's current
      implementation.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="DEPENDENCIES"><a class="permalink" href="#DEPENDENCIES">DEPENDENCIES</a></h1>
This module depends upon Win32::Process when used on Win32 system.
  <span class="Li">&quot;Win32::Process&quot;</span> is bundled as a core module
  in ActivePerl 5.6 and above.
<p class="Pp">There are no non-core dependencies on non-Win32 systems.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COMPARISON_TO_OTHER_APIs"><a class="permalink" href="#COMPARISON_TO_OTHER_APIs">COMPARISON
  TO OTHER APIs</a></h1>
Perl provides a range of in-built functions for handling external commands, and
  CPAN provides even more. The
  <span class="Li">&quot;IPC::System::Simple&quot;</span> differentiates itself
  from other options by providing:
<dl class="Bl-tag">
  <dt>Extremely detailed diagnostics</dt>
  <dd>The diagnostics produced by
      <span class="Li">&quot;IPC::System::Simple&quot;</span> are designed to
      provide as much information as possible. Rather than requiring the
      developer to inspect <span class="Li">$?</span>,
      <span class="Li">&quot;IPC::System::Simple&quot;</span> does the hard work
      for you.
    <p class="Pp">If an odd exit status is provided, you're informed of what it
        is. If a signal kills your process, you are informed of both its name
        and number. If tainted data or environment prevents your command from
        running, you are informed of exactly which data or environmental
        variable is tainted.</p>
  </dd>
  <dt>Exceptions on failure</dt>
  <dd><span class="Li">&quot;IPC::System::Simple&quot;</span> takes an
      aggressive approach to error handling. Rather than allow commands to fail
      silently, exceptions are thrown when unexpected results are seen. This
      allows for easy development using a try/catch style, and avoids the
      possibility of accidentally continuing after a failed command.</dd>
  <dt>Easy access to exit status</dt>
  <dd>The <span class="Li">&quot;run&quot;</span>,
      <span class="Li">&quot;system&quot;</span> and
      <span class="Li">&quot;capture&quot;</span> commands all set
      <span class="Li">$EXITVAL</span>, making it easy to determine the exit
      status of a command. Additionally, the
      <span class="Li">&quot;system&quot;</span> and
      <span class="Li">&quot;run&quot;</span> interfaces return the exit
    status.</dd>
  <dt>Consistent interfaces</dt>
  <dd>When called with multiple arguments, the
      <span class="Li">&quot;run&quot;</span>,
      <span class="Li">&quot;system&quot;</span> and
      <span class="Li">&quot;capture&quot;</span> interfaces <i>never</i> invoke
      the shell. This differs from the in-built Perl
      <span class="Li">&quot;system&quot;</span> command which may invoke the
      shell under Windows when called with multiple arguments. It differs from
      the in-built Perl backticks operator which always invokes the shell.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
When <span class="Li">&quot;system&quot;</span> is exported, the exotic form
  <span class="Li">&quot;system { $cmd } @args&quot;</span> is not supported.
  Attemping to use the exotic form is a syntax error. This affects the calling
  package <i>only</i>. Use <span class="Li">&quot;CORE::system&quot;</span> if
  you need it, or consider using the autodie module to replace
  <span class="Li">&quot;system&quot;</span> with lexical scope.
<p class="Pp">Core dumps are only checked for when a process dies due to a
    signal. It is not believed there are any systems where processes can dump
    core without dying to a signal.</p>
<p class="Pp"><span class="Li">&quot;WIFSTOPPED&quot;</span> status is not
    checked, as perl never spawns processes with the
    <span class="Li">&quot;WUNTRACED&quot;</span> option.</p>
<p class="Pp">Signals are not supported under Win32 systems, since they don't
    work at all like Unix signals. Win32 signals cause commands to exit with a
    given exit value, which this modules <i>does</i> capture.</p>
<section class="Ss">
<h2 class="Ss" id="Reporting_bugs"><a class="permalink" href="#Reporting_bugs">Reporting
  bugs</a></h2>
Before reporting a bug, please check to ensure you are using the most recent
  version of <span class="Li">&quot;IPC::System::Simple&quot;</span>. Your
  problem may have already been fixed in a new release.
<p class="Pp">You can find the
    <span class="Li">&quot;IPC::System::Simple&quot;</span> bug-tracker at
    &lt;http://rt.cpan.org/Public/Dist/Display.html?Name=IPC-System-Simple&gt; .
    Please check to see if your bug has already been reported; if in doubt,
    report yours anyway.</p>
<p class="Pp">Submitting a patch and/or failing test case will greatly expedite
    the fixing of bugs.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="FEEDBACK"><a class="permalink" href="#FEEDBACK">FEEDBACK</a></h1>
If you find this module useful, please consider rating it on the CPAN Ratings
  service at
  &lt;http://cpanratings.perl.org/rate/?distribution=IPC-System-Simple&gt; .
<p class="Pp">The module author loves to hear how
    <span class="Li">&quot;IPC::System::Simple&quot;</span> has made your life
    better (or worse). Feedback can be sent to
  &lt;pjf@perltraining.com.au&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
autodie uses <span class="Li">&quot;IPC::System::Simple&quot;</span> to provide
  succeed-or-die replacements to <span class="Li">&quot;system&quot;</span> (and
  other built-ins) with lexical scope.
<p class="Pp">POSIX, IPC::Run::Simple, perlipc, perlport, IPC::Run, IPC::Run3,
    Win32::Process</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Paul Fenwick &lt;pjf@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
Copyright (C) 2006-2008 by Paul Fenwick
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself, either Perl version 5.6.0 or,
    at your option, any later version of Perl 5 you may have available.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-03-24</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
