<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Pegex::Overview(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Pegex::Overview(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Pegex::Overview(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="What_is_Pegex?"><a class="permalink" href="#What_is_Pegex?">What
  is Pegex?</a></h1>
Pegex is a Friendly, Acmeist, PEG Parser framework. Friendly means that it is
  simple to create, understand, modify and maintain Pegex parsers. Acmeist means
  that the parsers will work automatically in many programming languages (as
  long as they have some kind of traditional &quot;regex&quot; support). PEG
  (Parser Expression Grammars) is the new style of Recursive-Descent/BNF style
  grammar definition syntax.
<p class="Pp">The name &quot;Pegex&quot; comes from PEG + Regex. With Pegex you
    define top down grammars that eventually break down to regex fragments. ie
    The low level parsing matches are always done with regexes against the
    current position in the input stream.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="What_is_Parsing?"><a class="permalink" href="#What_is_Parsing?">What
  is Parsing?</a></h1>
It may seem like a silly question, but it's important to have an understanding
  of what parsing is and what a parser can do for you. At the the most basic
  level &quot;parsing&quot; is the act of reading through an input, making sense
  of it, and possibly doing something with what is found.
<p class="Pp">Usually a parser gets its instructions of what means what from
    something called a grammar. A grammar is a set of rules that defines how the
    input must be structured. In many parsing methodologies, input is
    preprocessed (possibly into tokens) before the parser/grammar get to look at
    it. Although this is a common method, it is not the only approach.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="How_Pegex_Works"><a class="permalink" href="#How_Pegex_Works">How
  Pegex Works</a></h1>
Pegex parsing consists of 4 distinct parts or objects:
<dl class="Bl-tag">
  <dt>Parser</dt>
  <dd>The Pegex parsing engine</dd>
  <dt>Grammar</dt>
  <dd>The rules of a particular syntax</dd>
  <dt>Receiver</dt>
  <dd>The logic for processing matches</dd>
  <dt>Input</dt>
  <dd>Text conforming to the grammar rules</dd>
</dl>
<p class="Pp">Quite simply, a parser object is created with a grammar object and
    a receiver object. Then the parser object's
    <span class="Li">&quot;parse()&quot;</span> method is called on an input
    object. The parser applies the rules of the grammar to the input and invokes
    methods of the receiver as the rules match. The parse is either successful
    or results in an error. The result is whatever the receiver object decides
    it should be.</p>
<p class="Pp">For example consider a parser that turns the Markdown text
    language into HTML. The Pegex code to use this might look like this:</p>
<p class="Pp">In the simplest terms, Pegex works like this (pseudocode):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    parser = new Pegex.Parser(
        grammar: new Markdown.Grammar
        receiver: new Markdown.Receiver.HTML
    )
    html = parser.parse(markdown)
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="See_Also"><a class="permalink" href="#See_Also">See
  Also</a></h1>
<ul class="Bl-bullet">
  <li>Pegex::API</li>
  <li>Pegex::Syntax</li>
  <li>Pegex::Tutorial</li>
</ul>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-02-13</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
