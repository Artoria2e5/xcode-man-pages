<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>mro(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">mro(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">mro(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
mro - Method Resolution Order
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use mro; # enables next::method and friends globally

  use mro 'dfs'; # enable DFS MRO for this class (Perl default)
  use mro 'c3'; # enable C3 MRO for this class
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The &quot;mro&quot; namespace provides several utilities for dealing with method
  resolution order and method caching in general.
<p class="Pp">These interfaces are only available in Perl 5.9.5 and higher. See
    MRO::Compat on CPAN for a mostly forwards compatible implementation for
    older Perls.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OVERVIEW"><a class="permalink" href="#OVERVIEW">OVERVIEW</a></h1>
It's possible to change the MRO of a given class either by using
  <span class="Li">&quot;use</span> <span class="Li">mro&quot;</span> as shown
  in the synopsis, or by using the &quot;mro::set_mro&quot; function below.
<p class="Pp">The special methods
    <span class="Li">&quot;next::method&quot;</span>,
    <span class="Li">&quot;next::can&quot;</span>, and
    <span class="Li">&quot;maybe::next::method&quot;</span> are not available
    until this <span class="Li">&quot;mro&quot;</span> module has been loaded
    via <span class="Li">&quot;use&quot;</span> or
    <span class="Li">&quot;require&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="The_C3_MRO"><a class="permalink" href="#The_C3_MRO">The C3
  MRO</a></h1>
In addition to the traditional Perl default MRO (depth first search, called
  <span class="Li">&quot;DFS&quot;</span> here), Perl now offers the C3 MRO as
  well. Perl's support for C3 is based on the work done in Stevan Little's
  module Class::C3, and most of the C3-related documentation here is ripped
  directly from there.
<section class="Ss">
<h2 class="Ss" id="What_is_C3?"><a class="permalink" href="#What_is_C3?">What is
  C3?</a></h2>
C3 is the name of an algorithm which aims to provide a sane method resolution
  order under multiple inheritance. It was first introduced in the language
  Dylan (see links in the &quot;SEE ALSO&quot; section), and then later adopted
  as the preferred MRO (Method Resolution Order) for the new-style classes in
  Python 2.3. Most recently it has been adopted as the &quot;canonical&quot; MRO
  for Perl 6 classes, and the default MRO for Parrot objects as well.
</section>
<section class="Ss">
<h2 class="Ss" id="How_does_C3_work"><a class="permalink" href="#How_does_C3_work">How
  does C3 work</a></h2>
C3 works by always preserving local precedence ordering. This essentially means
  that no class will appear before any of its subclasses. Take, for instance,
  the classic diamond inheritance pattern:
<p class="Pp"><span class="Li"></span></p>
<pre>
     &lt;A&gt;
    /   \
  &lt;B&gt;   &lt;C&gt;
    \   /
     &lt;D&gt;
</pre>
<p class="Pp">The standard Perl 5 MRO would be (D, B, A, C). The result being
    that <b>A</b> appears before <b>C</b>, even though <b>C</b> is the subclass
    of <b>A</b>. The C3 MRO algorithm however, produces the following order: (D,
    B, C, A), which does not have this issue.</p>
<p class="Pp">This example is fairly trivial; for more complex cases and a
    deeper explanation, see the links in the &quot;SEE ALSO&quot; section.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Functions"><a class="permalink" href="#Functions">Functions</a></h1>
<section class="Ss">
<h2 class="Ss" id="mro::get_linear_isa($classname_,_$type_)"><a class="permalink" href="#mro::get_linear_isa($classname_,_$type_)">mro::get_linear_isa($classname[,
  $type])</a></h2>
Returns an arrayref which is the linearized MRO of the given class. Uses
  whichever MRO is currently in effect for that class by default, or the given
  MRO (either <span class="Li">&quot;c3&quot;</span> or
  <span class="Li">&quot;dfs&quot;</span> if specified as
  <span class="Li">$type</span>).
<p class="Pp">The linearized MRO of a class is an ordered array of all of the
    classes one would search when resolving a method on that class, starting
    with the class itself.</p>
<p class="Pp">If the requested class doesn't yet exist, this function will still
    succeed, and return <span class="Li">&quot;[ $classname ]&quot;</span></p>
<p class="Pp">Note that <span class="Li">&quot;UNIVERSAL&quot;</span> (and any
    members of <span class="Li">&quot;UNIVERSAL&quot;</span>'s MRO) are not part
    of the MRO of a class, even though all classes implicitly inherit methods
    from <span class="Li">&quot;UNIVERSAL&quot;</span> and its parents.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mro::set_mro_($classname,_$type)"><a class="permalink" href="#mro::set_mro_($classname,_$type)">mro::set_mro
  ($classname, $type)</a></h2>
Sets the MRO of the given class to the <span class="Li">$type</span> argument
  (either <span class="Li">&quot;c3&quot;</span> or
  <span class="Li">&quot;dfs&quot;</span>).
</section>
<section class="Ss">
<h2 class="Ss" id="mro::get_mro($classname)"><a class="permalink" href="#mro::get_mro($classname)">mro::get_mro($classname)</a></h2>
Returns the MRO of the given class (either
  <span class="Li">&quot;c3&quot;</span> or
  <span class="Li">&quot;dfs&quot;</span>).
</section>
<section class="Ss">
<h2 class="Ss" id="mro::get_isarev($classname)"><a class="permalink" href="#mro::get_isarev($classname)">mro::get_isarev($classname)</a></h2>
Gets the <span class="Li">&quot;mro_isarev&quot;</span> for this class, returned
  as an arrayref of class names. These are every class that &quot;isa&quot; the
  given class name, even if the isa relationship is indirect. This is used
  internally by the MRO code to keep track of method/MRO cache invalidations.
<p class="Pp">As with <span class="Li">&quot;mro::get_linear_isa&quot;</span>
    above, <span class="Li">&quot;UNIVERSAL&quot;</span> is special.
    <span class="Li">&quot;UNIVERSAL&quot;</span> (and parents') isarev lists do
    not include every class in existence, even though all classes are
    effectively descendants for method inheritance purposes.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mro::is_universal($classname)"><a class="permalink" href="#mro::is_universal($classname)">mro::is_universal($classname)</a></h2>
Returns a boolean status indicating whether or not the given classname is either
  <span class="Li">&quot;UNIVERSAL&quot;</span> itself, or one of
  <span class="Li">&quot;UNIVERSAL&quot;</span>'s parents by
  <span class="Li">@ISA</span> inheritance.
<p class="Pp">Any class for which this function returns true is
    &quot;universal&quot; in the sense that all classes potentially inherit
    methods from it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBmro::invalidate_all_method_caches()_fP"><a class="permalink" href="#_fBmro::invalidate_all_method_caches()_fP"><b>mro::invalidate_all_method_caches()</b></a></h2>
Increments <span class="Li">&quot;PL_sub_generation&quot;</span>, which
  invalidates method caching in all packages.
</section>
<section class="Ss">
<h2 class="Ss" id="mro::method_changed_in($classname)"><a class="permalink" href="#mro::method_changed_in($classname)">mro::method_changed_in($classname)</a></h2>
Invalidates the method cache of any classes dependent on the given class. This
  is not normally necessary. The only known case where pure perl code can
  confuse the method cache is when you manually install a new constant
  subroutine by using a readonly scalar value, like the internals of constant
  do. If you find another case, please report it so we can either fix it or
  document the exception here.
</section>
<section class="Ss">
<h2 class="Ss" id="mro::get_pkg_gen($classname)"><a class="permalink" href="#mro::get_pkg_gen($classname)">mro::get_pkg_gen($classname)</a></h2>
Returns an integer which is incremented every time a real local method in the
  package <span class="Li">$classname</span> changes, or the local
  <span class="Li">@ISA</span> of <span class="Li">$classname</span> is
  modified.
<p class="Pp">This is intended for authors of modules which do lots of class
    introspection, as it allows them to very quickly check if anything important
    about the local properties of a given class have changed since the last time
    they looked. It does not increment on method/<span class="Li">@ISA</span>
    changes in superclasses.</p>
<p class="Pp">It's still up to you to seek out the actual changes, and there
    might not actually be any. Perhaps all of the changes since you last checked
    cancelled each other out and left the package in the state it was in
  before.</p>
<p class="Pp">This integer normally starts off at a value of
    <span class="Li">1</span> when a package stash is instantiated. Calling it
    on packages whose stashes do not exist at all will return
    <span class="Li">0</span>. If a package stash is completely deleted (not a
    normal occurrence, but it can happen if someone does something like
    <span class="Li">&quot;undef %PkgName::&quot;</span>), the number will be
    reset to either <span class="Li">0</span> or <span class="Li">1</span>,
    depending on how completely the package was wiped out.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="next::method"><a class="permalink" href="#next::method">next::method</a></h2>
This is somewhat like <span class="Li">&quot;SUPER&quot;</span>, but it uses the
  C3 method resolution order to get better consistency in multiple inheritance
  situations. Note that while inheritance in general follows whichever MRO is in
  effect for the given class, <span class="Li">&quot;next::method&quot;</span>
  only uses the C3 MRO.
<p class="Pp">One generally uses it like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub some_method {
    my $self = shift;
    my $superclass_answer = $self-&gt;next::method(@_);
    return $superclass_answer + 1;
  }
</pre>
<p class="Pp">Note that you don't (re-)specify the method name. It forces you to
    always use the same method name as the method you started in.</p>
<p class="Pp">It can be called on an object or a class, of course.</p>
<p class="Pp">The way it resolves which actual method to call is:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>First, it determines the linearized C3 MRO of the object or class it is
      being called on.</dd>
  <dt>2.</dt>
  <dd>Then, it determines the class and method name of the context it was
      invoked from.</dd>
  <dt>3.</dt>
  <dd>Finally, it searches down the C3 MRO list until it reaches the
      contextually enclosing class, then searches further down the MRO list for
      the next method with the same name as the contextually enclosing
    method.</dd>
</dl>
<p class="Pp">Failure to find a next method will result in an exception being
    thrown (see below for alternatives).</p>
<p class="Pp">This is substantially different than the behavior of
    <span class="Li">&quot;SUPER&quot;</span> under complex multiple
    inheritance. (This becomes obvious when one realizes that the common
    superclasses in the C3 linearizations of a given class and one of its
    parents will not always be ordered the same for both.)</p>
<p class="Pp"><b>Caveat</b>: Calling
    <span class="Li">&quot;next::method&quot;</span> from methods defined
    outside the class:</p>
<p class="Pp">There is an edge case when using
    <span class="Li">&quot;next::method&quot;</span> from within a subroutine
    which was created in a different module than the one it is called from. It
    sounds complicated, but it really isn't. Here is an example which will not
    work correctly:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  *Foo::foo = sub { (shift)-&gt;next::method(@_) };
</pre>
<p class="Pp">The problem exists because the anonymous subroutine being assigned
    to the <span class="Li">*Foo::foo</span> glob will show up in the call stack
    as being called <span class="Li">&quot;__ANON__&quot;</span> and not
    <span class="Li">&quot;foo&quot;</span> as you might expect. Since
    <span class="Li">&quot;next::method&quot;</span> uses
    <span class="Li">&quot;caller&quot;</span> to find the name of the method it
    was called in, it will fail in this case.</p>
<p class="Pp">But fear not, there's a simple solution. The module
    <span class="Li">&quot;Sub::Name&quot;</span> will reach into the perl
    internals and assign a name to an anonymous subroutine for you. Simply do
    this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Sub::Name 'subname';
  *Foo::foo = subname 'Foo::foo' =&gt; sub { (shift)-&gt;next::method(@_) };
</pre>
<p class="Pp">and things will Just Work.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="next::can"><a class="permalink" href="#next::can">next::can</a></h2>
This is similar to <span class="Li">&quot;next::method&quot;</span>, but just
  returns either a code reference or <span class="Li">&quot;undef&quot;</span>
  to indicate that no further methods of this name exist.
</section>
<section class="Ss">
<h2 class="Ss" id="maybe::next::method"><a class="permalink" href="#maybe::next::method">maybe::next::method</a></h2>
In simple cases, it is equivalent to:
<p class="Pp"><span class="Li"></span></p>
<pre>
   $self-&gt;next::method(@_) if $self-&gt;next::can;
</pre>
<p class="Pp">But there are some cases where only this solution works (like
    <span class="Li">&quot;goto &amp;maybe::next::method&quot;</span>);</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<section class="Ss">
<h2 class="Ss" id="The_original_Dylan_paper"><a class="permalink" href="#The_original_Dylan_paper">The
  original Dylan paper</a></h2>
<dl class="Bl-tag">
  <dt>&lt;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.19.3910&amp;rep=rep1&amp;type=pdf&gt;</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Pugs"><a class="permalink" href="#Pugs">Pugs</a></h2>
The Pugs prototype Perl 6 Object Model uses C3
</section>
<section class="Ss">
<h2 class="Ss" id="Parrot"><a class="permalink" href="#Parrot">Parrot</a></h2>
Parrot now uses C3
<dl class="Bl-tag">
  <dt>&lt;http://use.perl.org/~autrijus/journal/25768&gt;</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Python_2.3__s-1MRO_s0_related_links"><a class="permalink" href="#Python_2.3__s-1MRO_s0_related_links">Python
  2.3 MRO related links</a></h2>
<dl class="Bl-tag">
  <dt>&lt;http://www.python.org/2.3/mro.html&gt;</dt>
  <dd></dd>
  <dt>&lt;http://www.python.org/2.2.2/descrintro.html#mro&gt;</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Class::C3"><a class="permalink" href="#Class::C3">Class::C3</a></h2>
<dl class="Bl-tag">
  <dt>Class::C3</dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Brandon L. Black, &lt;blblack@gmail.com&gt;
<p class="Pp">Based on Stevan Little's Class::C3</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-11-01</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
