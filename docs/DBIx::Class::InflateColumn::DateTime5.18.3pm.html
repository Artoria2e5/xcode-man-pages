<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>DBIx::Class::InflateColumn::DateTime(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::InflateColumn::DateTime(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::InflateColumn::DateTime(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
DBIx::Class::InflateColumn::DateTime - Auto-create DateTime objects from date
  and datetime columns.
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
Load this component and then declare one or more columns to be of the datetime,
  timestamp or date datatype.
<p class="Pp"><span class="Li"></span></p>
<pre>
  package Event;
  use base 'DBIx::Class::Core';

  __PACKAGE__-&gt;load_components(qw/InflateColumn::DateTime/);
  __PACKAGE__-&gt;add_columns(
    starts_when =&gt; { data_type =&gt; 'datetime' }
    create_date =&gt; { data_type =&gt; 'date' }
  );
</pre>
<p class="Pp">Then you can treat the specified column as a DateTime object.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  print &quot;This event starts the month of &quot;.
    $event-&gt;starts_when-&gt;month_name();
</pre>
<p class="Pp">If you want to set a specific timezone and locale for that field,
    use:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  __PACKAGE__-&gt;add_columns(
    starts_when =&gt; { data_type =&gt; 'datetime', timezone =&gt; &quot;America/Chicago&quot;, locale =&gt; &quot;de_DE&quot; }
  );
</pre>
<p class="Pp">If you want to inflate no matter what data_type your column is,
    use inflate_datetime or inflate_date:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  __PACKAGE__-&gt;add_columns(
    starts_when =&gt; { data_type =&gt; 'varchar', inflate_datetime =&gt; 1 }
  );

  __PACKAGE__-&gt;add_columns(
    starts_when =&gt; { data_type =&gt; 'varchar', inflate_date =&gt; 1 }
  );
</pre>
<p class="Pp">It's also possible to explicitly skip inflation:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  __PACKAGE__-&gt;add_columns(
    starts_when =&gt; { data_type =&gt; 'datetime', inflate_datetime =&gt; 0 }
  );
</pre>
<p class="Pp">NOTE: Don't rely on
    <span class="Li">&quot;InflateColumn::DateTime&quot;</span> to parse date
    strings for you. The column is set directly for any non-references and
    <span class="Li">&quot;InflateColumn::DateTime&quot;</span> is completely
    bypassed. Instead, use an input parser to create a DateTime object. For
    instance, if your user input comes as a 'YYYY-MM-DD' string, you can use
    <span class="Li">&quot;DateTime::Format::ISO8601&quot;</span> thusly:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use DateTime::Format::ISO8601;
  my $dt = DateTime::Format::ISO8601-&gt;parse_datetime('YYYY-MM-DD');
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module figures out the type of DateTime::Format::* class to inflate/deflate
  with based on the type of DBIx::Class::Storage::DBI::* that you are using. If
  you switch from one database to a different one your code should continue to
  work without modification (though note that this feature is new as of 0.07, so
  it may not be perfect yet - bug reports to the list very much welcome).
<p class="Pp">If the data_type of a field is
    <span class="Li">&quot;date&quot;</span>,
    <span class="Li">&quot;datetime&quot;</span> or
    <span class="Li">&quot;timestamp&quot;</span> (or a derivative of these
    datatypes, e.g. <span class="Li">&quot;timestamp with
    timezone&quot;</span>), this module will automatically call the appropriate
    parse/format method for deflation/inflation as defined in the storage class.
    For instance, for a <span class="Li">&quot;datetime&quot;</span> field the
    methods <span class="Li">&quot;parse_datetime&quot;</span> and
    <span class="Li">&quot;format_datetime&quot;</span> would be called on
    deflation/inflation. If the storage class does not provide a specialized
    inflator/deflator,
    <span class="Li">&quot;[parse|format]_datetime&quot;</span> will be used as
    a fallback. See DateTime::Format for more information on date
  formatting.</p>
<p class="Pp">For more help with using components, see &quot;USING&quot; in
    DBIx::Class::Manual::Component.</p>
<section class="Ss">
<h2 class="Ss" id="register_column"><a class="permalink" href="#register_column">register_column</a></h2>
Chains with the &quot;register_column&quot; in DBIx::Class::Row method, and sets
  up datetime columns appropriately. This would not normally be directly called
  by end users.
<p class="Pp">In the case of an invalid date, DateTime will throw an exception.
    To bypass these exceptions and just have the inflation return undef, use the
    <span class="Li">&quot;datetime_undef_if_invalid&quot;</span> option in the
    column info:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    &quot;broken_date&quot;,
    {
        data_type =&gt; &quot;datetime&quot;,
        default_value =&gt; '0000-00-00',
        is_nullable =&gt; 1,
        datetime_undef_if_invalid =&gt; 1
    }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="USAGE_NOTES"><a class="permalink" href="#USAGE_NOTES">USAGE
  NOTES</a></h1>
If you have a datetime column with an associated
  <span class="Li">&quot;timezone&quot;</span>, and subsequently create/update
  this column with a DateTime object in the DateTime::TimeZone::Floating
  timezone, you will get a warning (as there is a very good chance this will not
  have the result you expect). For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
  __PACKAGE__-&gt;add_columns(
    starts_when =&gt; { data_type =&gt; 'datetime', timezone =&gt; &quot;America/Chicago&quot; }
  );

  my $event = $schema-&gt;resultset('EventTZ')-&gt;create({
    starts_at =&gt; DateTime-&gt;new(year=&gt;2007, month=&gt;12, day=&gt;31, ),
  });
</pre>
<p class="Pp">The warning can be avoided in several ways:</p>
<dl class="Bl-tag">
  <dt>Fix your broken code</dt>
  <dd>When calling <span class="Li">&quot;set_time_zone&quot;</span> on a
      Floating DateTime object, the timezone is simply set to the requested
      value, and <b>no time conversion takes place</b>. It is always a good idea
      to be supply explicit times to the database:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $event = $schema-&gt;resultset('EventTZ')-&gt;create({
    starts_at =&gt; DateTime-&gt;new(year=&gt;2007, month=&gt;12, day=&gt;31, time_zone =&gt; &quot;America/Chicago&quot; ),
  });
    </pre>
  </dd>
  <dt>Suppress the check on per-column basis</dt>
  <dd><span class="Li"></span>
    <pre>
  __PACKAGE__-&gt;add_columns(
    starts_when =&gt; { data_type =&gt; 'datetime', timezone =&gt; &quot;America/Chicago&quot;, floating_tz_ok =&gt; 1 }
  );
    </pre>
  </dd>
  <dt>Suppress the check globally</dt>
  <dd>Set the environment variable DBIC_FLOATING_TZ_OK to some true value.</dd>
</dl>
<p class="Pp">Putting extra attributes like timezone, locale or floating_tz_ok
    into extra =&gt; {} has been <b>DEPRECATED</b> because this gets you into
    trouble using DBIx::Class::Schema::Versioned. Instead put it directly into
    the columns definition like in the examples above. If you still use the old
    way you'll see a warning - please fix your code then!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<dl class="Bl-tag">
  <dt>More information about the add_columns method, and column metadata, can be
    found in the documentation for DBIx::Class::ResultSource.</dt>
  <dd></dd>
  <dt>Further discussion of problems inherent to the Floating timezone: Floating
    DateTimes and $dt-&gt;set_time_zone</dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Matt S. Trout &lt;mst@shadowcatsystems.co.uk&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="INHERITED_METHODS"><a class="permalink" href="#INHERITED_METHODS">INHERITED
  METHODS</a></h1>
<dl class="Bl-tag">
  <dt>DBIx::Class::InflateColumn</dt>
  <dd>get_inflated_column, inflate_column, set_inflated_column,
      store_inflated_column</dd>
  <dt>DBIx::Class::Row</dt>
  <dd>copy, delete, discard_changes, get_column, get_columns, get_dirty_columns,
      get_from_storage, get_inflated_columns, has_column_loaded, in_storage,
      inflate_result, insert, insert_or_update, is_changed, is_column_changed,
      make_column_dirty, new, result_source, set_column, set_columns,
      set_inflated_columns, store_column, throw_exception, update,
      update_or_insert</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="CONTRIBUTORS"><a class="permalink" href="#CONTRIBUTORS">CONTRIBUTORS</a></h1>
Aran Deltac &lt;bluefeet@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
You may distribute this code under the same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
