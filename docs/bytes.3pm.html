<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>bytes(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">bytes(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">bytes(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
bytes - Perl pragma to expose the individual bytes of characters
</section>
<section class="Sh">
<h1 class="Sh" id="NOTICE"><a class="permalink" href="#NOTICE">NOTICE</a></h1>
Because the bytes pragma breaks encapsulation (i.e. it exposes the innards of
  how the perl executable currently happens to store a string), the byte values
  that result are in an unspecified encoding.
<p class="Pp"><b>Use of this module for anything other than debugging purposes
    is</b> <b>strongly discouraged.</b> If you feel that the functions here
    within might be useful for your application, this possibly indicates a
    mismatch between your mental model of Perl Unicode and the current reality.
    In that case, you may wish to read some of the perl Unicode documentation:
    perluniintro, perlunitut, perlunifaq and perlunicode.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use bytes;
    ... chr(...);       # or bytes::chr
    ... index(...);     # or bytes::index
    ... length(...);    # or bytes::length
    ... ord(...);       # or bytes::ord
    ... rindex(...);    # or bytes::rindex
    ... substr(...);    # or bytes::substr
    no bytes;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Perl's characters are stored internally as sequences of one or more bytes. This
  pragma allows for the examination of the individual bytes that together
  comprise a character.
<p class="Pp">Originally the pragma was designed for the loftier goal of helping
    incorporate Unicode into Perl, but the approach that used it was found to be
    defective, and the one remaining legitimate use is for debugging when you
    need to non-destructively examine characters' individual bytes. Just insert
    this pragma temporarily, and remove it after the debugging is finished.</p>
<p class="Pp">The original usage can be accomplished by explicit (rather than
    this pragma's implict) encoding using the Encode module:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Encode qw/encode/;

    my $utf8_byte_string   = encode &quot;UTF8&quot;,   $string;
    my $latin1_byte_string = encode &quot;Latin1&quot;, $string;
</pre>
<p class="Pp">Or, if performance is needed and you are only interested in the
    UTF-8 representation:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    utf8::encode(my $utf8_byte_string = $string);
</pre>
<p class="Pp"><span class="Li">&quot;no bytes&quot;</span> can be used to
    reverse the effect of <span class="Li">&quot;use bytes&quot;</span> within
    the current lexical scope.</p>
<p class="Pp">As an example, when Perl sees <span class="Li">&quot;$x =
    chr(400)&quot;</span>, it encodes the character in UTF-8 and stores it in
    <span class="Li">$x</span>. Then it is marked as character data, so, for
    instance, <span class="Li">&quot;length $x&quot;</span> returns
    <span class="Li">1</span>. However, in the scope of the
    <span class="Li">&quot;bytes&quot;</span> pragma, <span class="Li">$x</span>
    is treated as a series of bytes - the bytes that make up the UTF8 encoding -
    and <span class="Li">&quot;length $x&quot;</span> returns
    <span class="Li">2</span>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 $x = chr(400);
 print &quot;Length is &quot;, length $x, &quot;\n&quot;;     # &quot;Length is 1&quot;
 printf &quot;Contents are %vd\n&quot;, $x;         # &quot;Contents are 400&quot;
 {
     use bytes; # or &quot;require bytes; bytes::length()&quot;
     print &quot;Length is &quot;, length $x, &quot;\n&quot;; # &quot;Length is 2&quot;
     printf &quot;Contents are %vd\n&quot;, $x;     # &quot;Contents are 198.144 (on
                                          # ASCII platforms)&quot;
 }
</pre>
<p class="Pp"><span class="Li">&quot;chr()&quot;</span>,
    <span class="Li">&quot;ord()&quot;</span>,
    <span class="Li">&quot;substr()&quot;</span>,
    <span class="Li">&quot;index()&quot;</span> and
    <span class="Li">&quot;rindex()&quot;</span> behave similarly.</p>
<p class="Pp">For more on the implications, see perluniintro and
  perlunicode.</p>
<p class="Pp"><span class="Li">&quot;bytes::length()&quot;</span> is admittedly
    handy if you need to know the <b>byte length</b> of a Perl scalar. But a
    more modern way is:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   use Encode 'encode';
   length(encode('UTF-8', $scalar))
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="LIMITATIONS"><a class="permalink" href="#LIMITATIONS">LIMITATIONS</a></h1>
<span class="Li">&quot;bytes::substr()&quot;</span> does not work as an
  <i></i><b><i>lvalue()</i></b><i></i>.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perluniintro, perlunicode, utf8, Encode
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-11-01</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
