<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>C(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">C(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">C(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Inline::C - Write Perl Subroutines in C
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<span class="Li">&quot;Inline::C&quot;</span> is a module that allows you to
  write Perl subroutines in C. Since version 0.30 the Inline module supports
  multiple programming languages and each language has its own support module.
  This document describes how to use Inline with the C programming language. It
  also goes a bit into Perl C internals.
<p class="Pp">If you want to start working with programming examples right away,
    check out Inline::C-Cookbook. For more information on Inline in general, see
    Inline.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Usage"><a class="permalink" href="#Usage">Usage</a></h1>
You never actually use <span class="Li">&quot;Inline::C&quot;</span> directly.
  It is just a support module for using
  <span class="Li">&quot;Inline.pm&quot;</span> with C. So the usage is always:
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Inline C =&gt; ...;
</pre>
<p class="Pp">or</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    bind Inline C =&gt; ...;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Function_Definitions"><a class="permalink" href="#Function_Definitions">Function
  Definitions</a></h1>
The Inline grammar for C recognizes certain function definitions (or signatures)
  in your C code. If a signature is recognized by Inline, then it will be
  available in Perl-space. That is, Inline will generate the &quot;glue&quot;
  necessary to call that function as if it were a Perl subroutine. If the
  signature is not recognized, Inline will simply ignore it, with no complaints.
  It will not be available from Perl-space, although it <i>will</i> be available
  from C-space.
<p class="Pp">Inline looks for ANSI/prototype style function definitions. They
    must be of the form:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    return-type function-name ( type-name-pairs ) { ... }
</pre>
<p class="Pp">The most common types are:
    <span class="Li">&quot;int&quot;</span>,
    <span class="Li">&quot;long&quot;</span>,
    <span class="Li">&quot;double&quot;</span>,
    <span class="Li">&quot;char*&quot;</span>, and
    <span class="Li">&quot;SV*&quot;</span>. But you can use any type for which
    Inline can find a typemap. Inline uses the
    <span class="Li">&quot;typemap&quot;</span> file distributed with Perl as
    the default. You can specify more typemaps with the TYPEMAPS configuration
    option.</p>
<p class="Pp">A return type of <span class="Li">&quot;void&quot;</span> may also
    be used. The following are examples of valid function definitions.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    int Foo(double num, char* str) {
    void Foo(double num, char* str) {
    void Foo(SV*, ...) {
    long Foo(int i, int j, ...) {
    SV* Foo(void) { # 'void' arg invalid with the ParseRecDescent parser.
                    # Works only with the ParseRegExp parser.
                    # See the section on USING (below).
    SV* Foo() {  # Alternative to specifying 'void' arg. Is valid with
                 # both the ParseRecDescent and ParseRegExp parsers.
</pre>
<p class="Pp">The following definitions would not be recognized:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    Foo(int i) {               # no return type
    int Foo(float f) {         # no (default) typemap for float
    int Foo(num, str) double num; char* str; {
</pre>
<p class="Pp">Notice that Inline only looks for function <i>definitions</i>, not
    function <i>prototypes</i>. Definitions are the syntax directly preceding a
    function body. Also Inline does not scan external files, like headers. Only
    the code passed to Inline is used to create bindings; although other
    libraries can linked in, and called from C-space.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="C_Configuration_Options"><a class="permalink" href="#C_Configuration_Options">C
  Configuration Options</a></h1>
For information on how to specify Inline configuration options, see Inline. This
  section describes each of the configuration options available for C. Most of
  the options correspond either to MakeMaker or XS options of the same name. See
  ExtUtils::MakeMaker and perlxs.
<section class="Ss">
<h2 class="Ss" id="_s-1AUTO_INCLUDE_s0"><a class="permalink" href="#_s-1AUTO_INCLUDE_s0">AUTO_INCLUDE</a></h2>
Specifies extra statements to automatically included. They will be added onto
  the defaults. A newline char will be automatically added.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Inline C =&gt; Config =&gt; AUTO_INCLUDE =&gt; '#include &quot;yourheader.h&quot;';
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1AUTOWRAP_s0"><a class="permalink" href="#_s-1AUTOWRAP_s0">AUTOWRAP</a></h2>
If you 'ENABLE =&gt; AUTOWRAP', Inline::C will parse function declarations
  (prototype statements) in your C code. For each declaration it can bind to, it
  will create a dummy wrapper that will call the real function which may be in
  an external library. This is a nice convenience for functions that would
  otherwise just require an empty wrapper function.
<p class="Pp">This is similar to the base functionality you get from
    <span class="Li">&quot;h2xs&quot;</span>. It can be very useful for binding
    to external libraries.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1BOOT_s0"><a class="permalink" href="#_s-1BOOT_s0">BOOT</a></h2>
Specifies C code to be executed in the XS BOOT section. Corresponds to the XS
  parameter.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1CC_s0"><a class="permalink" href="#_s-1CC_s0">CC</a></h2>
Specify which compiler to use.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1CCFLAGS_s0"><a class="permalink" href="#_s-1CCFLAGS_s0">CCFLAGS</a></h2>
Specify compiler flags - same as ExtUtils::MakeMaker's CCFLAGS option. Whatever
  gets specified here replaces the default
  <span class="Li">$Config</span>{ccflags}. Often, you'll want to add an extra
  flag or two without clobbering the default flags in which case you could
  instead use CCFLAGSEX (see below) or, iff Config.pm has already been loaded:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Inline C =&gt; Config =&gt; CCFLAGS =&gt; $Config{ccflags} . &quot; -DXTRA -DTOO&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1CCFLAGSEX_s0"><a class="permalink" href="#_s-1CCFLAGSEX_s0">CCFLAGSEX</a></h2>
Extend compiler flags. Sets CCFLAGS to <span class="Li">$Config</span>{ccflags}
  followed by a space, followed by the specified value:
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Inline C =&gt; Config =&gt; CCFLAGSEX =&gt; &quot;-DXTRA -DTOO&quot;;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1FILTERS_s0"><a class="permalink" href="#_s-1FILTERS_s0">FILTERS</a></h2>
Allows you to specify a list of source code filters. If more than one is
  requested, be sure to group them with an array ref. The filters can either be
  subroutine references or names of filters provided by the supplementary
  Inline::Filters module.
<p class="Pp">Your source code will be filtered just before it is parsed by
    Inline. The MD5 fingerprint is generated before filtering. Source code
    filters can be used to do things like stripping out POD documentation,
    pre-expanding #include statements or whatever else you please. For
  example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Inline C =&gt; DATA =&gt;
               FILTERS =&gt; [Strip_POD =&gt; \&amp;MyFilter =&gt; Preprocess ];
</pre>
<p class="Pp">Filters are invoked in the order specified. See Inline::Filters
    for more information.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1INC_s0"><a class="permalink" href="#_s-1INC_s0">INC</a></h2>
Specifies an include path to use. Corresponds to the MakeMaker parameter.
  Expects a fully qualified path.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Inline C =&gt; Config =&gt; INC =&gt; '-I/inc/path';
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1LD_s0"><a class="permalink" href="#_s-1LD_s0">LD</a></h2>
Specify which linker to use.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1LDDLFLAGS_s0"><a class="permalink" href="#_s-1LDDLFLAGS_s0">LDDLFLAGS</a></h2>
Specify which linker flags to use.
<p class="Pp">NOTE: These flags will completely override the existing flags,
    instead of just adding to them. So if you need to use those too, you must
    respecify them here.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1LIBS_s0"><a class="permalink" href="#_s-1LIBS_s0">LIBS</a></h2>
Specifies external libraries that should be linked into your code. Corresponds
  to the MakeMaker parameter. Provide a fully qualified path with the -L switch
  if the library is in a location where it won't be found automatically.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Inline C =&gt; Config =&gt; LIBS =&gt; '-lyourlib';
</pre>
<p class="Pp">or</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Inline C =&gt; Config =&gt; LIBS =&gt; '-L/your/path -lyourlib';
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1MAKE_s0"><a class="permalink" href="#_s-1MAKE_s0">MAKE</a></h2>
Specify the name of the 'make' utility to use.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1MYEXTLIB_s0"><a class="permalink" href="#_s-1MYEXTLIB_s0">MYEXTLIB</a></h2>
Specifies a user compiled object that should be linked in. Corresponds to the
  MakeMaker parameter. Expects a fully qualified path.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Inline C =&gt; Config =&gt; MYEXTLIB =&gt; '/your/path/yourmodule.so';
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1OPTIMIZE_s0"><a class="permalink" href="#_s-1OPTIMIZE_s0">OPTIMIZE</a></h2>
This controls the MakeMaker OPTIMIZE setting. By setting this value to
  <span class="Li">'-g'</span>, you can turn on debugging support for your
  Inline extensions. This will allow you to be able to set breakpoints in your C
  code using a debugger like gdb.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1PREFIX_s0"><a class="permalink" href="#_s-1PREFIX_s0">PREFIX</a></h2>
Specifies a prefix that will be automatically stripped from C functions when
  they are bound to Perl. Useful for creating wrappers for shared library API-s,
  and binding to the original names in Perl. Also useful when names conflict
  with Perl internals. Corresponds to the XS parameter.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Inline C =&gt; Config =&gt; PREFIX =&gt; 'ZLIB_';
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1PRE_HEAD_s0"><a class="permalink" href="#_s-1PRE_HEAD_s0">PRE_HEAD</a></h2>
Specifies code that will precede the inclusion of all files specified in
  AUTO_INCLUDE (ie EXTERN.h, perl.h, XSUB.h, INLINE.h and anything else that
  might have been added to AUTO_INCLUDE by the user). If the specified value
  identifies a file, the contents of that file will be inserted, otherwise the
  specified value is inserted.
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Inline C =&gt; Config =&gt; PRE_HEAD =&gt; $code_or_filename;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1TYPEMAPS_s0"><a class="permalink" href="#_s-1TYPEMAPS_s0">TYPEMAPS</a></h2>
Specifies extra typemap files to use. These types will modify the behaviour of
  the C parsing. Corresponds to the MakeMaker parameter. Specify either a fully
  qualified path or a path relative to the cwd (ie relative to what the cwd is
  at the time the script is loaded).
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Inline C =&gt; Config =&gt; TYPEMAPS =&gt; '/your/path/typemap';
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1USING_s0"><a class="permalink" href="#_s-1USING_s0">USING</a></h2>
Specifies which parser to use. Default is 'ParseRecDescent', which uses the
  Parse::RecDescent module. The only other option is 'ParseRegExp', which uses
  the Inline::C::ParseRegExp module that ships with Inline.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Inline C =&gt; Config =&gt; USING =&gt; 'ParseRegExp';
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="C_-Perl_Bindings"><a class="permalink" href="#C_-Perl_Bindings">C-Perl
  Bindings</a></h1>
This section describes how the <span class="Li">&quot;Perl&quot;</span>
  variables get mapped to <span class="Li">&quot;C&quot;</span> variables and
  back again.
<p class="Pp">First, you need to know how
    <span class="Li">&quot;Perl&quot;</span> passes arguments back and forth to
    subroutines. Basically it uses a stack (also known as the <b>Stack</b>).
    When a sub is called, all of the parenthesized arguments get expanded into a
    list of scalars and pushed onto the <b>Stack</b>. The subroutine then pops
    all of its parameters off of the <b>Stack</b>. When the sub is done, it
    pushes all of its return values back onto the <b>Stack</b>.</p>
<p class="Pp">The <b>Stack</b> is an array of scalars known internally as
    <span class="Li">&quot;SV&quot;</span>'s. The <b>Stack</b> is actually an
    array of <b>pointers to SV</b> or <span class="Li">&quot;SV*&quot;</span>;
    therefore every element of the <b>Stack</b> is natively a
    <span class="Li">&quot;SV*&quot;</span>. For <i>FMTYEWTK</i> about this,
    read <span class="Li">&quot;perldoc perlguts&quot;</span>.</p>
<p class="Pp">So back to variable mapping. XS uses a thing known as
    &quot;typemaps&quot; to turn each <span class="Li">&quot;SV*&quot;</span>
    into a <span class="Li">&quot;C&quot;</span> type and back again. This is
    done through various XS macro calls, casts and the Perl API. See
    <span class="Li">&quot;perldoc perlapi&quot;</span>. XS allows you to define
    your own typemaps as well for fancier non-standard types such as
    <span class="Li">&quot;typedef&quot;</span>-ed structs.</p>
<p class="Pp">Inline uses the default Perl typemap file for its default types.
    This file is called
    <span class="Li">&quot;/usr/local/lib/perl5/5.6.1/ExtUtils/typemap&quot;</span>,
    or something similar, depending on your Perl installation. It has
    definitions for over 40 types, which are automatically used by Inline. (You
    should probably browse this file at least once, just to get an idea of the
    possibilities.)</p>
<p class="Pp">Inline parses your code for these types and generates the XS code
    to map them. The most commonly used types are:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 - int
 - long
 - double
 - char*
 - void
 - SV*
</pre>
<p class="Pp">If you need to deal with a type that is not in the defaults, just
    use the generic <span class="Li">&quot;SV*&quot;</span> type in the function
    definition. Then inside your code, do the mapping yourself. Alternatively,
    you can create your own typemap files and specify them using the
    <span class="Li">&quot;TYPEMAPS&quot;</span> configuration option.</p>
<p class="Pp">A return type of <span class="Li">&quot;void&quot;</span> has a
    special meaning to Inline. It means that you plan to push the values back
    onto the <b>Stack</b> yourself. This is what you need to do to return a list
    of values. If you really don't want to return anything (the traditional
    meaning of <span class="Li">&quot;void&quot;</span>) then simply don't push
    anything back.</p>
<p class="Pp">If ellipsis or <span class="Li">&quot;...&quot;</span> is used at
    the end of an argument list, it means that any number of
    <span class="Li">&quot;SV*&quot;</span>s may follow. Again you will need to
    pop the values off of the <span class="Li">&quot;Stack&quot;</span>
    yourself.</p>
<p class="Pp">See &quot;Examples&quot; below.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="The_Inline_Stack_Macros"><a class="permalink" href="#The_Inline_Stack_Macros">The
  Inline Stack Macros</a></h1>
When you write Inline C, the following lines are automatically prepended to your
  code (by default):
<p class="Pp"><span class="Li"></span></p>
<pre>
    #include &quot;EXTERN.h&quot;
    #include &quot;perl.h&quot;
    #include &quot;XSUB.h&quot;
    #include &quot;INLINE.h&quot;
</pre>
<p class="Pp">The file <span class="Li">&quot;INLINE.h&quot;</span> defines a
    set of macros that are useful for handling the Perl Stack from your C
    functions.</p>
<dl class="Bl-tag">
  <dt>Inline_Stack_Vars</dt>
  <dd>You'll need to use this one, if you want to use the others. It sets up a
      few local variables: <span class="Li">&quot;sp&quot;</span>,
      <span class="Li">&quot;items&quot;</span>,
      <span class="Li">&quot;ax&quot;</span> and
      <span class="Li">&quot;mark&quot;</span>, for use by the other macros.
      It's not important to know what they do, but I mention them to avoid
      possible name conflicts.
    <p class="Pp">NOTE: Since this macro declares variables, you'll need to put
        it with your other variable declarations at the top of your function. It
        must come before any executable statements and before any other
        <span class="Li">&quot;Inline_Stack&quot;</span> macros.</p>
  </dd>
  <dt>Inline_Stack_Items</dt>
  <dd>Returns the number of arguments passed in on the Stack.</dd>
  <dt>Inline_Stack_Item(i)</dt>
  <dd>Refers to a particular <span class="Li">&quot;SV*&quot;</span> in the
      Stack, where <span class="Li">&quot;i&quot;</span> is an index number
      starting from zero. Can be used to get or set the value.</dd>
  <dt>Inline_Stack_Reset</dt>
  <dd>Use this before pushing anything back onto the Stack. It resets the
      internal Stack pointer to the beginning of the Stack.</dd>
  <dt>Inline_Stack_Push(sv)</dt>
  <dd>Push a return value back onto the Stack. The value must be of type
      <span class="Li">&quot;SV*&quot;</span>.</dd>
  <dt>Inline_Stack_Done</dt>
  <dd>After you have pushed all of your return values, you must call this
    macro.</dd>
  <dt>Inline_Stack_Return(n)</dt>
  <dd>Return <span class="Li">&quot;n&quot;</span> items on the Stack.</dd>
  <dt>Inline_Stack_Void</dt>
  <dd>A special macro to indicate that you really don't want to return anything.
      Same as:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    Inline_Stack_Return(0);
    </pre>
    <p class="Pp">Please note that this macro actually <b>returns</b> from your
        function.</p>
  </dd>
</dl>
<p class="Pp">Each of these macros is available in 3 different styles to suit
    your coding tastes. The following macros are equivalent.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    Inline_Stack_Vars
    inline_stack_vars
    INLINE_STACK_VARS
</pre>
<p class="Pp">All of this functionality is available through XS macro calls as
    well. So why duplicate the functionality? There are a few reasons why I
    decided to offer this set of macros. First, as a convenient way to access
    the Stack. Second, for consistent, self documenting, non-cryptic coding.
    Third, for future compatibility. It occured to me that if a lot of people
    started using XS macros for their C code, the interface might break under
    Perl6. By using this set, hopefully I will be able to insure future
    compatibility of argument handling.</p>
<p class="Pp">Of course, if you use the rest of the Perl API, your code will
    most likely break under Perl6. So this is not a 100% guarantee. But since
    argument handling is the most common interface you're likely to use, it
    seemed like a wise thing to do.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Writing_C_Subroutines"><a class="permalink" href="#Writing_C_Subroutines">Writing
  C Subroutines</a></h1>
The definitions of your C functions will fall into one of the following four
  categories. For each category there are special considerations.
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd><span class="Li"></span>
    <pre>
    int Foo(int arg1, char* arg2, SV* arg3) {
    </pre>
    <p class="Pp">This is the simplest case. You have a non
        <span class="Li">&quot;void&quot;</span> return type and a fixed length
        argument list. You don't need to worry about much. All the conversions
        will happen automatically.</p>
  </dd>
  <dt>2.</dt>
  <dd><span class="Li"></span>
    <pre>
    void Foo(int arg1, char* arg2, SV* arg3) {
    </pre>
    <p class="Pp">In this category you have a
        <span class="Li">&quot;void&quot;</span> return type. This means that
        either you want to return nothing, or that you want to return a list. In
        the latter case you'll need to push values onto the <b>Stack</b>
        yourself. There are a few Inline macros that make this easy. Code
        something like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    int i, max; SV* my_sv[10];
    Inline_Stack_Vars;
    Inline_Stack_Reset;
    for (i = 0; i &lt; max; i++)
      Inline_Stack_Push(my_sv[i]);
    Inline_Stack_Done;
    </pre>
    <p class="Pp">After resetting the Stack pointer, this code pushes a series
        of return values. At the end it uses
        <span class="Li">&quot;Inline_Stack_Done&quot;</span> to mark the end of
        the return stack.</p>
    <p class="Pp">If you really want to return nothing, then don't use the
        <span class="Li">&quot;Inline_Stack_&quot;</span> macros. If you must
        use them, then set use
        <span class="Li">&quot;Inline_Stack_Void&quot;</span> at the end of your
        function.</p>
  </dd>
  <dt>3.</dt>
  <dd><span class="Li"></span>
    <pre>
    char* Foo(SV* arg1, ...) {
    </pre>
    <p class="Pp">In this category you have an unfixed number of arguments. This
        means that you'll have to pop values off the <b>Stack</b> yourself. Do
        it like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    int i;
    Inline_Stack_Vars;
    for (i = 0; i &lt; Inline_Stack_Items; i++)
      handle_sv(Inline_Stack_Item(i));
    </pre>
    <p class="Pp">The return type of
        <span class="Li">Inline_Stack_Item(i)</span> is
        <span class="Li">&quot;SV*&quot;</span>.</p>
  </dd>
  <dt>4.</dt>
  <dd><span class="Li"></span>
    <pre>
    void* Foo(SV* arg1, ...) {
    </pre>
    <p class="Pp">In this category you have both a
        <span class="Li">&quot;void&quot;</span> return type and an unfixed
        number of arguments. Just combine the techniques from Categories 3 and
        4.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Examples"><a class="permalink" href="#Examples">Examples</a></h1>
Here are a few examples. Each one is a complete program that you can try running
  yourself. For many more examples see Inline::C-Cookbook.
<section class="Ss">
<h2 class="Ss" id="Example__1__-_Greetings"><a class="permalink" href="#Example__1__-_Greetings">Example
  #1 - Greetings</a></h2>
This example will take one string argument (a name) and print a greeting. The
  function is called with a string and with a number. In the second case the
  number is forced to a string.
<p class="Pp">Notice that you do not need to <span class="Li">&quot;#include
    &lt;stdio.h&quot;</span>&gt;. The <span class="Li">&quot;perl.h&quot;</span>
    header file which gets included by default, automatically loads the standard
    C header files for you.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Inline C;
    greet('Ingy');
    greet(42);
    __END__
    __C__
    void greet(char* name) {
      printf(&quot;Hello %s!\n&quot;, name);
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Example__2__-_and_Salutations"><a class="permalink" href="#Example__2__-_and_Salutations">Example
  #2 - and Salutations</a></h2>
This is similar to the last example except that the name is passed in as a
  <span class="Li">&quot;SV*&quot;</span> (pointer to Scalar Value) rather than
  a string (<span class="Li">&quot;char*&quot;</span>). That means we need to
  convert the <span class="Li">&quot;SV&quot;</span> to a string ourselves. This
  is accomplished using the <span class="Li">&quot;SvPVX&quot;</span> function
  which is part of the <span class="Li">&quot;Perl&quot;</span> internal API.
  See <span class="Li">&quot;perldoc perlapi&quot;</span> for more info.
<p class="Pp">One problem is that <span class="Li">&quot;SvPVX&quot;</span>
    doesn't automatically convert strings to numbers, so we get a little
    surprise when we try to greet <span class="Li">42</span>. The program
    segfaults, a common occurence when delving into the guts of Perl.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Inline C;
    greet('Ingy');
    greet(42);
    __END__
    __C__
    void greet(SV* sv_name) {
      printf(&quot;Hello %s!\n&quot;, SvPVX(sv_name));
    }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Example__3__-_Fixing_the_problem"><a class="permalink" href="#Example__3__-_Fixing_the_problem">Example
  #3 - Fixing the problem</a></h2>
We can fix the problem in Example #2 by using the
  <span class="Li">&quot;SvPV&quot;</span> function instead. This function will
  stringify the <span class="Li">&quot;SV&quot;</span> if it does not contain a
  string. <span class="Li">&quot;SvPV&quot;</span> returns the length of the
  string as it's second parameter. Since we don't care about the length, we can
  just put <span class="Li">&quot;PL_na&quot;</span> there, which is a special
  variable designed for that purpose.
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Inline C;
    greet('Ingy');
    greet(42);
    __END__
    __C__
    void greet(SV* sv_name) {
      printf(&quot;Hello %s!\n&quot;, SvPV(sv_name, PL_na));
    }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
For general information about Inline see Inline.
<p class="Pp">For sample programs using Inline with C see
  Inline::C-Cookbook.</p>
<p class="Pp">For information on supported languages and platforms see
    Inline-Support.</p>
<p class="Pp">For information on writing your own Inline Language Support
    Module, see Inline-API.</p>
<p class="Pp">Inline's mailing list is inline@perl.org</p>
<p class="Pp">To subscribe, send email to inline-subscribe@perl.org</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_DEFICIENCIES"><a class="permalink" href="#BUGS_AND_DEFICIENCIES">BUGS
  AND DEFICIENCIES</a></h1>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>If you use C function names that happen to be used internally by Perl, you
      will get a load error at run time. There is currently no functionality to
      prevent this or to warn you. For now, a list of Perl's internal symbols is
      packaged in the Inline module distribution under the filename
      <span class="Li">'symbols.perl'</span>. Avoid using these in your
    code.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Brian Ingerson &lt;INGY@cpan.org&gt;
<p class="Pp">Sisyphus &lt;sisyphus@cpan.org&gt; fixed some bugs and is current
    co-maintainer.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c) 2000-2002. Brian Ingerson.
<p class="Pp">Copyright (c) 2008, 2010-2012. Sisyphus.</p>
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See http://www.perl.com/perl/misc/Artistic.html</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2012-11-19</td>
    <td class="foot-os">perl v5.18.2</td>
  </tr>
</table>
</body>
</html>
