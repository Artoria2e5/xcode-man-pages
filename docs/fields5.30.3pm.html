<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>fields(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">fields(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">fields(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
fields - compile-time class fields
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    {
        package Foo;
        use fields qw(foo bar _Foo_private);
        sub new {
            my Foo $self = shift;
            unless (ref $self) {
                $self = fields::new($self);
                $self-&gt;{_Foo_private} = &quot;this is Foo's secret&quot;;
            }
            $self-&gt;{foo} = 10;
            $self-&gt;{bar} = 20;
            return $self;
        }
    }

    my $var = Foo-&gt;new;
    $var-&gt;{foo} = 42;

    # this will generate a run-time error
    $var-&gt;{zap} = 42;

    # this will generate a compile-time error
    my Foo $foo = Foo-&gt;new;
    $foo-&gt;{zap} = 24;

    # subclassing
    {
        package Bar;
        use base 'Foo';
        use fields qw(baz _Bar_private);        # not shared with Foo
        sub new {
            my $class = shift;
            my $self = fields::new($class);
            $self-&gt;SUPER::new();                # init base fields
            $self-&gt;{baz} = 10;                  # init own fields
            $self-&gt;{_Bar_private} = &quot;this is Bar's secret&quot;;
            return $self;
        }
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <span class="Li">&quot;fields&quot;</span> pragma enables compile-time and
  run-time verified class fields.
<p class="Pp">NOTE: The current implementation keeps the declared fields in the
    <span class="Li">%FIELDS</span> hash of the calling package, but this may
    change in future versions. Do <b>not</b> update the
    <span class="Li">%FIELDS</span> hash directly, because it must be created at
    compile-time for it to be fully useful, as is done by this pragma.</p>
<p class="Pp">If a typed lexical variable (<span class="Li">&quot;my
    Class</span> <span class="Li">$var&quot;</span>) holding a reference is used
    to access a hash element and a package with the same name as the type has
    declared class fields using this pragma, then the hash key is verified at
    compile time. If the variables are not typed, access is only checked at run
    time.</p>
<p class="Pp">The related <span class="Li">&quot;base&quot;</span> pragma will
    combine fields from base classes and any fields declared using the
    <span class="Li">&quot;fields&quot;</span> pragma. This enables field
    inheritance to work properly. Inherited fields can be overridden but will
    generate a warning if warnings are enabled.</p>
<p class="Pp"><b>Only valid for Perl 5.8.x and earlier:</b> Field names that
    start with an underscore character are made private to the class and are not
    visible to subclasses.</p>
<p class="Pp">Also, <b>in Perl 5.8.x and earlier</b>, this pragma uses
    pseudo-hashes, the effect being that you can have objects with named fields
    which are as compact and as fast arrays to access, as long as the objects
    are accessed through properly typed variables.</p>
<p class="Pp">The following functions are supported:</p>
<dl class="Bl-tag">
  <dt>new</dt>
  <dd><b>fields::new()</b> creates and blesses a hash comprised of the fields
      declared using the <span class="Li">&quot;fields&quot;</span> pragma into
      the specified class. It is the recommended way to construct a fields-based
      object.
    <p class="Pp">This makes it possible to write a constructor like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    package Critter::Sounds;
    use fields qw(cat dog bird);

    sub new {
        my $self = shift;
        $self = fields::new($self) unless ref $self;
        $self-&gt;{cat} = 'meow';                      # scalar element
        @$self{'dog','bird'} = ('bark','tweet');    # slice
        return $self;
    }
    </pre>
  </dd>
  <dt>phash</dt>
  <dd><b>This function only works in Perl 5.8.x and earlier.</b> Pseudo-hashes
      were removed from Perl as of 5.10. Consider using restricted hashes or
      <b>fields::new()</b> instead (which itself uses restricted hashes under
      5.10+). See Hash::Util. Using <b>fields::phash()</b> under 5.10 or higher
      will cause an error.
    <p class="Pp"><b>fields::phash()</b> can be used to create and initialize a
        plain (unblessed) pseudo-hash. This function should always be used
        instead of creating pseudo-hashes directly.</p>
    <p class="Pp">If the first argument is a reference to an array, the
        pseudo-hash will be created with keys from that array. If a second
        argument is supplied, it must also be a reference to an array whose
        elements will be used as the values. If the second array contains less
        elements than the first, the trailing elements of the pseudo-hash will
        not be initialized. This makes it particularly useful for creating a
        pseudo-hash from subroutine arguments:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    sub dogtag {
       my $tag = fields::phash([qw(name rank ser_num)], [@_]);
    }
    </pre>
    <p class="Pp"><b>fields::phash()</b> also accepts a list of key-value pairs
        that will be used to construct the pseudo hash. Examples:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $tag = fields::phash(name =&gt; &quot;Joe&quot;,
                            rank =&gt; &quot;captain&quot;,
                            ser_num =&gt; 42);

    my $pseudohash = fields::phash(%args);
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
base, Hash::Util
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-10-24</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
