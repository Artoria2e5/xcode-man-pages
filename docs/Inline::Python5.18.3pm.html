<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Python(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Python(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Python(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Inline::Python - Write Perl subs and classes in Python.
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
   print &quot;9 + 16 = &quot;, add(9, 16), &quot;\n&quot;;
   print &quot;9 - 16 = &quot;, subtract(9, 16), &quot;\n&quot;;

   use Inline Python =&gt; &lt;&lt;'END_OF_PYTHON_CODE';
   def add(x,y): 
      return x + y

   def subtract(x,y):
      return x - y

   END_OF_PYTHON_CODE
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <span class="Li">&quot;Inline::Python&quot;</span> module allows you to put
  Python source code directly &quot;inline&quot; in a Perl script or module. It
  sets up an in-process Python interpreter, runs your code, and then examines
  Python's symbol table for things to bind to Perl. The process of interrogating
  the Python interpreter for globals only occurs the first time you run your
  Python code. The namespace is cached, and subsequent calls use the cached
  version.
<p class="Pp">This document describes
    <span class="Li">&quot;Inline::Python&quot;</span>, the Perl package which
    gives you access to a Python interpreter. For lack of a better place to keep
    it, it also gives you instructions on how to use
    <span class="Li">&quot;perlmodule&quot;</span>, the Python package which
    gives you access to the Perl interpreter.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="WHAT'S_NEW?"><a class="permalink" href="#WHAT'S_NEW?">WHAT'S
  NEW?</a></h1>
Version 0.21 provides the ability to bind to 'new-style' classes (as defined by
  the python PEP's 252 and 253.) See &quot;New-Style Classes&quot; for details.
<p class="Pp">See the Changes file for new features in recent versions.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Using_the_Inline::Python_Module"><a class="permalink" href="#Using_the_Inline::Python_Module">Using
  the Inline::Python Module</a></h1>
Using Inline::Python will seem very similar to using another Inline language,
  thanks to Inline's consistent look and feel.
<p class="Pp">This section will explain the different ways to use
    Inline::Python. For more details on
    <span class="Li">&quot;Inline&quot;</span>, see 'perldoc Inline'.</p>
<section class="Ss">
<h2 class="Ss" id="Giving_Your_Source_to_Inline"><a class="permalink" href="#Giving_Your_Source_to_Inline">Giving
  Your Source to Inline</a></h2>
The most basic form for using <span class="Li">&quot;Inline::Python&quot;</span>
  is this:
<p class="Pp"><span class="Li"></span></p>
<pre>
   use Inline Python =&gt; 'Python source code';
</pre>
<p class="Pp">Of course, you can use Perl's &quot;here document&quot; style of
    quoting to make the code slightly easier to read:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   use Inline Python =&gt; &lt;&lt;'END';

     Python source code goes here.

   END
</pre>
<p class="Pp">The source code can also be specified as a filename, a subroutine
    reference (sub routine should return source code), or an array reference
    (array contains lines of source code). The recommended way of using Inline
    is this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   use Inline Python;

   ...

   __END__
   __Python__

   Python source code goes here.
</pre>
<p class="Pp">This information is detailed in 'perldoc Inline'.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Importing_Functions"><a class="permalink" href="#Importing_Functions">Importing
  Functions</a></h2>
Maybe you have a whole library written in Python that only needs one entry
  point. You'll want to import that function. It's as easy as this:
<p class="Pp"><span class="Li"></span></p>
<pre>
   use Inline Python;

   doit();

   __END__
   __Python__

   from mylibrary import doit
</pre>
<p class="Pp">Inline::Python actually binds to every function in Python's
    &quot;global&quot; namespace (those of you in the know, know that namespace
    is called '__main__'). So if you had another function there, you'd get that
    too.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Importing_Classes"><a class="permalink" href="#Importing_Classes">Importing
  Classes</a></h2>
If you've written a library in Python, you'll make it object-oriented. That's
  just something Python folks do. So you'll probably want to import a class, not
  a function. That's just as easy:
<p class="Pp"><span class="Li"></span></p>
<pre>
   use Inline Python;

   my $obj = new Myclass;

   __END__
   __Python__

   from mylibrary import myclass as Myclass
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="New-Style_Classes"><a class="permalink" href="#New-Style_Classes">New-Style
  Classes</a></h2>
As of python 2.2, the python internals have begun to change in a way which makes
  types 'look' more like classes. This means that your python code can now
  subclass builtin python types such as lists, tuples, integers, and etc. It
  also means that identifying python objects and creating Perl bindings for them
  has become a little trickier.
<p class="Pp">See Guido's write-up (http://www.python.org/2.2.2/descrintro.html)
    and the relevant Python Enhancement Proposals (PEP) numbers 252 and 253 for
    details about the python code. Also, see the mailing-list discussion
    (http://mail.python.org/pipermail/python-dev/2004-July/046060.html) for
    possible implications regarding C-language python extensions.</p>
<p class="Pp">This change should not affect code which uses Inline::Python,
    except that it allows you to bind to python classes which have been written
    using these new features. In most cases, you will be importing an entire
    class from an external library as defined in the example above.</p>
<p class="Pp">In other cases, you may be writing Inline::Python code as
  follows:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   use Inline Python =&gt; &lt;&lt;'END';
   class Foo(object):
      def __init__(self):
         print &quot;new Foo object being created&quot;
         self.data = {}
      def get_data(self): return self.data
      def set_data(self,dat): 
         self.data = dat
   END
</pre>
<p class="Pp">Additional caveats may exist. Note that if the python class is
    subclassing one of the builtin types which would normally be accessible as a
    'Perlish' translation, that the instance will be an opaque object accessible
    only through its class methods.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # Class is defined as 'def Class(float):'
  my $obj = Class-&gt;new(4);
  print $$obj &quot;\n&quot;; # will NOT print '4.0'
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="New-Style"><a class="permalink" href="#New-Style">New-Style</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="Boundary_Conditions"><a class="permalink" href="#Boundary_Conditions">Boundary
  Conditions</a></h2>
What if you have a class that wasn't imported? Can you deal with instances of
  that class properly?
<p class="Pp">Of course you can! Check this out:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   use Inline Python =&gt; &lt;&lt;END;

   def Foo():
       class Bar:
           def __init__(self):
               print &quot;new Bar()&quot;
           def tank():
               return 10
       return Bar()

   END

   my $o = Foo();
   $o-&gt;tank();
</pre>
<p class="Pp">In this example, <span class="Li">&quot;Bar&quot;</span> isn't
    imported because it isn't a global -- it's hidden inside the function
    <i>Foo()</i>. But <i>Foo()</i> is imported into Perl, and it returns an
    instance of the <span class="Li">&quot;Bar&quot;</span> class. What happens
    then?</p>
<p class="Pp">Whenever Inline::Python needs to return an instance of a class to
    Perl, it generates an instance of Inline::Python::Object, the base class for
    all Inline::Python objects. This base class knows how to do all the things
    you need: calling methods, in this case.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Exceptions"><a class="permalink" href="#Exceptions">Exceptions</a></h1>
Exceptions thrown in Python code get translated to Perl exceptions which you can
  catch using eval.
</section>
<section class="Sh">
<h1 class="Sh" id="Using_Perl_inside_Python_(inside_Perl)"><a class="permalink" href="#Using_Perl_inside_Python_(inside_Perl)">Using
  Perl inside Python (inside Perl)</a></h1>
This section doesn't talk at all about
  <span class="Li">&quot;Inline::Python&quot;</span>. It's about how to use
  <span class="Li">&quot;perl&quot;</span>.
  <span class="Li">&quot;perl&quot;</span> is a Python module bundled with
  Inline::Python that gives you access to Perl from inside your Python code. In
  the future, it will be possible to compile Inline::Python to work the other
  way around -- to use Python as the main programming language, and jump into
  Perl when you want to.
<p class="Pp">The <span class="Li">&quot;perl&quot;</span> package exposes Perl
    packages and subs. It uses the same code as Inline::Python to automatically
    translate parameters and return values as needed. Packages and subs are
    represented as <span class="Li">&quot;PerlPkg&quot;</span> and
    <span class="Li">&quot;PerlSub&quot;</span>, respectively.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Using_the_PerlPkg_Type"><a class="permalink" href="#Using_the_PerlPkg_Type">Using
  the PerlPkg Type</a></h1>
The <span class="Li">&quot;perl&quot;</span> package is actually not a package
  at all. As soon as you import it, it replaces itself with an instance of the
  PerlPkg class, wrapping the Perl package &quot;main&quot;. Perl's 'main'
  package is analogous to '__main__' in Python.
<p class="Pp">Here's what you can do with the 'main' PerlPkg:</p>
<section class="Ss">
<h2 class="Ss" id="_fIeval()_fP"><a class="permalink" href="#_fIeval()_fP"><i>eval()</i></a></h2>
<span class="Li"></span>
<pre>
   eval(source code)
</pre>
<p class="Pp">Unlike Python, Perl has no <i>exec()</i> -- the <i>eval()</i>
    function always returns the result of the code it evaluated. <i>eval()</i>
    takes exactly one argument, the perl source code, and returns the result of
    the evaluation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIrequire()_fP_and__fIuse()_fP"><a class="permalink" href="#_fIrequire()_fP_and__fIuse()_fP"><i>require()</i>
  and <i>use()</i></a></h2>
<span class="Li"></span>
<pre>
   require(module name)
   use(module name)
</pre>
<p class="Pp">Use <i>require()</i> instead of
    <span class="Li">&quot;import&quot;</span>. In Python, you'd say this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   import md5
</pre>
<p class="Pp">But using the perl module, you'd say this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   perl.require(&quot;Digest::MD5&quot;)
</pre>
<p class="Pp">Of course, in Perl there's more than one way to do it (TM).
    <i>require()</i> doesn't run the package's <i>import()</i> function. If you
    want symbols exported, for instance, use <i>use()</i> instead of
    <i>require()</i>.</p>
<p class="Pp">Here is the functionality common to all PerlPkg instances:</p>
</section>
<section class="Ss">
<h2 class="Ss" id="____getattr____"><a class="permalink" href="#____getattr____">__getattr__</a></h2>
Python's __getattr__() function allows the package to dynamically return
  something to satisfy the request. For instance, you can get at the subs in a
  perl package by using <i>dir()</i> (which is the same as
  <span class="Li">&quot;getattr(perl,</span>
  <span class="Li">'__methods__')&quot;</span>.
<p class="Pp">Here's an example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   perl.eval(&quot;sub f { 10 }&quot;)    # define main::f
   f = perl.f
   f(); f(&quot;hello&quot;)              # no argument checking
   if perl.f() != 10: 
       import sys; sys.exit(1)
</pre>
<p class="Pp">Notice what happens. First we call <i>eval()</i> to define a sub
    'f'. Then we say <span class="Li">&quot;perl.f&quot;</span>, which goes into
    the __getattr__() method. We check the Perl namespace and see a function
    called f, which we return, wrapped in an instance of the PerlSub type.</p>
<p class="Pp"><i>Accessing a perl object's data</i></p>
<p class="Pp">__getattr__ may also be used to access a Perl object's attributes,
    just like Python allows. The Perl object just has to implement a sub
    __getattr__ returning the requested attribute, which may even be calculated
    on the fly.</p>
<p class="Pp">An example for the common hash based objects:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   sub __getattr__ {
       my ($self, $attr) = @_;
       return $self-&gt;{$attr}; 
   }
</pre>
<p class="Pp">This allows Python code to access the perl object's data like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   print my_perl_object.field_name
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="named_arguments"><a class="permalink" href="#named_arguments">named
  arguments</a></h2>
When a Perl sub is called with named arguments from Python code, Inline::Python
  follows the PyObject_Call protocol: positional arguments are given as array
  ref followed by named arguments as a hash ref. A Perl method supporting named
  arguments would therefore look like:
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub supports_named_arguments {
        my ($self, $positional, $named) = @_;
        foreach (qw( named1 named2 )) {
            last unless @$positional;
            $named-&gt;{$_} = shift @$positional;
        }
        ...
    }
</pre>
<p class="Pp">If this method is called using only positional arguments, they
    would just be pushed into <span class="Li">@_</span> like in any other
    method, complicating it to:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    sub supports_named_arguments {
        my ($self, $positional, $named) = @_;
        if (@_ == 3 and $size and ref $size and ref $size eq 'ARRAY' and ref $useimage eq 'HASH') { # called using named parameters
            foreach (qw( named1 named2 ... )) {
                last unless @$positional;
                $named-&gt;{$_} = shift @$positional;
            }
        }
        else {
            $named = { named1 =&gt; $positional, named2 =&gt; $named, named3 =&gt; $_[3], ... };
        }
        ...
    }
</pre>
<p class="Pp">As this adds a lot of boiler plate code to subroutines, it is
    better to just use Perl named arguments conventions (single hashref
    parameter) if possible.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Using_the_PerlSub_Type"><a class="permalink" href="#Using_the_PerlSub_Type">Using
  the PerlSub Type</a></h1>
All Perl subs are wrapped in the PerlSub type, so that they can emulate Python
  subroutines. You can call them. It's all good. Here's what you can do with
  PerlSub objects:
<section class="Ss">
<h2 class="Ss" id="Call"><a class="permalink" href="#Call">Call</a></h2>
PerlSub catches the call action and forwards the call to the real sub in Perl.
</section>
<section class="Ss">
<h2 class="Ss" id="Set_the_evaluation_flags"><a class="permalink" href="#Set_the_evaluation_flags">Set
  the evaluation flags</a></h2>
Perl has this notion of calling context. A subroutine can ask Perl what it is
  being used for. The idea is that if no one cares about your return value, you
  might be able to save time by not building it. By default, PerlSub objects
  evaluate in 'list' context with no extra flags turned on.
<p class="Pp"><span class="Li"></span></p>
<pre>
   perl.eval(&quot;sub f { 10 }&quot;)
   f = perl.f
   f.flags = f.flags | f.G_SCALAR
   x = f()
</pre>
<p class="Pp">Here are the most common flags you'll need. For more details about
    these and other possible flags, see perlcall.</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>G_VOID
    <p class="Pp">Calls the Perl subroutine in a void context. Guarantees that
        no results will be returned. If any are returned, Perl deletes them.</p>
  </dd>
  <dt>2.</dt>
  <dd>G_SCALAR
    <p class="Pp">Calls the Perl subroutine in a scalar context. Ensures that
        only one element is returned from the sub. If the sub returns a list,
        only the last element is actually saved.</p>
  </dd>
  <dt>3.</dt>
  <dd>G_ARRAY
    <p class="Pp">Calls the Perl subroutine in a list context. Ensures that any
        items returned from the subroutine are returned. This is the default for
        PerlSub objects.</p>
  </dd>
  <dt>4.</dt>
  <dd>G_DISCARD
    <p class="Pp">If you are not interested in the return values, you can
        optimize slightly by telling Perl, and it will discard all returned
        values for you.</p>
  </dd>
  <dt>5.</dt>
  <dd>G_NOARGS
    <p class="Pp">If you are not passing any arguments, you can optimize the
        call so that Perl doesn't bother setting up the stack for
      parameters.</p>
  </dd>
  <dt>6.</dt>
  <dd>G_EVAL
    <p class="Pp">It is possible for the Perl sub to fail, either by calling
        <i>die()</i> explicitly or by calling a non-existent sub. By default,
        the process will terminate immediately. To avoid this happening, you can
        trap the exception using the G_EVAL flag.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Under_the_Hood"><a class="permalink" href="#Under_the_Hood">Under
  the Hood</a></h1>
When Inline::Python imports a class or function, it creates subs in Perl which
  delegate the action to some C functions I've written, which know how to call
  Python functions and methods.
<p class="Pp"><span class="Li"></span></p>
<pre>
   use Inline Python =&gt; &lt;&lt;'END';

   class Foo:
      def __init__(self):
         print &quot;new Foo object being created&quot;
         self.data = {}
      def get_data(self): return self.data
      def set_data(self,dat): 
         self.data = dat

   END
</pre>
<p class="Pp">Inline::Python actually generates this code and <i>eval()</i>s
  it:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   package main::Foo;
   @main::Foo::ISA = qw(Inline::Python::Object);

   sub new {
     splice @_, 1, 0, &quot;__main__&quot;, &quot;Foo&quot;;
     return &amp;Inline::Python::py_new_object;
   }

   sub set_data {
     splice @_, 1, 0, &quot;set_data&quot;;
     return &amp;Inline::Python::py_call_method;
   }

   sub get_data {
     splice @_, 1, 0, &quot;get_data&quot;;
     return &amp;Inline::Python::py_call_method;
   }

   sub __init__ {
     splice @_, 1, 0, &quot;__init__&quot;;
     return &amp;Inline::Python::py_call_method;
   }
</pre>
<p class="Pp">More about those <span class="Li">&quot;py_*&quot;</span>
    functions, and how to generate this snippet of code yourself, in the next
    section.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="The_Do-it-yourselfer's_Guide_to_Inline::Python"><a class="permalink" href="#The_Do-it-yourselfer's_Guide_to_Inline::Python">The
  Do-it-yourselfer's Guide to Inline::Python</a></h1>
Sometimes you don't actually want to do things the Inline Way. Maybe you just
  want to use a Python class as-is, without ever treating it like a normal Perl
  class:
<p class="Pp"><span class="Li"></span></p>
<pre>
   use Inline::Python qw(py_eval);

   py_eval(&lt;&lt;'END');

   class MyClass:
       def __init__(self): self.data = {}
       def put(self, key, value): self.data[key] = value
       def get(self, key):
           try: return self.data[key]
           except KeyError: return None

   END

   my $o = Inline::Python::Object-&gt;new('__main__', 'MyClass');
   $o-&gt;put(&quot;candy&quot;, &quot;yummy&quot;);
   die &quot;Ooops&quot; unless $o-&gt;get(&quot;candy&quot;) eq 'yummy';
</pre>
<p class="Pp">Inline::Python provides a full suite of exportable functions you
    can use to manipulate Python objects and functions &quot;directly&quot;.</p>
<section class="Ss">
<h2 class="Ss" id="_fIpy_eval()_fP"><a class="permalink" href="#_fIpy_eval()_fP"><i>py_eval()</i></a></h2>
<span class="Li"></span>
<pre>
   py_eval(&quot;python source code&quot;, [context])
</pre>
<p class="Pp">The new <i>py_eval()</i> behaves a little like Perl's
    <i>eval()</i>. It evaluates the code or croaks on failure. The optional
    context argument can be used to place restrictions on the type of code
    allowed, as well as influence what happens to the result.</p>
<dl class="Bl-tag">
  <dt>0</dt>
  <dd>Accepts only expressions. Complete statements yield a syntax error. An
      expression is anything that can appear to the right of an '=' sign.
      Returns the value of the expression.</dd>
  <dt>1</dt>
  <dd>The default. Accepts arbitrarily long input, which may be any valid Python
      code. Always returns <span class="Li">&quot;undef&quot;</span>.</dd>
  <dt>2</dt>
  <dd>Accepts exactly one statement, and prints the result to STDOUT. This is
      how Python works in interactive mode. Always returns
      <span class="Li">&quot;undef&quot;</span>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIpy_call_function()_fP"><a class="permalink" href="#_fIpy_call_function()_fP"><i>py_call_function()</i></a></h2>
<span class="Li"></span>
<pre>
   py_call_function(&quot;package&quot;, &quot;function&quot;, args...)
</pre>
<p class="Pp">This function runs a Python function and returns the result. The
    &quot;package&quot; and &quot;function&quot; uniquely identify a function,
    and the remaining args are passed to the function.</p>
<p class="Pp">Those who know Python well enough will know you can actually
    &quot;run&quot; a class and get an instance of that class back. But in case
    that's just too weird for you, I've given you a slightly higher-level
    wrapper around that common idiom.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIpy_new_object()_fP"><a class="permalink" href="#_fIpy_new_object()_fP"><i>py_new_object()</i></a></h2>
<span class="Li"></span>
<pre>
   py_new_object(&quot;perl package&quot;, &quot;python package&quot;, 
                 &quot;python class&quot;, args...)
</pre>
<p class="Pp">This function creates an instance of a Python class. The
    &quot;python class&quot; is the name of the class inside the &quot;python
    package&quot;. The new object is blessed into the given &quot;perl
    package&quot;. The remaining args are passed directly to the
  constructor.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIpy_call_method()_fP"><a class="permalink" href="#_fIpy_call_method()_fP"><i>py_call_method()</i></a></h2>
<span class="Li"></span>
<pre>
   py_call_method(object, &quot;method name&quot;, args...)
</pre>
<p class="Pp">Given an instance of a Python class, this function can call a
    method on it. This is useful if you have an object which is blessed into a
    non-existent Perl package. Attempts to use Perl's object syntax would fail,
    because Perl wouldn't find any methods in that package. But
    <i>py_call_method()</i> can always perform method calls correctly since it
    unwraps the underlying Python object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIeval_python()_fP"><a class="permalink" href="#_fIeval_python()_fP"><i>eval_python()</i></a></h2>
Unlike in previous releases of Inline::Python, <i>eval_python()</i> can now
  return the result of the code. As before, <i>eval_python()</i> is overloaded:
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>eval_python(code, [context])
    <p class="Pp">Evaluate the code using <i>py_eval()</i>.</p>
  </dd>
  <dt>2.</dt>
  <dd>eval_python(python package, function, args...)
    <p class="Pp">Run the given function and return the results using
        <i>py_call_function()</i>.</p>
  </dd>
  <dt>3.</dt>
  <dd>eval_python(object, method, args...)
    <p class="Pp">Invoke the given method on the object using
        <i>py_call_method()</i> and return the results.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIpy_bind_func()_fP"><a class="permalink" href="#_fIpy_bind_func()_fP"><i>py_bind_func()</i></a></h2>
<span class="Li"></span>
<pre>
   py_bind_func(&quot;symbol name&quot;, &quot;python package&quot;, &quot;function&quot;)
</pre>
<p class="Pp">This function imports a Python function (named
    &quot;function&quot;) as the symbol named by &quot;perl symbol&quot;. After
    this function has been called, the Python function can be called as if it
    were a Perl function in the given package.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   use Inline::Python qw(py_eval py_bind_func);

   py_eval(&lt;&lt;'END');

   def Foo():
      return 42

   END

   # For the purposes of this example, so I know the package, I set it:
   py_bind_func(&quot;main::Bar&quot;, &quot;__main__&quot;, &quot;Foo&quot;);
   print &quot;The meaning of life is: &quot;, Bar(), &quot;\n&quot;;
</pre>
<p class="Pp">This call to <i>py_bind_func()</i> will generate this code and
    <i>eval()</i> it:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   sub main::Bar {
       unshift @_, &quot;__main__&quot;, &quot;Foo&quot;;
       return &amp;Inline::Python::py_call_function;
   }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIpy_bind_class()_fP"><a class="permalink" href="#_fIpy_bind_class()_fP"><i>py_bind_class()</i></a></h2>
<span class="Li"></span>
<pre>
   py_bind_class(&quot;perl package&quot;, &quot;python package&quot;, &quot;class&quot;, methods...)
</pre>
<p class="Pp">This function imports a Python class (named &quot;class&quot;)
    into the Perl package named by &quot;perl package&quot;. After this function
    has been called, the Perl package will look just like a regular Perl
  class.</p>
<p class="Pp">The example I showed earlier in the &quot;Under the Hood&quot;
    section shows the output of py_bind_class. Here's another look at it:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   use Inline::Python qw(py_eval py_bind_class);

   py_eval(&lt;&lt;'END');

   class Foo:
      def __init__(self):
         print &quot;new Foo object being created&quot;
         self.data = {}
      def get_data(self): return self.data
      def set_data(self,dat): 
         self.data = dat

   END

   py_bind_class(&quot;main::Foo&quot;, &quot;__main__&quot;, &quot;Foo&quot;, &quot;set_data&quot;, &quot;get_data&quot;);
   my $o = new Foo;
</pre>
<p class="Pp">This call to <i>py_bind_class()</i> will generate this code and
    <i>eval()</i> it:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   package main::Foo;
   @main::Foo::ISA = qw(Inline::Python::Object);

   sub new {
     splice @_, 1, 0, &quot;__main__&quot;, &quot;Foo&quot;;
     return &amp;Inline::Python::py_new_object;
   }

   sub set_data {
     splice @_, 1, 0, &quot;set_data&quot;;
     return &amp;Inline::Python::py_call_method;
   }

   sub get_data {
     splice @_, 1, 0, &quot;get_data&quot;;
     return &amp;Inline::Python::py_call_method;
   }
</pre>
<p class="Pp">Note that if you want methods to be created as I've shown, you
    must pass them to <i>py_bind_class()</i> yourself. It doesn't create
    anything except <i>new()</i> and the <span class="Li">@ISA</span> array. It
    doesn't need to, since the base class knows how to deal with any method call
    -- but it's also slower, since it has to walk up the inheritance tree to the
    AUTOLOAD method. I recommend binding to the functions you know about,
    especially if you're the one writing the code. If it's auto-generated, use
    <i>py_study_package()</i>, described below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIpy_study_package()_fP"><a class="permalink" href="#_fIpy_study_package()_fP"><i>py_study_package()</i></a></h2>
<span class="Li"></span>
<pre>
   py_study_package([&quot;package&quot;])
</pre>
<p class="Pp">This function interrogates the Python interpreter about the given
    package (or '__main__' if you don't specify one). It returns a list of
    key/value pairs, so it should be used like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   py_eval('import pickle');
   my %namespace = py_study_package(&quot;pickle&quot;);
</pre>
<p class="Pp">On my machine, <span class="Li">%namespace</span> looks something
    like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   $VAR1 = {
             'classes' =&gt; { ... },
             'functions' =&gt; [
                              '_keep_alive',
                              'loads',
                              'dump',
                              'load',
                              'dumps',
                              'test',
                              'whichmodule'
                            ]
           };
</pre>
<p class="Pp">Each result can be fed to <i>py_bind_function()</i> and
    <i>py_bind_class()</i>, which is exactly what Inline::Python itself
  does.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIpy_is_tuple()_fP"><a class="permalink" href="#_fIpy_is_tuple()_fP"><i>py_is_tuple()</i></a></h2>
<span class="Li"></span>
<pre>
   my $array_ref = py_eval('(1, 2)')
   $is_tuple = py_is_tuple($array_ref)
</pre>
<p class="Pp">This function can tell you if the array reference you got from
    calling some Python code was a tuple in Python or not (e.g. a normal array).
    This can be useful if an API requires a distinction between those cases.
    py_is_tuple works by looking for a magic marker put onto array refs by
    Py2Pl. Bear in mind that this marker may get lost when copying the array
    data.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
For information about using <span class="Li">&quot;Inline&quot;</span>, see
  Inline.
<p class="Pp">For information about other Inline languages, see
  Inline-Support.</p>
<p class="Pp">Inline::Python's mailing list is inline@perl.org</p>
<p class="Pp">To subscribe, send email to inline-subscribe@perl.org</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_DEFICIENCIES"><a class="permalink" href="#BUGS_AND_DEFICIENCIES">BUGS
  AND DEFICIENCIES</a></h1>
This is a production quality release of Inline::Python. It is fairly feature
  complete and runs stable with no known crasher bugs or memory leaks. Further
  testing and expanded support for other operating systems and platforms will be
  a focus for future releases.
<p class="Pp">When reporting a bug, please do the following:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
 - Put &quot;use Inline REPORTBUG;&quot; at the top of your code, or 
   use the command line option &quot;perl -MInline=REPORTBUG ...&quot;.
 - Run your code.
 - Follow the printed instructions.
</pre>
<p class="Pp">Here are some things to watch out for:</p>
<dl class="Bl-tag">
  <dt>1.</dt>
  <dd>Note that the namespace imported into Perl is NOT recursively traversed.
      Only Python <b>globals</b> are imported into Perl -- subclasses,
      subfunctions, and other modules are not imported.
    <p class="Pp">Example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   use Inline Python =&gt; &lt;&lt;'END';

   import mymodule

   class A: 
       class B: pass

   END
    </pre>
    <p class="Pp">The namespace imported into perl is ONLY that related to
        <span class="Li">&quot;A&quot;</span>. Nothing related to
        <span class="Li">&quot;mymodule&quot;</span> or
        <span class="Li">&quot;B&quot;</span> is imported, unless some Python
        code explicitly copies variables from the mymodule namespace into the
        global namespace before Perl binds to it.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORTED_PLATFORMS"><a class="permalink" href="#SUPPORTED_PLATFORMS">SUPPORTED
  PLATFORMS</a></h1>
Inline::Python has been tested on RedHat Linux 6.2 with a variety of different
  Perl and Python configurations. It also seems to be running pretty well on
  openSUSE at least from 10.3 to 11.4 and on Solaris. Previous versions of
  Inline::Python worked on Windows and Cygwin -- this version has never been
  tested there. I strongly suspect it will require patching. Please send me
  patches.
<p class="Pp">This version of Inline::Python has been tested with Python
    versions from 2.5 to 2.7. It may work on older versions but will almost
    certainly not work with Python 3.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Neil Watkiss &lt;NEILW@cpan.org&gt;
<p class="Pp">Brian Ingerson &lt;INGY@cpan.org&gt; is the author of Inline,
    Inline::C and Inline::CPR. He was responsible for much encouragement and
    many suggestions throughout the development of Inline::Python.</p>
<p class="Pp">Eric Wilhelm provided support for 'new-style' classes in version
    0.21. Many thanks, Eric!</p>
<p class="Pp">Stefan Seifert &lt;NINE@cpan.org&gt; fixed some bugs and is
    current co-maintainer.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright (c) 2001, Neil Watkiss.
<p class="Pp">All Rights Reserved. This module is free software. It may be used,
    redistributed and/or modified under the same terms as Perl itself.</p>
<p class="Pp">(see http://www.perl.com/perl/misc/Artistic.html)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="POD_ERRORS"><a class="permalink" href="#POD_ERRORS">POD
  ERRORS</a></h1>
Hey! <b>The above document had some coding errors, which are explained
  below:</b>
<dl class="Bl-tag">
  <dt>Around line 477:</dt>
  <dd>Expected text after =item, not a number</dd>
  <dt>Around line 482:</dt>
  <dd>Expected text after =item, not a number</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2011-04-29</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
