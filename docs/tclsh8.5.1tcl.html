<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 1993 The Regents of the University of California.
   Copyright (c) 1994-1996 Sun Microsystems, Inc.
  
   See the file "license.terms" for information on usage and redistribution
   of this file, and for a DISCLAIMER OF ALL WARRANTIES.
  
   RCS: @(#) $Id: tclsh.1,v 1.14 2007/12/13 15:22:33 dgp Exp $
  
   The -*- nroff -*- definitions below are for supplemental macros used
   in Tcl/Tk manual entries.
  
   .AP type name in/out ?indent?
  	Start paragraph describing an argument to a library procedure.
  	type is type of argument (int, etc.), in/out is either "in", "out",
  	or "in/out" to describe whether procedure reads or modifies arg,
  	and indent is equivalent to second arg of .IP (shouldn't ever be
  	needed;  use .AS below instead)
  
   .AS ?type? ?name?
  	Give maximum sizes of arguments for setting tab stops.  Type and
  	name are examples of largest possible arguments that will be passed
  	to .AP later.  If args are omitted, default tab stops are used.
  
   .BS
  	Start box enclosure.  From here until next .BE, everything will be
  	enclosed in one large box.
  
   .BE
  	End of box enclosure.
  
   .CS
  	Begin code excerpt.
  
   .CE
  	End code excerpt.
  
   .VS ?version? ?br?
  	Begin vertical sidebar, for use in marking newly-changed parts
  	of man pages.  The first argument is ignored and used for recording
  	the version when the .VS was added, so that the sidebars can be
  	found and removed when they reach a certain age.  If another argument
  	is present, then a line break is forced before starting the sidebar.
  
   .VE
  	End of vertical sidebar.
  
   .DS
  	Begin an indented unfilled display.
  
   .DE
  	End of indented unfilled display.
  
   .SO ?manpage?
  	Start of list of standard options for a Tk widget. The manpage
  	argument defines where to look up the standard options; if
  	omitted, defaults to "options". The options follow on successive
  	lines, in three columns separated by tabs.
  
   .SE
  	End of list of standard options for a Tk widget.
  
   .OP cmdName dbName dbClass
  	Start of description of a specific option.  cmdName gives the
  	option's name as specified in the class command, dbName gives
  	the option's name in the option database, and dbClass gives
  	the option's class in the option database.
  
   .UL arg1 arg2
  	Print arg1 underlined, then print arg2 normally.
  
   .QW arg1 ?arg2?
  	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
  
   .PQ arg1 ?arg2?
  	Print an open parenthesis, arg1 in quotes, then arg2 normally
  	(for trailing punctuation) and then a closing parenthesis.
  
   RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
  
  	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
  	# Start an argument description
  .b
  	# define tabbing values for .AP
  
  	# BS - start boxed text
  	# ^y = starting y location
  	# ^b = 1
  	# BE - end boxed text (draw box now)
  	Draw four-sided box normally, but don't draw top of
  	box if the box started on an earlier page.
  	# VS - start vertical sidebar
  	# ^Y = starting y location
  	# ^v = 1 (for troff;  for nroff this doesn't matter)
  	# VE - end of vertical sidebar
  	# Special macro to handle page bottom:  finish off current
  	# box/sidebar if in box/sidebar mode, then invoked standard
  	# page bottom macro.
  	Draw three-sided box if this is the box's first page,
  	draw two sides but no top otherwise.
  	# DS - begin display
  	# DE - end display
  	# SO - start of list of standard options
  	# SE - end of list of standard options
  	# OP - start of full description for a single option
  	# CS - begin code excerpt
  	# CE - end code excerpt
  	# UL - underline word
  	# QW - apply quotation marks to word
  " fix emacs highlighting
  	# PQ - apply parens and quotation marks to word
  " fix emacs highlighting
  	# QR - quoted range
  " fix emacs highlighting
  	# MT - "empty" string
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>tclsh(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">tclsh(1)</td>
    <td class="head-vol">Tcl Applications</td>
    <td class="head-rtitle">tclsh(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<pre>

</pre>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
tclsh - Simple shell containing Tcl interpreter
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>tclsh</b> ?-encoding <i>name</i>? ?<i>fileName arg arg ...</i>?
<pre>

</pre>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<b>Tclsh</b> is a shell-like application that reads Tcl commands from its
  standard input or from a file and evaluates them. If invoked with no arguments
  then it runs interactively, reading Tcl commands from standard input and
  printing command results and error messages to standard output. It runs until
  the <b>exit</b> command is invoked or until it reaches end-of-file on its
  standard input. If there exists a file <b>.tclshrc</b> (or <b>tclshrc.tcl</b>
  on the Windows platforms) in the home directory of the user, interactive
  <b>tclsh</b> evaluates the file as a Tcl script just before reading the first
  command from standard input.
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SCRIPT_FILES"><a class="permalink" href="#SCRIPT_FILES">SCRIPT
  FILES</a></h1>
If <b>tclsh</b> is invoked with arguments then the first few arguments specify
  the name of a script file, and, optionally, the encoding of the text data
  stored in that script file. Any additional arguments are made available to the
  script as variables (see below). Instead of reading commands from standard
  input <b>tclsh</b> will read Tcl commands from the named file; <b>tclsh</b>
  will exit when it reaches the end of the file. The end of the file may be
  marked either by the physical end of the medium, or by the character,
  &#x201C;\032&#x201D; (&#x201C;\u001a&#x201D;, control-Z). If this character is
  present in the file, the <b>tclsh</b> application will read text up to but not
  including the character. An application that requires this character in the
  file may safely encode it as &#x201C;\032&#x201D;, &#x201C;\x1a&#x201D;, or
  &#x201C;\u001a&#x201D;; or may generate it by use of commands such as
  <b>format</b> or <b>binary</b>. There is no automatic evaluation of
  <b>.tclshrc</b> when the name of a script file is presented on the
  <b>tclsh</b> command line, but the script file can always <b>source</b> it if
  desired.
<p class="Pp">If you create a Tcl script in a file whose first line is</p>
<div class="Bd-indent">
<pre>
<b>#!/usr/bin/tclsh</b>
</pre>
</div>
then you can invoke the script file directly from your shell if you mark the
  file as executable. This assumes that <b>tclsh</b> has been installed in the
  default location in /usr/bin; if it is installed somewhere else then you will
  have to modify the above line to match. Many UNIX systems do not allow the
  <b>#!</b> line to exceed about 30 characters in length, so be sure that the
  <b>tclsh</b> executable can be accessed with a short file name.
<p class="Pp">An even better approach is to start your script files with the
    following three lines:</p>
<div class="Bd-indent">
<pre>
<b>#!/bin/sh</b>
<b># the next line restarts using tclsh \</b>
<b>exec tclsh &quot;$0&quot; &quot;$@&quot;</b>
</pre>
</div>
This approach has three advantages over the approach in the previous paragraph.
  First, the location of the <b>tclsh</b> binary does not have to be hard-wired
  into the script: it can be anywhere in your shell search path. Second, it gets
  around the 30-character file name limit in the previous approach. Third, this
  approach will work even if <b>tclsh</b> is itself a shell script (this is done
  on some systems in order to handle multiple architectures or operating
  systems: the <b>tclsh</b> script selects one of several binaries to run). The
  three lines cause both <b>sh</b> and <b>tclsh</b> to process the script, but
  the <b>exec</b> is only executed by <b>sh</b>. <b>sh</b> processes the script
  first; it treats the second line as a comment and executes the third line. The
  <b>exec</b> statement cause the shell to stop processing and instead to start
  up <b>tclsh</b> to reprocess the entire script. When <b>tclsh</b> starts up,
  it treats all three lines as comments, since the backslash at the end of the
  second line causes the third line to be treated as part of the comment on the
  second line.
<p class="Pp">You should note that it is also common practice to install tclsh
    with its version number as part of the name. This has the advantage of
    allowing multiple versions of Tcl to exist on the same system at once, but
    also the disadvantage of making it harder to write scripts that start up
    uniformly across different versions of Tcl.</p>
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="VARIABLES"><a class="permalink" href="#VARIABLES">VARIABLES</a></h1>
<b>Tclsh</b> sets the following Tcl variables:
<dl class="Bl-tag">
  <dt><b>argc</b></dt>
  <dd>Contains a count of the number of <i>arg</i> arguments (0 if none), not
      including the name of the script file.</dd>
  <dt><b>argv</b></dt>
  <dd>Contains a Tcl list whose elements are the <i>arg</i> arguments, in order,
      or an empty string if there are no <i>arg</i> arguments.</dd>
  <dt><b>argv0</b></dt>
  <dd>Contains <i>fileName</i> if it was specified. Otherwise, contains the name
      by which <b>tclsh</b> was invoked.</dd>
  <dt><b>tcl_interactive</b></dt>
  <dd>Contains 1 if <b>tclsh</b> is running interactively (no <i>fileName</i>
      was specified and standard input is a terminal-like device), 0 otherwise.
    <p class="Pp"></p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="PROMPTS"><a class="permalink" href="#PROMPTS">PROMPTS</a></h1>
When <b>tclsh</b> is invoked interactively it normally prompts for each command
  with &#x201C;<b>% </b>&#x201D;. You can change the prompt by setting the
  variables <b>tcl_prompt1</b> and <b>tcl_prompt2</b>. If variable
  <b>tcl_prompt1</b> exists then it must consist of a Tcl script to output a
  prompt; instead of outputting a prompt <b>tclsh</b> will evaluate the script
  in <b>tcl_prompt1</b>. The variable <b>tcl_prompt2</b> is used in a similar
  way when a newline is typed but the current command is not yet complete; if
  <b>tcl_prompt2</b> is not set then no prompt is output for incomplete
  commands.
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARD_CHANNELS"><a class="permalink" href="#STANDARD_CHANNELS">STANDARD
  CHANNELS</a></h1>
See <b>Tcl_StandardChannels</b> for more explanations.
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
encoding(n), fconfigure(n), tclvars(n)
<p class="Pp"></p>
</section>
<section class="Sh">
<h1 class="Sh" id="KEYWORDS"><a class="permalink" href="#KEYWORDS">KEYWORDS</a></h1>
argument, interpreter, prompt, script file, shell
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date"></td>
    <td class="foot-os">Tcl</td>
  </tr>
</table>
</body>
</html>
