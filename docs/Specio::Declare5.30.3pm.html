<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Specio::Declare(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Specio::Declare(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Specio::Declare(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Specio::Declare - Specio declaration subroutines
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
version 0.46
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    package MyApp::Type::Library;

    use parent 'Specio::Exporter';

    use Specio::Declare;
    use Specio::Library::Builtins;

    declare(
        'Foo',
        parent =&gt; t('Str'),
        where  =&gt; sub { $_[0] =~ /foo/i },
    );

    declare(
        'ArrayRefOfInt',
        parent =&gt; t( 'ArrayRef', of =&gt; t('Int') ),
    );

    my $even = anon(
        parent =&gt; t('Int'),
        inline =&gt; sub {
            my $type      = shift;
            my $value_var = shift;

            return $value_var . ' % 2 == 0';
        },
    );

    coerce(
        t('ArrayRef'),
        from  =&gt; t('Foo'),
        using =&gt; sub { [ $_[0] ] },
    );

    coerce(
        $even,
        from  =&gt; t('Int'),
        using =&gt; sub { $_[0] % 2 ? $_[0] + 1 : $_[0] },
    );

    # Specio name is DateTime
    any_isa_type('DateTime');

    # Specio name is DateTimeObject
    object_isa_type( 'DateTimeObject', class =&gt; 'DateTime' );

    any_can_type(
        'Duck',
        methods =&gt; [ 'duck_walk', 'quack' ],
    );

    object_can_type(
        'DuckObject',
        methods =&gt; [ 'duck_walk', 'quack' ],
    );

    enum(
        'Colors',
        values =&gt; [qw( blue green red )],
    );

    intersection(
        'HashRefAndArrayRef',
        of =&gt; [ t('HashRef'), t('ArrayRef') ],
    );

    union(
        'IntOrArrayRef',
        of =&gt; [ t('Int'), t('ArrayRef') ],
    );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This package exports a set of type declaration helpers. Importing this package
  also causes it to create a <span class="Li">&quot;t&quot;</span> subroutine
  the caller.
</section>
<section class="Sh">
<h1 class="Sh" id="SUBROUTINES"><a class="permalink" href="#SUBROUTINES">SUBROUTINES</a></h1>
This module exports the following subroutines.
<section class="Ss">
<h2 class="Ss" id="t('name')"><a class="permalink" href="#t('name')">t('name')</a></h2>
This subroutine lets you access any types you have declared so far, as well as
  any types you imported from another type library.
<p class="Pp">If you pass an unknown name, it throws an exception.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="declare(...)"><a class="permalink" href="#declare(...)">declare(...)</a></h2>
This subroutine declares a named type. The first argument is the type name,
  followed by a set of key/value parameters:
<ul class="Bl-bullet">
  <li>parent =&gt; <span class="Li">$type</span>
    <p class="Pp">The parent should be another type object. Specifically, it can
        be anything which does the Specio::Constraint::Role::Interface role. The
        parent can be a named or anonymous type.</p>
  </li>
  <li>where =&gt; sub { ... }
    <p class="Pp">This is a subroutine which defines the type constraint. It
        will be passed a single argument, the value to check, and it should
        return true or false to indicate whether or not the value is valid for
        the type.</p>
    <p class="Pp">This parameter is mutually exclusive with the
        <span class="Li">&quot;inline&quot;</span> parameter.</p>
  </li>
  <li>inline =&gt; sub { ... }
    <p class="Pp">This is a subroutine that is called to generate inline code to
        validate the type. Inlining can be <i>much</i> faster than simply
        providing a subroutine with the
        <span class="Li">&quot;where&quot;</span> parameter, but is often more
        complicated to get right.</p>
    <p class="Pp">The inline generator is called as a method on the type with
        one argument. This argument is a <i>string</i> containing the variable
        name to use in the generated code. Typically this is something like
        <span class="Li">'$_[0]'</span> or <span class="Li">'$value'</span>.</p>
    <p class="Pp">The inline generator subroutine should return a <i>string</i>
        of code representing a single term, and it <i>should not</i> be
        terminated with a semicolon. This allows the inlined code to be safely
        included in an <span class="Li">&quot;if&quot;</span> statement, for
        example. You can use <span class="Li">&quot;do { }&quot;</span> blocks
        and ternaries to get everything into one term. Do not assign to the
        variable you are testing. This single term should evaluate to true or
        false.</p>
    <p class="Pp">The inline generator is expected to include code to implement
        both the current type and all its parents. Typically, the easiest way to
        do this is to write a subroutine something like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  sub {
      my $self = shift;
      my $var  = shift;

      return $self-&gt;parent-&gt;inline_check($var)
          . ' and more checking code goes here';
  }
    </pre>
    <p class="Pp">Or, more concisely:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  sub { $_[0]-&gt;parent-&gt;inline_check( $_[1] ) . 'more code that checks $_[1]' }
    </pre>
    <p class="Pp">The <span class="Li">&quot;inline&quot;</span> parameter is
        mutually exclusive with the <span class="Li">&quot;where&quot;</span>
        parameter.</p>
  </li>
  <li>message_generator =&gt; sub { ... }
    <p class="Pp">A subroutine to generate an error message when the type check
        fails. The default message says something like &quot;Validation failed
        for type named Int declared in package Specio::Library::Builtins
        (.../Specio/blib/lib/Specio/Library/Builtins.pm) at line 147 in sub
        named (eval) with value 1.1&quot;.</p>
    <p class="Pp">You can override this to provide something more specific about
        the way the type failed.</p>
    <p class="Pp">The subroutine you provide will be called as a method on the
        type with two arguments. The first is the description of the type (the
        bit in the message above that starts with &quot;type named Int ...&quot;
        and ends with &quot;... in sub named (eval)&quot;. This description says
        what the thing is and where it was defined.</p>
    <p class="Pp">The second argument is the value that failed the type check,
        after any coercions that might have been applied.</p>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="anon(...)"><a class="permalink" href="#anon(...)">anon(...)</a></h2>
This subroutine declares an anonymous type. It is identical to
  <span class="Li">&quot;declare&quot;</span> except that it expects a list of
  key/value parameters without a type name as the first parameter.
</section>
<section class="Ss">
<h2 class="Ss" id="coerce(...)"><a class="permalink" href="#coerce(...)">coerce(...)</a></h2>
This declares a coercion from one type to another. The first argument should be
  an object which does the Specio::Constraint::Role::Interface role. This can be
  either a named or anonymous type. This type is the type that the coercion is
  <i>to</i>.
<p class="Pp">The remaining arguments are key/value parameters:</p>
<ul class="Bl-bullet">
  <li>from =&gt; <span class="Li">$type</span>
    <p class="Pp">This must be an object which does the
        Specio::Constraint::Role::Interface role. This is type that we are
        coercing <i>from</i>. Again, this can be either a named or anonymous
        type.</p>
  </li>
  <li>using =&gt; sub { ... }
    <p class="Pp">This is a subroutine which defines the type coercion. It will
        be passed a single argument, the value to coerce. It should return a new
        value of the type this coercion is to.</p>
    <p class="Pp">This parameter is mutually exclusive with the
        <span class="Li">&quot;inline&quot;</span> parameter.</p>
  </li>
  <li>inline =&gt; sub { ... }
    <p class="Pp">This is a subroutine that is called to generate inline code to
        perform the coercion.</p>
    <p class="Pp">The inline generator is called as a method on the type with
        one argument. This argument is a <i>string</i> containing the variable
        name to use in the generated code. Typically this is something like
        <span class="Li">'$_[0]'</span> or <span class="Li">'$value'</span>.</p>
    <p class="Pp">The inline generator subroutine should return a <i>string</i>
        of code representing a single term, and it <i>should not</i> be
        terminated with a semicolon. This allows the inlined code to be safely
        included in an <span class="Li">&quot;if&quot;</span> statement, for
        example. You can use <span class="Li">&quot;do { }&quot;</span> blocks
        and ternaries to get everything into one term. This single term should
        evaluate to the new value.</p>
  </li>
</ul>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DECLARATION_HELPERS"><a class="permalink" href="#DECLARATION_HELPERS">DECLARATION
  HELPERS</a></h1>
This module also exports some helper subs for declaring certain kinds of types:
<section class="Ss">
<h2 class="Ss" id="any_isa_type,_object_isa_type"><a class="permalink" href="#any_isa_type,_object_isa_type">any_isa_type,
  object_isa_type</a></h2>
The <span class="Li">&quot;any_isa_type&quot;</span> helper creates a type which
  accepts a class name or object of the given class. The
  <span class="Li">&quot;object_isa_type&quot;</span> helper creates a type
  which only accepts an object of the given class.
<p class="Pp">These subroutines take a type name as the first argument. The
    remaining arguments are key/value pairs. Currently this is just the
    <span class="Li">&quot;class&quot;</span> key, which should be a class name.
    This is the class that the type requires.</p>
<p class="Pp">The type name argument can be omitted to create an anonymous
  type.</p>
<p class="Pp">You can also pass just a single argument, in which case that will
    be used as both the type's name and the class for the constraint to
  check.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="any_does_type,_object_does_type"><a class="permalink" href="#any_does_type,_object_does_type">any_does_type,
  object_does_type</a></h2>
The <span class="Li">&quot;any_does_type&quot;</span> helper creates a type
  which accepts a class name or object which does the given role. The
  <span class="Li">&quot;object_does_type&quot;</span> helper creates a type
  which only accepts an object which does the given role.
<p class="Pp">These subroutines take a type name as the first argument. The
    remaining arguments are key/value pairs. Currently this is just the
    <span class="Li">&quot;role&quot;</span> key, which should be a role name.
    This is the class that the type requires.</p>
<p class="Pp">This should just work (I hope) with roles created by Moose, Mouse,
    and Moo (using Role::Tiny).</p>
<p class="Pp">The type name argument can be omitted to create an anonymous
  type.</p>
<p class="Pp">You can also pass just a single argument, in which case that will
    be used as both the type's name and the role for the constraint to
  check.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="any_can_type,_object_can_type"><a class="permalink" href="#any_can_type,_object_can_type">any_can_type,
  object_can_type</a></h2>
The <span class="Li">&quot;any_can_type&quot;</span> helper creates a type which
  accepts a class name or object with the given methods. The
  <span class="Li">&quot;object_can_type&quot;</span> helper creates a type
  which only accepts an object with the given methods.
<p class="Pp">These subroutines take a type name as the first argument. The
    remaining arguments are key/value pairs. Currently this is just the
    <span class="Li">&quot;methods&quot;</span> key, which can be either a
    string or array reference of strings. These strings are the required methods
    for the type.</p>
<p class="Pp">The type name argument can be omitted to create an anonymous
  type.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="enum"><a class="permalink" href="#enum">enum</a></h2>
This creates a type which accepts a string matching a given list of acceptable
  values.
<p class="Pp">The first argument is the type name. The remaining arguments are
    key/value pairs. Currently this is just the
    <span class="Li">&quot;values&quot;</span> key. This should an array
    reference of acceptable string values.</p>
<p class="Pp">The type name argument can be omitted to create an anonymous
  type.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="intersection"><a class="permalink" href="#intersection">intersection</a></h2>
This creates a type which is the intersection of two or more other types. A
  union only accepts values which match all of its underlying types.
<p class="Pp">The first argument is the type name. The remaining arguments are
    key/value pairs. Currently this is just the
    <span class="Li">&quot;of&quot;</span> key. This should an array reference
    of types.</p>
<p class="Pp">The type name argument can be omitted to create an anonymous
  type.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="union"><a class="permalink" href="#union">union</a></h2>
This creates a type which is the union of two or more other types. A union
  accepts any of its underlying types.
<p class="Pp">The first argument is the type name. The remaining arguments are
    key/value pairs. Currently this is just the
    <span class="Li">&quot;of&quot;</span> key. This should an array reference
    of types.</p>
<p class="Pp">The type name argument can be omitted to create an anonymous
  type.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="PARAMETERIZED_TYPES"><a class="permalink" href="#PARAMETERIZED_TYPES">PARAMETERIZED
  TYPES</a></h1>
You can create a parameterized type by calling
  <span class="Li">&quot;t&quot;</span> with additional parameters, like this:
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $arrayref_of_int = t( 'ArrayRef', of =&gt; t('Int') );

  my $arrayref_of_hashref_of_int = t(
      'ArrayRef',
      of =&gt; t(
          'HashRef',
          of =&gt; t('Int'),
      ),
  );
</pre>
<p class="Pp">The <span class="Li">&quot;t&quot;</span> subroutine assumes that
    if it receives more than one argument, it should look up the named type and
    call <span class="Li">&quot;$type-&gt;parameterize(...)&quot;</span> with
    the additional arguments.</p>
<p class="Pp">If the named type cannot be parameterized, it throws an error.</p>
<p class="Pp">You can also call
    <span class="Li">&quot;$type-&gt;parameterize&quot;</span> directly if
    needed. See Specio::Constraint::Parameterizable for details.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
Bugs may be submitted at &lt;https://github.com/houseabsolute/Specio/issues&gt;.
<p class="Pp">I am also usually active on IRC as 'autarch' on
    <span class="Li">&quot;irc://irc.perl.org&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SOURCE"><a class="permalink" href="#SOURCE">SOURCE</a></h1>
The source code repository for Specio can be found at
  &lt;https://github.com/houseabsolute/Specio&gt;.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Dave Rolsky &lt;autarch@urth.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
This software is Copyright (c) 2012 - 2020 by Dave Rolsky.
<p class="Pp">This is free software, licensed under:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  The Artistic License 2.0 (GPL Compatible)
</pre>
<p class="Pp">The full text of the license can be found in the <i>LICENSE</i>
    file included with this distribution.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-03-14</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
