<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::RequestIO(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::RequestIO(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::RequestIO(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Apache2::RequestIO - Perl API for Apache request record IO
</section>
<section class="Sh">
<h1 class="Sh" id="Synopsis"><a class="permalink" href="#Synopsis">Synopsis</a></h1>
<span class="Li"></span>
<pre>
  use Apache2::RequestIO ();
  
  $rc = $r-&gt;discard_request_body();
  
  $r-&gt;print(&quot;foo&quot;, &quot;bar&quot;);
  $r-&gt;puts(&quot;foo&quot;, &quot;bar&quot;); # same as print, but no flushing
  $r-&gt;printf(&quot;%s $d&quot;, &quot;foo&quot;, 5);
  
  $r-&gt;read($buffer, $len);
  
  $r-&gt;rflush();
  
  $r-&gt;sendfile($filename);
  
  $r-&gt;write(&quot;foobartarcar&quot;, 3, 5);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Description"><a class="permalink" href="#Description">Description</a></h1>
<span class="Li">&quot;Apache2::RequestIO&quot;</span> provides the API to
  perform IO on the Apache request object.
</section>
<section class="Sh">
<h1 class="Sh" id="API"><a class="permalink" href="#API">API</a></h1>
<span class="Li">&quot;Apache2::RequestIO&quot;</span> provides the following
  functions and/or methods:
<section class="Ss">
<h2 class="Ss" id="_discard_request_body_"><a class="permalink" href="#_discard_request_body_">&quot;discard_request_body&quot;</a></h2>
In HTTP/1.1, any method can have a body. However, most GET handlers wouldn't
  know what to do with a request body if they received one. This helper routine
  tests for and reads any message body in the request, simply discarding
  whatever it receives. We need to do this because failing to read the request
  body would cause it to be interpreted as the next request on a persistent
  connection.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $rc = $r-&gt;discard_request_body();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd>The current request</dd>
  <dt>ret: $rc ( integer )</dt>
  <dd><span class="Li">&quot;APR::Const status constant&quot;</span> if request
      is malformed, <span class="Li">&quot;Apache2::Const::OK&quot;</span>
      otherwise.</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Since we return an error status if the request is malformed, this
    routine should be called at the beginning of a no-body handler, e.g.,</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   use Apache2::Const -compile =&gt; qw(OK);
   $rc = $r-&gt;discard_request_body;
   return $rc if $rc != Apache2::Const::OK;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_print_"><a class="permalink" href="#_print_">&quot;print&quot;</a></h2>
Send data to the client.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $cnt = $r-&gt;print(@msg);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>arg1: @msg ( ARRAY )</dt>
  <dd>Data to send</dd>
  <dt>ret: $cnt ( number )</dt>
  <dd>How many bytes were sent (or buffered). If zero bytes were sent,
      <span class="Li">&quot;print&quot;</span> will return
      <span class="Li">0E0</span>, or &quot;zero but true,&quot; which will
      still evaluate to <span class="Li">0</span> in a numerical context.</dd>
  <dt>excpt: &quot;APR::Error&quot;</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">The data is flushed only if STDOUT stream's
    <span class="Li">$|</span> is true. Otherwise it's buffered up to the size
    of the buffer, flushing only excessive data.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_printf_"><a class="permalink" href="#_printf_">&quot;printf&quot;</a></h2>
Format and send data to the client (same as
  <span class="Li">&quot;printf&quot;</span>).
<p class="Pp"><span class="Li"></span></p>
<pre>
  $cnt = $r-&gt;printf($format, @args);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>arg1: $format ( string )</dt>
  <dd>Format string, as in the Perl core
      <span class="Li">&quot;printf&quot;</span> function.</dd>
  <dt>arg2: @args ( ARRAY )</dt>
  <dd>Arguments to be formatted, as in the Perl core
      <span class="Li">&quot;printf&quot;</span> function.</dd>
  <dt>ret: $cnt ( number )</dt>
  <dd>How many bytes were sent (or buffered)</dd>
  <dt>excpt: &quot;APR::Error&quot;</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">The data is flushed only if STDOUT stream's
    <span class="Li">$|</span> is true. Otherwise it's buffered up to the size
    of the buffer, flushing only excessive data.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_puts_"><a class="permalink" href="#_puts_">&quot;puts&quot;</a></h2>
Send data to the client
<p class="Pp"><span class="Li"></span></p>
<pre>
  $cnt = $r-&gt;puts(@msg);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>arg1: @msg ( ARRAY )</dt>
  <dd>Data to send</dd>
  <dt>ret: $cnt ( number )</dt>
  <dd>How many bytes were sent (or buffered)</dd>
  <dt>excpt: &quot;APR::Error&quot;</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li">&quot;puts()&quot;</span> is similar to
    <span class="Li">&quot;print()&quot;</span>, but it won't attempt to flush
    data, no matter what the value of STDOUT stream's <span class="Li">$|</span>
    is. Therefore assuming that STDOUT stream's <span class="Li">$|</span> is
    true, this method should be a tiny bit faster than
    <span class="Li">&quot;print()&quot;</span>, especially if small strings are
    printed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_read_"><a class="permalink" href="#_read_">&quot;read&quot;</a></h2>
Read data from the client.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $cnt = $r-&gt;read($buffer, $len);
  $cnt = $r-&gt;read($buffer, $len, $offset);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>arg1: $buffer ( SCALAR )</dt>
  <dd>The buffer to populate with the read data</dd>
  <dt>arg2: $len ( number )</dt>
  <dd>How many bytes to attempt to read</dd>
  <dt>opt arg3: $offset ( number )</dt>
  <dd>If a non-zero <span class="Li">$offset</span> is specified, the read data
      will be placed at that offset in the <span class="Li">$buffer</span>.
    <p class="Pp">META: negative offset and \0 padding are not supported at the
        moment</p>
  </dd>
  <dt>ret: $cnt ( number )</dt>
  <dd>How many characters were actually read</dd>
  <dt>excpt: &quot;APR::Error&quot;</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">This method shares a lot of similarities with the Perl core
    <span class="Li">&quot;read()&quot;</span> function. The main difference in
    the error handling, which is done via <span class="Li">&quot;APR::Error
    exceptions&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="_rflush_"><a class="permalink" href="#_rflush_">&quot;rflush&quot;</a></h2>
Flush any buffered data to the client.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r-&gt;rflush();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: no return value</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Unless STDOUT stream's <span class="Li">$|</span> is false, data
    sent via <span class="Li">&quot;$r-&gt;print()&quot;</span> is buffered.
    This method flushes that data to the client.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_sendfile_"><a class="permalink" href="#_sendfile_">&quot;sendfile&quot;</a></h2>
Send a file or a part of it
<p class="Pp"><span class="Li"></span></p>
<pre>
  $rc = $r-&gt;sendfile($filename);
  $rc = $r-&gt;sendfile($filename, $offset);
  $rc = $r-&gt;sendfile($filename, $offset, $len);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>arg1: $filename ( string )</dt>
  <dd>The full path to the file (using <span class="Li">&quot;/&quot;</span> on
      all systems)</dd>
  <dt>opt arg2: $offset ( integer )</dt>
  <dd>Offset into the file to start sending.
    <p class="Pp">No offset is used if <span class="Li">$offset</span> is not
        specified.</p>
  </dd>
  <dt>opt arg3: $len ( integer )</dt>
  <dd>How many bytes to send.
    <p class="Pp">If not specified the whole file is sent (or a part of it, if
        <span class="Li">$offset</span> if specified)</p>
  </dd>
  <dt>ret: $rc ( &quot;APR::Const status constant&quot; )</dt>
  <dd>On success, <span class="Li">&quot;APR::Const::SUCCESS&quot;</span> is
      returned.
    <p class="Pp">In case of a failure -- a failure code is returned, in which
        case normally it should be returned to the caller.</p>
  </dd>
  <dt>excpt: &quot;APR::Error&quot;</dt>
  <dd>Exceptions are thrown only when this function is called in the VOID
      context. So if you don't want to handle the errors, just don't ask for a
      return value and the function will handle all the errors on its own.</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_write_"><a class="permalink" href="#_write_">&quot;write&quot;</a></h2>
Send partial string to the client
<p class="Pp"><span class="Li"></span></p>
<pre>
  $cnt = $r-&gt;write($buffer);
  $cnt = $r-&gt;write($buffer, $len);
  $cnt = $r-&gt;write($buffer, $len, $offset);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>arg1: $buffer ( SCALAR )</dt>
  <dd>The string with data</dd>
  <dt>opt arg2: $len ( SCALAR )</dt>
  <dd>How many bytes to send. If not specified, or -1 is specified, all the data
      in <span class="Li">$buffer</span> (or starting from
      <span class="Li">$offset</span>) will be sent.</dd>
  <dt>opt arg3: $offset ( number )</dt>
  <dd>Offset into the <span class="Li">$buffer</span> string.</dd>
  <dt>ret: $cnt ( number )</dt>
  <dd>How many bytes were sent (or buffered)</dd>
  <dt>excpt: &quot;APR::Error&quot;</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Examples:</p>
<p class="Pp">Assuming that we have a string:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $string = &quot;123456789&quot;;
</pre>
<p class="Pp">Then:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r-&gt;write($string);
</pre>
<p class="Pp">sends:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  123456789
</pre>
<p class="Pp">Whereas:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r-&gt;write($string, 3);
</pre>
<p class="Pp">sends:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  123
</pre>
<p class="Pp">And:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r-&gt;write($string, 3, 5);
</pre>
<p class="Pp">sends:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  678
</pre>
<p class="Pp">Finally:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r-&gt;write($string, -1, 5);
</pre>
<p class="Pp">sends:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  6789
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TIE_Interface"><a class="permalink" href="#TIE_Interface">TIE
  Interface</a></h1>
The TIE interface implementation. This interface is used for HTTP request
  handlers, when running under <span class="Li">&quot;SetHandler</span>
  <span class="Li">perl-script&quot;</span> and Perl doesn't have perlio
  enabled.
<p class="Pp">See the <i>perltie</i> manpage for more information.</p>
<section class="Ss">
<h2 class="Ss" id="_BINMODE_"><a class="permalink" href="#_BINMODE_">&quot;BINMODE&quot;</a></h2>
<dl class="Bl-tag">
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">NoOP</p>
<p class="Pp">See the <i>binmode</i> Perl entry in the <i>perlfunc</i>
  manpage</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_CLOSE_"><a class="permalink" href="#_CLOSE_">&quot;CLOSE&quot;</a></h2>
<dl class="Bl-tag">
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">NoOP</p>
<p class="Pp">See the <i>close</i> Perl entry in the <i>perlfunc</i> manpage</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_FILENO_"><a class="permalink" href="#_FILENO_">&quot;FILENO&quot;</a></h2>
<dl class="Bl-tag">
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">See the <i>fileno</i> Perl entry in the <i>perlfunc</i>
  manpage</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_GETC_"><a class="permalink" href="#_GETC_">&quot;GETC&quot;</a></h2>
<dl class="Bl-tag">
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">See the <i>getc</i> Perl entry in the <i>perlfunc</i> manpage</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_OPEN_"><a class="permalink" href="#_OPEN_">&quot;OPEN&quot;</a></h2>
<dl class="Bl-tag">
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">See the <i>open</i> Perl entry in the <i>perlfunc</i> manpage</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_PRINT_"><a class="permalink" href="#_PRINT_">&quot;PRINT&quot;</a></h2>
<dl class="Bl-tag">
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">See the <i>print</i> Perl entry in the <i>perlfunc</i> manpage</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_PRINTF_"><a class="permalink" href="#_PRINTF_">&quot;PRINTF&quot;</a></h2>
<dl class="Bl-tag">
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">See the <i>printf</i> Perl entry in the <i>perlfunc</i>
  manpage</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_READ_"><a class="permalink" href="#_READ_">&quot;READ&quot;</a></h2>
<dl class="Bl-tag">
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">See the <i>read</i> Perl entry in the <i>perlfunc</i> manpage</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_TIEHANDLE_"><a class="permalink" href="#_TIEHANDLE_">&quot;TIEHANDLE&quot;</a></h2>
<dl class="Bl-tag">
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">See the <i>tie</i> Perl entry in the <i>perlfunc</i> manpage</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_UNTIE_"><a class="permalink" href="#_UNTIE_">&quot;UNTIE&quot;</a></h2>
<dl class="Bl-tag">
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">NoOP</p>
<p class="Pp">See the <i>untie</i> Perl entry in the <i>perlfunc</i> manpage</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_WRITE_"><a class="permalink" href="#_WRITE_">&quot;WRITE&quot;</a></h2>
<dl class="Bl-tag">
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">See the <i>write</i> Perl entry in the <i>perlfunc</i> manpage</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Deprecated_API"><a class="permalink" href="#Deprecated_API">Deprecated
  API</a></h1>
The following methods are deprecated, Apache plans to remove those in the
  future, therefore avoid using them.
<section class="Ss">
<h2 class="Ss" id="_get_client_block_"><a class="permalink" href="#_get_client_block_">&quot;get_client_block&quot;</a></h2>
This method is deprecated since the C implementation is buggy and we don't want
  you to use it at all. Instead use the plain
  <span class="Li">&quot;$r-&gt;read()&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="_setup_client_block_"><a class="permalink" href="#_setup_client_block_">&quot;setup_client_block&quot;</a></h2>
This method is deprecated since
  <span class="Li">&quot;$r-&gt;get_client_block&quot;</span> is deprecated.
</section>
<section class="Ss">
<h2 class="Ss" id="_should_client_block_"><a class="permalink" href="#_should_client_block_">&quot;should_client_block&quot;</a></h2>
This method is deprecated since
  <span class="Li">&quot;$r-&gt;get_client_block&quot;</span> is deprecated.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="See_Also"><a class="permalink" href="#See_Also">See
  Also</a></h1>
mod_perl 2.0 documentation.
</section>
<section class="Sh">
<h1 class="Sh" id="Copyright"><a class="permalink" href="#Copyright">Copyright</a></h1>
mod_perl 2.0 and its core modules are copyrighted under The Apache Software
  License, Version 2.0.
</section>
<section class="Sh">
<h1 class="Sh" id="Authors"><a class="permalink" href="#Authors">Authors</a></h1>
The mod_perl development team and numerous contributors.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-06-18</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
