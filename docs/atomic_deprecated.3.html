<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>ATOMIC_DEPRECATED(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">ATOMIC_DEPRECATED(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">ATOMIC_DEPRECATED(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<code class="Nm">OSAtomicAdd32</code>,
  <code class="Nm">OSAtomicAdd32Barrier</code>,
  <code class="Nm">OSAtomicIncrement32</code>,
  <code class="Nm">OSAtomicIncrement32Barrier</code>,
  <code class="Nm">OSAtomicDecrement32</code>,
  <code class="Nm">OSAtomicDecrement32Barrier</code>,
  <code class="Nm">OSAtomicOr32</code>,
  <code class="Nm">OSAtomicOr32Barrier</code>,
  <code class="Nm">OSAtomicOr32Orig</code>,
  <code class="Nm">OSAtomicOr32OrigBarrier</code>,
  <code class="Nm">OSAtomicAnd32</code>,
  <code class="Nm">OSAtomicAnd32Barrier</code>,
  <code class="Nm">OSAtomicAnd32Orig</code>,
  <code class="Nm">OSAtomicAnd32OrigBarrier</code>,
  <code class="Nm">OSAtomicXor32</code>,
  <code class="Nm">OSAtomicXor32Barrier</code>,
  <code class="Nm">OSAtomicXor32Orig</code>,
  <code class="Nm">OSAtomicXor32OrigBarrier</code>,
  <code class="Nm">OSAtomicAdd64</code>,
  <code class="Nm">OSAtomicAdd64Barrier</code>,
  <code class="Nm">OSAtomicIncrement64</code>,
  <code class="Nm">OSAtomicIncrement64Barrier</code>,
  <code class="Nm">OSAtomicDecrement64</code>,
  <code class="Nm">OSAtomicDecrement64Barrier</code>,
  <code class="Nm">OSAtomicCompareAndSwapInt</code>,
  <code class="Nm">OSAtomicCompareAndSwapIntBarrier</code>,
  <code class="Nm">OSAtomicCompareAndSwapLong</code>,
  <code class="Nm">OSAtomicCompareAndSwapLongBarrier</code>,
  <code class="Nm">OSAtomicCompareAndSwapPtr</code>,
  <code class="Nm">OSAtomicCompareAndSwapPtrBarrier</code>,
  <code class="Nm">OSAtomicCompareAndSwap32</code>,
  <code class="Nm">OSAtomicCompareAndSwap32Barrier</code>,
  <code class="Nm">OSAtomicCompareAndSwap64</code>,
  <code class="Nm">OSAtomicCompareAndSwap64Barrier</code>,
  <code class="Nm">OSAtomicTestAndSet</code>,
  <code class="Nm">OSAtomicTestAndSetBarrier</code>,
  <code class="Nm">OSAtomicTestAndClear</code>,
  <code class="Nm">OSAtomicTestAndClearBarrier</code>,
  <code class="Nm">OSMemoryBarrier</code> &#x2014;
<div class="Nd">deprecated atomic add, increment, decrement, or, and, xor,
  compare and swap, test and set, test and clear, and memory barrier</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<code class="In">#include &lt;<a class="In">libkern/OSAtomic.h</a>&gt;</code>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicAdd32</code>(<var class="Fa" style="white-space: nowrap;">int32_t
    theAmount</var>, <var class="Fa" style="white-space: nowrap;">volatile
    int32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicAdd32Barrier</code>(<var class="Fa" style="white-space: nowrap;">int32_t
    theAmount</var>, <var class="Fa" style="white-space: nowrap;">volatile
    int32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicIncrement32</code>(<var class="Fa" style="white-space: nowrap;">volatile
    int32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicIncrement32Barrier</code>(<var class="Fa" style="white-space: nowrap;">volatile
    int32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicDecrement32</code>(<var class="Fa" style="white-space: nowrap;">volatile
    int32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicDecrement32Barrier</code>(<var class="Fa" style="white-space: nowrap;">volatile
    int32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicOr32</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicOr32Barrier</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicAnd32</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicAnd32Barrier</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicXor32</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicXor32Barrier</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicOr32Orig</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicOr32OrigBarrier</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicAnd32Orig</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicAnd32OrigBarrier</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicXor32Orig</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int32_t</var>
  <br/>
  <code class="Fn">OSAtomicXor32OrigBarrier</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    theMask</var>, <var class="Fa" style="white-space: nowrap;">volatile
    uint32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int64_t</var>
  <br/>
  <code class="Fn">OSAtomicAdd64</code>(<var class="Fa" style="white-space: nowrap;">int64_t
    theAmount</var>, <var class="Fa" style="white-space: nowrap;">volatile
    OSAtomic_int64_aligned64_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int64_t</var>
  <br/>
  <code class="Fn">OSAtomicAdd64Barrier</code>(<var class="Fa" style="white-space: nowrap;">int64_t
    theAmount</var>, <var class="Fa" style="white-space: nowrap;">volatile
    OSAtomic_int64_aligned64_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int64_t</var>
  <br/>
  <code class="Fn">OSAtomicIncrement64</code>(<var class="Fa" style="white-space: nowrap;">volatile
    OSAtomic_int64_aligned64_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int64_t</var>
  <br/>
  <code class="Fn">OSAtomicIncrement64Barrier</code>(<var class="Fa" style="white-space: nowrap;">volatile
    OSAtomic_int64_aligned64_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int64_t</var>
  <br/>
  <code class="Fn">OSAtomicDecrement64</code>(<var class="Fa" style="white-space: nowrap;">volatile
    OSAtomic_int64_aligned64_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">int64_t</var>
  <br/>
  <code class="Fn">OSAtomicDecrement64Barrier</code>(<var class="Fa" style="white-space: nowrap;">volatile
    OSAtomic_int64_aligned64_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwapInt</code>(<var class="Fa" style="white-space: nowrap;">int
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">int
    newValue</var>, <var class="Fa" style="white-space: nowrap;">volatile int
    *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwapIntBarrier</code>(<var class="Fa" style="white-space: nowrap;">int
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">int
    newValue</var>, <var class="Fa" style="white-space: nowrap;">volatile int
    *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwapLong</code>(<var class="Fa" style="white-space: nowrap;">long
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">long
    newValue</var>, <var class="Fa" style="white-space: nowrap;">volatile long
    *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwapLongBarrier</code>(<var class="Fa" style="white-space: nowrap;">long
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">long
    newValue</var>, <var class="Fa" style="white-space: nowrap;">volatile long
    *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwapPtr</code>(<var class="Fa" style="white-space: nowrap;">void*
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">void*
    newValue</var>, <var class="Fa" style="white-space: nowrap;">void* volatile
    *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwapPtrBarrier</code>(<var class="Fa" style="white-space: nowrap;">void*
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">void*
    newValue</var>, <var class="Fa" style="white-space: nowrap;">void* volatile
    *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwap32</code>(<var class="Fa" style="white-space: nowrap;">int32_t
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">int32_t
    newValue</var>, <var class="Fa" style="white-space: nowrap;">volatile
    int32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwap32Barrier</code>(<var class="Fa" style="white-space: nowrap;">int32_t
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">int32_t
    newValue</var>, <var class="Fa" style="white-space: nowrap;">volatile
    int32_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwap64</code>(<var class="Fa" style="white-space: nowrap;">int64_t
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">int64_t
    newValue</var>, <var class="Fa" style="white-space: nowrap;">volatile
    OSAtomic_int64_aligned64_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicCompareAndSwap64Barrier</code>(<var class="Fa" style="white-space: nowrap;">int64_t
    oldValue</var>, <var class="Fa" style="white-space: nowrap;">int64_t
    newValue</var>, <var class="Fa" style="white-space: nowrap;">volatile
    OSAtomic_int64_aligned64_t *theValue</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicTestAndSet</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    n</var>, <var class="Fa" style="white-space: nowrap;">volatile void
    *theAddress</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicTestAndSetBarrier</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    n</var>, <var class="Fa" style="white-space: nowrap;">volatile void
    *theAddress</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicTestAndClear</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    n</var>, <var class="Fa" style="white-space: nowrap;">volatile void
    *theAddress</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicTestAndClearBarrier</code>(<var class="Fa" style="white-space: nowrap;">uint32_t
    n</var>, <var class="Fa" style="white-space: nowrap;">volatile void
    *theAddress</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">OSAtomicEnqueue</code>(<var class="Fa" style="white-space: nowrap;">OSQueueHead
    *list</var>, <var class="Fa" style="white-space: nowrap;">void *new</var>,
    <var class="Fa" style="white-space: nowrap;">size_t offset</var>);</p>
<p class="Pp"><var class="Ft">void*</var>
  <br/>
  <code class="Fn">OSAtomicDequeue</code>(<var class="Fa" style="white-space: nowrap;">OSQueueHead
    *list</var>, <var class="Fa" style="white-space: nowrap;">size_t
    offset</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">OSMemoryBarrier</code>(<var class="Fa" style="white-space: nowrap;">void</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<div class="Bf Sy">These are deprecated interfaces for atomic and
  synchronization operations, provided for compatibility with legacy code. New
  code should use the C11
  <code class="In">&lt;<a class="In">stdatomic.h</a>&gt;</code> interfaces
  described in <a class="Xr">stdatomic(3)</a>.</div>
<p class="Pp">These functions are thread and multiprocessor safe. For each
    function, there is a version which incorporates a memory barrier and another
    version which does not. Barriers strictly order memory access on a
    weakly-ordered architecture such as ARM. All loads and stores executed in
    sequential program order before the barrier will complete before any load or
    store executed after the barrier. On some platforms, such as ARM, the
    barrier operation can be quite expensive.</p>
<p class="Pp">Most code will want to use the barrier functions to ensure that
    memory shared between threads is properly synchronized. For example, if you
    want to initialize a shared data structure and then atomically increment a
    variable to indicate that the initialization is complete, then you must use
    <code class="Fn">OSAtomicIncrement32Barrier</code>() to ensure that the
    stores to your data structure complete before the atomic add. Likewise, the
    consumer of that data structure must use
    <code class="Fn">OSAtomicDecrement32Barrier</code>(), in order to ensure
    that their loads of the structure are not executed before the atomic
    decrement. On the other hand, if you are simply incrementing a global
    counter, then it is safe and potentially much faster to use
    <code class="Fn">OSAtomicIncrement32</code>(). If you are unsure which
    version to use, prefer the barrier variants as they are safer.</p>
<p class="Pp">The logical (and, or, xor) and bit test operations are layered on
    top of the <code class="Fn">OSAtomicCompareAndSwap</code>() primitives.
    There are four versions of each logical operation, depending on whether or
    not there is a barrier, and whether the return value is the result of the
    operation (eg, <code class="Fn">OSAtomicOr32</code>() ) or the original
    value before the operation (eg, <code class="Fn">OSAtomicOr32Orig</code>()
    ).</p>
<p class="Pp">The memory address <var class="Fa">theValue</var> must be
    &quot;naturally aligned&quot;, i.e. 32-bit aligned for 32-bit operations and
    64-bit aligned for 64-bit operations. Note that this is not the default
    alignment of the <var class="Vt">int64_t</var> in the iOS ARMv7 ABI, the
    <var class="Vt">OSAtomic_int64_aligned64_t</var> type can be used to declare
    variables with the required alignment.</p>
<p class="Pp">The <code class="Fn">OSAtomicCompareAndSwap</code>() operations
    compare <var class="Fa">oldValue</var> to <var class="Fa">*theValue</var>,
    and set <var class="Fa">*theValue</var> to <var class="Fa">newValue</var> if
    the comparison is equal. The comparison and assignment occur as one atomic
    operation.</p>
<p class="Pp"><code class="Fn">OSAtomicTestAndSet</code>() and
    <code class="Fn">OSAtomicTestAndClear</code>() operate on bit (0x80 &gt;&gt;
    ( <var class="Fa">n</var> &amp; 7)) of byte ((char*)
    <var class="Fa">theAddress</var> + ( <var class="Fa">n</var> &gt;&gt; 3)).
    They set the named bit to either 1 or 0, respectively.
    <var class="Fa">theAddress</var> need not be aligned.</p>
<p class="Pp">The <code class="Fn">OSMemoryBarrier</code>() function strictly
    orders memory accesses in a weakly ordered memory model such as with ARM, by
    creating a barrier. All loads and stores executed in sequential program
    order before the barrier will complete with respect to the memory coherence
    mechanism, before any load or store executed after the barrier. Used with an
    atomic operation, the barrier can be used to create custom synchronization
    protocols as an alternative to the spinlock or queue/dequeue operations.
    Note that this barrier does not order uncached loads and stores. On a
    uniprocessor, the barrier operation is typically optimized into a no-op.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
The arithmetic operations return the new value, after the operation has been
  performed. The boolean operations come in two styles, one of which returns the
  new value, and one of which (the &quot;Orig&quot; versions) returns the old.
  The compare-and-swap operations return true if the comparison was equal, ie if
  the swap occured. The bit test and set/clear operations return the original
  value of the bit.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<a class="Xr">stdatomic(3)</a>, <a class="Xr">atomic(3)</a>,
  <a class="Xr">spinlock_deprecated(3)</a>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
Most of these functions first appeared in Mac OS 10.4 (Tiger). The
  &quot;Orig&quot; forms of the boolean operations, the &quot;int&quot;,
  &quot;long&quot; and &quot;ptr&quot; forms of compare-and-swap first appeared
  in Mac OS 10.5 (Leopard).
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">March 7, 2016</td>
    <td class="foot-os">Darwin</td>
  </tr>
</table>
</body>
</html>
