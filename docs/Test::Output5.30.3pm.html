<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Test::Output(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Test::Output(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Test::Output(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Test::Output - Utilities to test STDOUT and STDERR messages.
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
    use Test::More tests =&gt; 4;
    use Test::Output;

    sub writer {
      print &quot;Write out.\n&quot;;
      print STDERR &quot;Error out.\n&quot;;
    }

    stdout_is(\&amp;writer,&quot;Write out.\n&quot;,'Test STDOUT');

    stderr_isnt(\&amp;writer,&quot;No error out.\n&quot;,'Test STDERR');

    combined_is(
                \&amp;writer,
                &quot;Write out.\nError out.\n&quot;,
                'Test STDOUT &amp; STDERR combined'
               );

    output_is(
              \&amp;writer,
              &quot;Write out.\n&quot;,
              &quot;Error out.\n&quot;,
              'Test STDOUT &amp; STDERR'
            );

   # Use bare blocks.

   stdout_is { print &quot;test&quot; } &quot;test&quot;, &quot;Test STDOUT&quot;;
   stderr_isnt { print &quot;bad test&quot; } &quot;test&quot;, &quot;Test STDERR&quot;;
   output_is { print 'STDOUT'; print STDERR 'STDERR' }
     &quot;STDOUT&quot;, &quot;STDERR&quot;, &quot;Test output&quot;;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Test::Output provides a simple interface for testing output sent to
  <span class="Li">&quot;STDOUT&quot;</span> or
  <span class="Li">&quot;STDERR&quot;</span>. A number of different utilities
  are included to try and be as flexible as possible to the tester.
<p class="Pp">Likewise, Capture::Tiny provides a much more robust capture
    mechanism without than the original Test::Output::Tie.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="TESTS"><a class="permalink" href="#TESTS">TESTS</a></h1>
<section class="Ss">
<h2 class="Ss" id="_s-1STDOUT_s0"><a class="permalink" href="#_s-1STDOUT_s0">STDOUT</a></h2>
<dl class="Bl-tag">
  <dt><b>stdout_is</b></dt>
  <dd></dd>
  <dt><b>stdout_isnt</b></dt>
  <dd><span class="Li"></span>
    <pre>
   stdout_is  ( $coderef, $expected, 'description' );
   stdout_is    { ... } $expected, 'description';
   stdout_isnt( $coderef, $expected, 'description' );
   stdout_isnt  { ... } $expected, 'description';
    </pre>
    <p class="Pp"><span class="Li">&quot;stdout_is()&quot;</span> captures
        output sent to <span class="Li">&quot;STDOUT&quot;</span> from
        <span class="Li">$coderef</span> and compares it against
        <span class="Li">$expected</span>. The test passes if equal.</p>
    <p class="Pp"><span class="Li">&quot;stdout_isnt()&quot;</span> passes if
        <span class="Li">&quot;STDOUT&quot;</span> is not equal to
        <span class="Li">$expected</span>.</p>
  </dd>
  <dt><b>stdout_like</b></dt>
  <dd></dd>
  <dt><b>stdout_unlike</b></dt>
  <dd><span class="Li"></span>
    <pre>
   stdout_like  ( $coderef, qr/$expected/, 'description' );
   stdout_like    { ... } qr/$expected/, 'description';
   stdout_unlike( $coderef, qr/$expected/, 'description' );
   stdout_unlike  { ... } qr/$expected/, 'description';
    </pre>
    <p class="Pp"><span class="Li">&quot;stdout_like()&quot;</span> captures the
        output sent to <span class="Li">&quot;STDOUT&quot;</span> from
        <span class="Li">$coderef</span> and compares it to the regex in
        <span class="Li">$expected</span>. The test passes if the regex
      matches.</p>
    <p class="Pp"><span class="Li">&quot;stdout_unlike()&quot;</span> passes if
        STDOUT does not match the regex.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1STDERR_s0"><a class="permalink" href="#_s-1STDERR_s0">STDERR</a></h2>
<dl class="Bl-tag">
  <dt><b>stderr_is</b></dt>
  <dd></dd>
  <dt><b>stderr_isnt</b></dt>
  <dd><span class="Li"></span>
    <pre>
   stderr_is  ( $coderef, $expected, 'description' );
   stderr_is    {... } $expected, 'description';

   stderr_isnt( $coderef, $expected, 'description' );
   stderr_isnt  {... } $expected, 'description';
    </pre>
    <p class="Pp"><span class="Li">&quot;stderr_is()&quot;</span> is similar to
        <span class="Li">&quot;stdout_is&quot;</span>, except that it captures
        <span class="Li">&quot;STDERR&quot;</span>. The test passes if
        <span class="Li">&quot;STDERR&quot;</span> from
        <span class="Li">$coderef</span> equals
        <span class="Li">$expected</span>.</p>
    <p class="Pp"><span class="Li">&quot;stderr_isnt()&quot;</span> passes if
        <span class="Li">&quot;STDERR&quot;</span> is not equal to
        <span class="Li">$expected</span>.</p>
  </dd>
  <dt><b>stderr_like</b></dt>
  <dd></dd>
  <dt><b>stderr_unlike</b></dt>
  <dd><span class="Li"></span>
    <pre>
   stderr_like  ( $coderef, qr/$expected/, 'description' );
   stderr_like   { ...} qr/$expected/, 'description';
   stderr_unlike( $coderef, qr/$expected/, 'description' );
   stderr_unlike  { ...} qr/$expected/, 'description';
    </pre>
    <p class="Pp"><span class="Li">&quot;stderr_like()&quot;</span> is similar
        to <span class="Li">&quot;stdout_like()&quot;</span> except that it
        compares the regex <span class="Li">$expected</span> to
        <span class="Li">&quot;STDERR&quot;</span> captured from
        <span class="Li">$codref</span>. The test passes if the regex
      matches.</p>
    <p class="Pp"><span class="Li">&quot;stderr_unlike()&quot;</span> passes if
        <span class="Li">&quot;STDERR&quot;</span> does not match the regex.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1COMBINED_OUTPUT_s0"><a class="permalink" href="#_s-1COMBINED_OUTPUT_s0">COMBINED
  OUTPUT</a></h2>
<dl class="Bl-tag">
  <dt><b>combined_is</b></dt>
  <dd></dd>
  <dt><b>combined_isnt</b></dt>
  <dd><span class="Li"></span>
    <pre>
   combined_is   ( $coderef, $expected, 'description' );
   combined_is   {... } $expected, 'description';
   combined_isnt ( $coderef, $expected, 'description' );
   combined_isnt {... } $expected, 'description';
    </pre>
    <p class="Pp"><span class="Li">&quot;combined_is()&quot;</span> directs
        <span class="Li">&quot;STDERR&quot;</span> to
        <span class="Li">&quot;STDOUT&quot;</span> then captures
        <span class="Li">&quot;STDOUT&quot;</span>. This is equivalent to UNIXs
        <span class="Li">&quot;2&gt;&amp;1&quot;</span>. The test passes if the
        combined <span class="Li">&quot;STDOUT&quot;</span> and
        <span class="Li">&quot;STDERR&quot;</span> from
        <span class="Li">$coderef</span> equals
        <span class="Li">$expected</span>.</p>
    <p class="Pp"><span class="Li">&quot;combined_isnt()&quot;</span> passes if
        combined <span class="Li">&quot;STDOUT&quot;</span> and
        <span class="Li">&quot;STDERR&quot;</span> are not equal to
        <span class="Li">$expected</span>.</p>
  </dd>
  <dt><b>combined_like</b></dt>
  <dd></dd>
  <dt><b>combined_unlike</b></dt>
  <dd><span class="Li"></span>
    <pre>
   combined_like   ( $coderef, qr/$expected/, 'description' );
   combined_like   { ...} qr/$expected/, 'description';
   combined_unlike ( $coderef, qr/$expected/, 'description' );
   combined_unlike { ...} qr/$expected/, 'description';
    </pre>
    <p class="Pp"><span class="Li">&quot;combined_like()&quot;</span> is similar
        to <span class="Li">&quot;combined_is()&quot;</span> except that it
        compares a regex (<span class="Li">&quot;$expected)&quot;</span> to
        <span class="Li">&quot;STDOUT&quot;</span> and
        <span class="Li">&quot;STDERR&quot;</span> captured from
        <span class="Li">$codref</span>. The test passes if the regex
      matches.</p>
    <p class="Pp"><span class="Li">&quot;combined_unlike()&quot;</span> passes
        if the combined <span class="Li">&quot;STDOUT&quot;</span> and
        <span class="Li">&quot;STDERR&quot;</span> does not match the regex.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1OUTPUT_s0"><a class="permalink" href="#_s-1OUTPUT_s0">OUTPUT</a></h2>
<dl class="Bl-tag">
  <dt><b>output_is</b></dt>
  <dd></dd>
  <dt><b>output_isnt</b></dt>
  <dd><span class="Li"></span>
    <pre>
   output_is  ( $coderef, $expected_stdout, $expected_stderr, 'description' );
   output_is    {... } $expected_stdout, $expected_stderr, 'description';
   output_isnt( $coderef, $expected_stdout, $expected_stderr, 'description' );
   output_isnt  {... } $expected_stdout, $expected_stderr, 'description';
    </pre>
    <p class="Pp">The <span class="Li">&quot;output_is()&quot;</span> function
        is a combination of the <span class="Li">&quot;stdout_is()&quot;</span>
        and <span class="Li">&quot;stderr_is()&quot;</span> functions. For
        example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  output_is(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},'foo','bar');
    </pre>
    <p class="Pp">is functionally equivalent to</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  stdout_is(sub {print &quot;foo&quot;;},'foo')
    &amp;&amp; stderr_is(sub {print STDERR &quot;bar&quot;;'bar');
    </pre>
    <p class="Pp">except that <span class="Li">$coderef</span> is only executed
        once.</p>
    <p class="Pp">Unlike <span class="Li">&quot;stdout_is()&quot;</span> and
        <span class="Li">&quot;stderr_is()&quot;</span> which ignore STDERR and
        STDOUT respectively, <span class="Li">&quot;output_is()&quot;</span>
        requires both <span class="Li">&quot;STDOUT&quot;</span> and
        <span class="Li">&quot;STDERR&quot;</span> to match in order to pass.
        Setting either <span class="Li">$expected_stdout</span> or
        <span class="Li">$expected_stderr</span> to
        <span class="Li">&quot;undef&quot;</span> ignores
        <span class="Li">&quot;STDOUT&quot;</span> or
        <span class="Li">&quot;STDERR&quot;</span> respectively.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  output_is(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},'foo',undef);
    </pre>
    <p class="Pp">is the same as</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  stdout_is(sub {print &quot;foo&quot;;},'foo')
    </pre>
    <p class="Pp"><span class="Li">&quot;output_isnt()&quot;</span> provides the
        opposite function of <span class="Li">&quot;output_is()&quot;</span>. It
        is a combination of <span class="Li">&quot;stdout_isnt()&quot;</span>
        and <span class="Li">&quot;stderr_isnt()&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  output_isnt(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},'bar','foo');
    </pre>
    <p class="Pp">is functionally equivalent to</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  stdout_is(sub {print &quot;foo&quot;;},'bar')
    &amp;&amp; stderr_is(sub {print STDERR &quot;bar&quot;;'foo');
    </pre>
    <p class="Pp">As with <span class="Li">&quot;output_is()&quot;</span>,
        setting either <span class="Li">$expected_stdout</span> or
        <span class="Li">$expected_stderr</span> to
        <span class="Li">&quot;undef&quot;</span> ignores the output to that
        facility.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  output_isnt(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},undef,'foo');
    </pre>
    <p class="Pp">is the same as</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  stderr_is(sub {print STDERR &quot;bar&quot;;},'foo')
    </pre>
  </dd>
  <dt><b>output_like</b></dt>
  <dd></dd>
  <dt><b>output_unlike</b></dt>
  <dd><span class="Li"></span>
    <pre>
  output_like  ( $coderef, $regex_stdout, $regex_stderr, 'description' );
  output_like  { ... } $regex_stdout, $regex_stderr, 'description';
  output_unlike( $coderef, $regex_stdout, $regex_stderr, 'description' );
  output_unlike { ... } $regex_stdout, $regex_stderr, 'description';
    </pre>
    <p class="Pp"><span class="Li">&quot;output_like()&quot;</span> and
        <span class="Li">&quot;output_unlike()&quot;</span> follow the same
        principles as <span class="Li">&quot;output_is()&quot;</span> and
        <span class="Li">&quot;output_isnt()&quot;</span> except they use a
        regular expression for matching.</p>
    <p class="Pp"><span class="Li">&quot;output_like()&quot;</span> attempts to
        match <span class="Li">$regex_stdout</span> and
        <span class="Li">$regex_stderr</span> against
        <span class="Li">&quot;STDOUT&quot;</span> and
        <span class="Li">&quot;STDERR&quot;</span> produced by
        <span class="Li">$coderef</span>. The test passes if both match.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  output_like(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},qr/foo/,qr/bar/);
    </pre>
    <p class="Pp">The above test is successful.</p>
    <p class="Pp">Like <span class="Li">&quot;output_is()&quot;</span>, setting
        either <span class="Li">$regex_stdout</span> or
        <span class="Li">$regex_stderr</span> to
        <span class="Li">&quot;undef&quot;</span> ignores the output to that
        facility.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  output_like(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},qr/foo/,undef);
    </pre>
    <p class="Pp">is the same as</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  stdout_like(sub {print &quot;foo&quot;; print STDERR &quot;bar&quot;;},qr/foo/);
    </pre>
    <p class="Pp"><span class="Li">&quot;output_unlike()&quot;</span> test pass
        if output from <span class="Li">$coderef</span> doesn't match
        <span class="Li">$regex_stdout</span> and
        <span class="Li">$regex_stderr</span>.</p>
  </dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXPORTS"><a class="permalink" href="#EXPORTS">EXPORTS</a></h1>
By default, all subroutines are exported by default.
<ul class="Bl-bullet">
  <li>:stdout - the subs with <span class="Li">&quot;stdout&quot;</span> in the
      name.</li>
  <li>:stderr - the subs with <span class="Li">&quot;stderr&quot;</span> in the
      name.</li>
  <li>:functions - the subs with <span class="Li">&quot;_from&quot;</span> at
      the end.</li>
  <li>:output - the subs with <span class="Li">&quot;output&quot;</span> in the
      name.</li>
  <li>:combined - the subs with <span class="Li">&quot;combined&quot;</span> in
      the name.</li>
  <li>:tests - everything that outputs TAP</li>
  <li>:all - everything (which is the same as the default)</li>
</ul>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<section class="Ss">
<h2 class="Ss" id="stdout_from"><a class="permalink" href="#stdout_from">stdout_from</a></h2>
<span class="Li"></span>
<pre>
  my $stdout = stdout_from($coderef)
  my $stdout = stdout_from { ... };
</pre>
<p class="Pp"><b>stdout_from()</b> executes <span class="Li">$coderef</span> and
    captures STDOUT.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="stderr_from"><a class="permalink" href="#stderr_from">stderr_from</a></h2>
<span class="Li"></span>
<pre>
  my $stderr = stderr_from($coderef)
  my $stderr = stderr_from { ... };
</pre>
<p class="Pp"><span class="Li">&quot;stderr_from()&quot;</span> executes
    <span class="Li">$coderef</span> and captures
    <span class="Li">&quot;STDERR&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="output_from"><a class="permalink" href="#output_from">output_from</a></h2>
<span class="Li"></span>
<pre>
  my ($stdout, $stderr) = output_from($coderef)
  my ($stdout, $stderr) = output_from {...};
</pre>
<p class="Pp"><span class="Li">&quot;output_from()&quot;</span> executes
    <span class="Li">$coderef</span> one time capturing both
    <span class="Li">&quot;STDOUT&quot;</span> and
    <span class="Li">&quot;STDERR&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="combined_from"><a class="permalink" href="#combined_from">combined_from</a></h2>
<span class="Li"></span>
<pre>
  my $combined = combined_from($coderef);
  my $combined = combined_from {...};
</pre>
<p class="Pp"><span class="Li">&quot;combined_from()&quot;</span> executes
    <span class="Li">$coderef</span> one time combines
    <span class="Li">&quot;STDOUT&quot;</span> and
    <span class="Li">&quot;STDERR&quot;</span>, and captures them.
    <span class="Li">&quot;combined_from()&quot;</span> is equivalent to using
    <span class="Li">&quot;2&gt;&amp;1&quot;</span> in UNIX.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Currently maintained by brian d foy,
  <span class="Li">&quot;bdfoy@cpan.org&quot;</span>.
<p class="Pp">Shawn Sorichetti,
    <span class="Li">&quot;&lt;ssoriche@cpan.org&gt;&quot;</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SOURCE_AVAILABILITY"><a class="permalink" href="#SOURCE_AVAILABILITY">SOURCE
  AVAILABILITY</a></h1>
This module is in Github:
<p class="Pp"><span class="Li"></span></p>
<pre>
        http://github.com/briandfoy/test-output/tree/master
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
Please report any bugs or feature requests to
  <span class="Li">&quot;bug-test-output@rt.cpan.org&quot;</span>, or through
  the web interface at &lt;http://rt.cpan.org&gt;. I will be notified, and then
  you'll automatically be notified of progress on your bug as I make changes.
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
Thanks to chromatic whose TieOut.pm was the basis for capturing output.
<p class="Pp">Also thanks to rjbs for his help cleaning the documentation, and
    pushing me to Sub::Exporter. (This feature has been removed since it uses
    none of Sub::Exporter's strengths).</p>
<p class="Pp">Thanks to David Wheeler for providing code block support and
    tests.</p>
<p class="Pp">Thanks to Michael G Schwern for the solution to combining
    <span class="Li">&quot;STDOUT&quot;</span> and
    <span class="Li">&quot;STDERR&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_&amp;_LICENSE"><a class="permalink" href="#COPYRIGHT_&amp;_LICENSE">COPYRIGHT
  &amp; LICENSE</a></h1>
Copyright 2005-2013 Shawn Sorichetti, All Rights Reserved.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2017-03-29</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
