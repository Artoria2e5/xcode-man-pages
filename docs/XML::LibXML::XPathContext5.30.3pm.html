<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>XML::LibXML::XPathContext(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XML::LibXML::XPathContext(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">XML::LibXML::XPathContext(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
XML::LibXML::XPathContext - XPath Evaluation
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  my $xpc = XML::LibXML::XPathContext-&gt;new();
  my $xpc = XML::LibXML::XPathContext-&gt;new($node);
  $xpc-&gt;registerNs($prefix, $namespace_uri)
  $xpc-&gt;unregisterNs($prefix)
  $uri = $xpc-&gt;lookupNs($prefix)
  $xpc-&gt;registerVarLookupFunc($callback, $data)
  $data = $xpc-&gt;getVarLookupData();
  $callback = $xpc-&gt;getVarLookupFunc();
  $xpc-&gt;unregisterVarLookupFunc($name);
  $xpc-&gt;registerFunctionNS($name, $uri, $callback)
  $xpc-&gt;unregisterFunctionNS($name, $uri)
  $xpc-&gt;registerFunction($name, $callback)
  $xpc-&gt;unregisterFunction($name)
  @nodes = $xpc-&gt;findnodes($xpath)
  @nodes = $xpc-&gt;findnodes($xpath, $context_node )
  $nodelist = $xpc-&gt;findnodes($xpath, $context_node )
  $object = $xpc-&gt;find($xpath )
  $object = $xpc-&gt;find($xpath, $context_node )
  $value = $xpc-&gt;findvalue($xpath )
  $value = $xpc-&gt;findvalue($xpath, $context_node )
  $bool = $xpc-&gt;exists( $xpath_expression, $context_node );
  $xpc-&gt;setContextNode($node)
  my $node = $xpc-&gt;getContextNode;
  $xpc-&gt;setContextPosition($position)
  my $position = $xpc-&gt;getContextPosition;
  $xpc-&gt;setContextSize($size)
  my $size = $xpc-&gt;getContextSize;
  $xpc-&gt;setContextNode($node)
The XML::LibXML::XPathContext class provides an almost complete interface to
libxml2's XPath implementation. With XML::LibXML::XPathContext, it is possible
to evaluate XPath expressions in the context of arbitrary node, context size,
and context position, with a user-defined namespace-prefix mapping, custom
XPath functions written in Perl, and even a custom XPath variable resolver.
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<section class="Ss">
<h2 class="Ss" id="Namespaces"><a class="permalink" href="#Namespaces">Namespaces</a></h2>
This example demonstrates <span class="Li">&quot;registerNs()&quot;</span>
  method. It finds all paragraph nodes in an XHTML document.
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $xc = XML::LibXML::XPathContext-&gt;new($xhtml_doc);
  $xc-&gt;registerNs('xhtml', 'http://www.w3.org/1999/xhtml');
  my @nodes = $xc-&gt;findnodes('//xhtml:p');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Custom_XPath_functions"><a class="permalink" href="#Custom_XPath_functions">Custom
  XPath functions</a></h2>
This example demonstrates <span class="Li">&quot;registerFunction()&quot;</span>
  method by defining a function filtering nodes based on a Perl regular
  expression:
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub grep_nodes {
    my ($nodelist,$regexp) =  @_;
    my $result = XML::LibXML::NodeList-&gt;new;
    for my $node ($nodelist-&gt;get_nodelist()) {
      $result-&gt;push($node) if $node-&gt;textContent =~ $regexp;
    }
    return $result;
  };

  my $xc = XML::LibXML::XPathContext-&gt;new($node);
  $xc-&gt;registerFunction('grep_nodes', \&amp;grep_nodes);
  my @nodes = $xc-&gt;findnodes('//section[grep_nodes(para,&quot;\bsearch(ing|es)?\b&quot;)]');
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Variables"><a class="permalink" href="#Variables">Variables</a></h2>
This example demonstrates
  <span class="Li">&quot;registerVarLookup()&quot;</span> method. We use XPath
  variables to recycle results of previous evaluations:
<p class="Pp"><span class="Li"></span></p>
<pre>
  sub var_lookup {
    my ($varname,$ns,$data)=@_;
    return $data-&gt;{$varname};
  }

  my $areas = XML::LibXML-&gt;new-&gt;parse_file('areas.xml');
  my $empl = XML::LibXML-&gt;new-&gt;parse_file('employees.xml');

  my $xc = XML::LibXML::XPathContext-&gt;new($empl);

  my %variables = (
    A =&gt; $xc-&gt;find('/employees/employee[@salary&gt;10000]'),
    B =&gt; $areas-&gt;find('/areas/area[district='Brooklyn']/street'),
  );

  # get names of employees from $A working in an area listed in $B
  $xc-&gt;registerVarLookupFunc(\&amp;var_lookup, \%variables);
  my @nodes = $xc-&gt;findnodes('$A[work_area/street = $B]/name');
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<dl class="Bl-tag">
  <dt>new</dt>
  <dd><span class="Li"></span>
    <pre>
  my $xpc = XML::LibXML::XPathContext-&gt;new();
    </pre>
    <p class="Pp">Creates a new XML::LibXML::XPathContext object without a
        context node.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $xpc = XML::LibXML::XPathContext-&gt;new($node);
    </pre>
    <p class="Pp">Creates a new XML::LibXML::XPathContext object with the
        context node set to <span class="Li">$node</span>.</p>
  </dd>
  <dt>registerNs</dt>
  <dd><span class="Li"></span>
    <pre>
  $xpc-&gt;registerNs($prefix, $namespace_uri)
    </pre>
    <p class="Pp">Registers namespace <span class="Li">$prefix</span> to
        <span class="Li">$namespace_uri</span>.</p>
  </dd>
  <dt>unregisterNs</dt>
  <dd><span class="Li"></span>
    <pre>
  $xpc-&gt;unregisterNs($prefix)
    </pre>
    <p class="Pp">Unregisters namespace <span class="Li">$prefix</span>.</p>
  </dd>
  <dt>lookupNs</dt>
  <dd><span class="Li"></span>
    <pre>
  $uri = $xpc-&gt;lookupNs($prefix)
    </pre>
    <p class="Pp">Returns namespace URI registered with
        <span class="Li">$prefix</span>. If <span class="Li">$prefix</span> is
        not registered to any namespace URI returns
        <span class="Li">&quot;undef&quot;</span>.</p>
  </dd>
  <dt>registerVarLookupFunc</dt>
  <dd><span class="Li"></span>
    <pre>
  $xpc-&gt;registerVarLookupFunc($callback, $data)
    </pre>
    <p class="Pp">Registers variable lookup function
        <span class="Li">$prefix</span>. The registered function is executed by
        the XPath engine each time an XPath variable is evaluated. It takes
        three arguments: <span class="Li">$data</span>, variable name, and
        variable ns-URI and must return one value: a number or string or any
        <span class="Li">&quot;XML::LibXML::&quot;</span> object that can be a
        result of findnodes: Boolean, Literal, Number, Node (e.g. Document,
        Element, etc.), or NodeList. For convenience, simple (non-blessed) array
        references containing only XML::LibXML::Node objects can be used instead
        of an XML::LibXML::NodeList.</p>
  </dd>
  <dt>getVarLookupData</dt>
  <dd><span class="Li"></span>
    <pre>
  $data = $xpc-&gt;getVarLookupData();
    </pre>
    <p class="Pp">Returns the data that have been associated with a variable
        lookup function during a previous call to
        <span class="Li">&quot;registerVarLookupFunc&quot;</span>.</p>
  </dd>
  <dt>getVarLookupFunc</dt>
  <dd><span class="Li"></span>
    <pre>
  $callback = $xpc-&gt;getVarLookupFunc();
    </pre>
    <p class="Pp">Returns the variable lookup function previously registered
        with <span class="Li">&quot;registerVarLookupFunc&quot;</span>.</p>
  </dd>
  <dt>unregisterVarLookupFunc</dt>
  <dd><span class="Li"></span>
    <pre>
  $xpc-&gt;unregisterVarLookupFunc($name);
    </pre>
    <p class="Pp">Unregisters variable lookup function and the associated lookup
        data.</p>
  </dd>
  <dt>registerFunctionNS</dt>
  <dd><span class="Li"></span>
    <pre>
  $xpc-&gt;registerFunctionNS($name, $uri, $callback)
    </pre>
    <p class="Pp">Registers an extension function <span class="Li">$name</span>
        in <span class="Li">$uri</span> namespace.
        <span class="Li">$callback</span> must be a CODE reference. The
        arguments of the callback function are either simple scalars or
        <span class="Li">&quot;XML::LibXML::*&quot;</span> objects depending on
        the XPath argument types. The function is responsible for checking the
        argument number and types. Result of the callback code must be a single
        value of the following types: a simple scalar (number, string) or an
        arbitrary <span class="Li">&quot;XML::LibXML::*&quot;</span> object that
        can be a result of findnodes: Boolean, Literal, Number, Node (e.g.
        Document, Element, etc.), or NodeList. For convenience, simple
        (non-blessed) array references containing only XML::LibXML::Node objects
        can be used instead of a XML::LibXML::NodeList.</p>
  </dd>
  <dt>unregisterFunctionNS</dt>
  <dd><span class="Li"></span>
    <pre>
  $xpc-&gt;unregisterFunctionNS($name, $uri)
    </pre>
    <p class="Pp">Unregisters extension function <span class="Li">$name</span>
        in <span class="Li">$uri</span> namespace. Has the same effect as
        passing <span class="Li">&quot;undef&quot;</span> as
        <span class="Li">$callback</span> to registerFunctionNS.</p>
  </dd>
  <dt>registerFunction</dt>
  <dd><span class="Li"></span>
    <pre>
  $xpc-&gt;registerFunction($name, $callback)
    </pre>
    <p class="Pp">Same as <span class="Li">&quot;registerFunctionNS&quot;</span>
        but without a namespace.</p>
  </dd>
  <dt>unregisterFunction</dt>
  <dd><span class="Li"></span>
    <pre>
  $xpc-&gt;unregisterFunction($name)
    </pre>
    <p class="Pp">Same as
        <span class="Li">&quot;unregisterFunctionNS&quot;</span> but without a
        namespace.</p>
  </dd>
  <dt>findnodes</dt>
  <dd><span class="Li"></span>
    <pre>
  @nodes = $xpc-&gt;findnodes($xpath)

  @nodes = $xpc-&gt;findnodes($xpath, $context_node )

  $nodelist = $xpc-&gt;findnodes($xpath, $context_node )
    </pre>
    <p class="Pp">Performs the xpath statement on the current node and returns
        the result as an array. In scalar context, returns an
        XML::LibXML::NodeList object. Optionally, a node may be passed as a
        second argument to set the context node for the query.</p>
    <p class="Pp">The xpath expression can be passed either as a string, or as a
        XML::LibXML::XPathExpression object.</p>
  </dd>
  <dt>find</dt>
  <dd><span class="Li"></span>
    <pre>
  $object = $xpc-&gt;find($xpath )

  $object = $xpc-&gt;find($xpath, $context_node )
    </pre>
    <p class="Pp">Performs the xpath expression using the current node as the
        context of the expression, and returns the result depending on what type
        of result the XPath expression had. For example, the XPath
        <span class="Li">&quot;1 * 3 + 	 52&quot;</span> results in an
        XML::LibXML::Number object being returned. Other expressions might
        return a XML::LibXML::Boolean object, or a XML::LibXML::Literal object
        (a string). Each of those objects uses Perl's overload feature to ``do
        the right thing'' in different contexts. Optionally, a node may be
        passed as a second argument to set the context node for the query.</p>
    <p class="Pp">The xpath expression can be passed either as a string, or as a
        XML::LibXML::XPathExpression object.</p>
  </dd>
  <dt>findvalue</dt>
  <dd><span class="Li"></span>
    <pre>
  $value = $xpc-&gt;findvalue($xpath )

  $value = $xpc-&gt;findvalue($xpath, $context_node )
    </pre>
    <p class="Pp">Is exactly equivalent to:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $xpc-&gt;find( $xpath, $context_node )-&gt;to_literal;
    </pre>
    <p class="Pp">That is, it returns the literal value of the results. This
        enables you to ensure that you get a string back from your search,
        allowing certain shortcuts. This could be used as the equivalent of
        &lt;xsl:value-of select=``some_xpath''/&gt;. Optionally, a node may be
        passed in the second argument to set the context node for the query.</p>
    <p class="Pp">The xpath expression can be passed either as a string, or as a
        XML::LibXML::XPathExpression object.</p>
  </dd>
  <dt>exists</dt>
  <dd><span class="Li"></span>
    <pre>
  $bool = $xpc-&gt;exists( $xpath_expression, $context_node );
    </pre>
    <p class="Pp">This method behaves like <i>findnodes</i>, except that it only
        returns a boolean value (1 if the expression matches a node, 0
        otherwise) and may be faster than <i>findnodes</i>, because the XPath
        evaluation may stop early on the first match (this is true for libxml2
        &gt;= 2.6.27).</p>
    <p class="Pp">For XPath expressions that do not return node-set, the method
        returns true if the returned value is a non-zero number or a non-empty
        string.</p>
  </dd>
  <dt>setContextNode</dt>
  <dd><span class="Li"></span>
    <pre>
  $xpc-&gt;setContextNode($node)
    </pre>
    <p class="Pp">Set the current context node.</p>
  </dd>
  <dt>getContextNode</dt>
  <dd><span class="Li"></span>
    <pre>
  my $node = $xpc-&gt;getContextNode;
    </pre>
    <p class="Pp">Get the current context node.</p>
  </dd>
  <dt>setContextPosition</dt>
  <dd><span class="Li"></span>
    <pre>
  $xpc-&gt;setContextPosition($position)
    </pre>
    <p class="Pp">Set the current context position. By default, this value is -1
        (and evaluating XPath function
        <span class="Li">&quot;position()&quot;</span> in the initial context
        raises an XPath error), but can be set to any value up to context size.
        This usually only serves to cheat the XPath engine to return given
        position when <span class="Li">&quot;position()&quot;</span> XPath
        function is called. Setting this value to -1 restores the default
        behavior.</p>
  </dd>
  <dt>getContextPosition</dt>
  <dd><span class="Li"></span>
    <pre>
  my $position = $xpc-&gt;getContextPosition;
    </pre>
    <p class="Pp">Get the current context position.</p>
  </dd>
  <dt>setContextSize</dt>
  <dd><span class="Li"></span>
    <pre>
  $xpc-&gt;setContextSize($size)
    </pre>
    <p class="Pp">Set the current context size. By default, this value is -1
        (and evaluating XPath function
        <span class="Li">&quot;last()&quot;</span> in the initial context raises
        an XPath error), but can be set to any non-negative value. This usually
        only serves to cheat the XPath engine to return the given value when
        <span class="Li">&quot;last()&quot;</span> XPath function is called. If
        context size is set to 0, position is automatically also set to 0. If
        context size is positive, position is automatically set to 1. Setting
        context size to -1 restores the default behavior.</p>
  </dd>
  <dt>getContextSize</dt>
  <dd><span class="Li"></span>
    <pre>
  my $size = $xpc-&gt;getContextSize;
    </pre>
    <p class="Pp">Get the current context size.</p>
  </dd>
  <dt>setContextNode</dt>
  <dd><span class="Li"></span>
    <pre>
  $xpc-&gt;setContextNode($node)
    </pre>
    <p class="Pp">Set the current context node.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS_AND_CAVEATS"><a class="permalink" href="#BUGS_AND_CAVEATS">BUGS
  AND CAVEATS</a></h1>
XML::LibXML::XPathContext objects <i>are</i> reentrant, meaning that you can
  call methods of an XML::LibXML::XPathContext even from XPath extension
  functions registered with the same object or from a variable lookup function.
  On the other hand, you should rather avoid registering new extension
  functions, namespaces and a variable lookup function from within extension
  functions and a variable lookup function, unless you want to experience
  untested behavior.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Ilya Martynov and Petr Pajas, based on XML::LibXML and XML::LibXSLT code by Matt
  Sergeant and Christian Glahn.
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORICAL_REMARK"><a class="permalink" href="#HISTORICAL_REMARK">HISTORICAL
  REMARK</a></h1>
Prior to XML::LibXML 1.61 this module was distributed separately for maintenance
  reasons.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS_2"><a class="permalink" href="#AUTHORS_2">AUTHORS</a></h1>
Matt Sergeant, Christian Glahn, Petr Pajas
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
2.0110
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
2001-2007, AxKit.com Ltd.
<p class="Pp">2002-2006, Christian Glahn.</p>
<p class="Pp">2006-2009, Petr Pajas.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-02-01</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
