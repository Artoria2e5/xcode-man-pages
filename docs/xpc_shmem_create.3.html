<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2011, 2016 Apple Inc. All rights reserved.
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>xpc_objects(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">xpc_objects(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">xpc_objects(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<code class="Nm">xpc_objects</code> &#x2014;
<div class="Nd">boxed XPC objects reference</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<code class="In">#include <a class="In">&lt;xpc/xpc.h&gt;</a></code>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_null_create</code>(<var class="Fa">void</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_bool_create</code>(<var class="Fa">bool value</var>);</p>
<p class="Pp"><var class="Ft">bool</var>
  <br/>
  <code class="Fn">xpc_bool_get_value</code>(<var class="Fa">xpc_object_t
    xbool</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_int64_create</code>(<var class="Fa">int64_t
  value</var>);</p>
<p class="Pp"><var class="Ft">int64_t</var>
  <br/>
  <code class="Fn">xpc_int64_get_value</code>(<var class="Fa">xpc_object_t
    xint</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_uint64_create</code>(<var class="Fa">uint64_t
    value</var>);</p>
<p class="Pp"><var class="Ft">uint64_t</var>
  <br/>
  <code class="Fn">xpc_uint64_get_value</code>(<var class="Fa">xpc_object_t
    xuint</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_double_create</code>(<var class="Fa">double
  value</var>);</p>
<p class="Pp"><var class="Ft">double</var>
  <br/>
  <code class="Fn">xpc_double_get_value</code>(<var class="Fa">xpc_object_t
    xdouble</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_date_create</code>(<var class="Fa">int64_t
    interval</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_date_create_from_current</code>(<var class="Fa">void</var>);</p>
<p class="Pp"><var class="Ft">int64_t</var>
  <br/>
  <code class="Fn">xpc_date_get_value</code>(<var class="Fa">xpc_object_t
    xdate</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_data_create</code>(<var class="Fa">const void
    *bytes</var>, <var class="Fa">size_t length</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_data_create_with_dispatch_data</code>(<var class="Fa">dispatch_data_t
    ddata</var>);</p>
<p class="Pp"><var class="Ft">size_t</var>
  <br/>
  <code class="Fn">xpc_data_get_length</code>(<var class="Fa">xpc_object_t
    xdata</var>);</p>
<p class="Pp"><var class="Ft">const void *</var>
  <br/>
  <code class="Fn">xpc_data_get_bytes_ptr</code>(<var class="Fa">xpc_object_t
    xdata</var>);</p>
<p class="Pp"><var class="Ft">size_t</var>
  <br/>
  <code class="Fn">xpc_data_get_bytes</code>(<var class="Fa">xpc_object_t
    xdata</var>, <var class="Fa">void *buffer</var>, <var class="Fa">size_t
    off</var>, <var class="Fa">size_t length</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_string_create</code>(<var class="Fa">const char
    *string</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_string_create_with_format</code>(<var class="Fa">const
    char *fmt</var>, <var class="Fa">...</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_string_create_with_format_and_arguments</code>(<var class="Fa">const
    char *fmt</var>, <var class="Fa">va_list ap</var>);</p>
<p class="Pp"><var class="Ft">size_t</var>
  <br/>
  <code class="Fn">xpc_string_get_length</code>(<var class="Fa">xpc_object_t
    xstring</var>);</p>
<p class="Pp"><var class="Ft">const char *</var>
  <br/>
  <code class="Fn">xpc_string_get_string_ptr</code>(<var class="Fa">xpc_object_t
    xstring</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_uuid_create</code>(<var class="Fa">const uuid_t
    uuid</var>);</p>
<p class="Pp"><var class="Ft">const uint8_t *</var>
  <br/>
  <code class="Fn">xpc_uuid_get_bytes</code>(<var class="Fa">xpc_object_t
    xuuid</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_fd_create</code>(<var class="Fa">int fd</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">xpc_fd_dup</code>(<var class="Fa">xpc_object_t
  xfd</var>);</p>
<p class="Pp"><var class="Ft">xpc_object_t</var>
  <br/>
  <code class="Fn">xpc_shmem_create</code>(<var class="Fa">void *region</var>,
    <var class="Fa">size_t length</var>);</p>
<p class="Pp"><var class="Ft">size_t</var>
  <br/>
  <code class="Fn">xpc_shmem_map</code>(<var class="Fa">xpc_object_t
    xshmem</var>, <var class="Fa">void **region</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Most XPC objects are boxed representations of primitive C language types or
  low-level operating system handles. These boxed objects are immutable. In
  general, the getter methods for each object type will check to see if the
  given object is of the proper type and, if it is not, will return a sensible
  default value as described in <a class="Xr">xpc_object(3)</a>. If an improper
  object is given to another type of method, the behavior is undefined.
<p class="Pp">See <a class="Xr">xpc_object(3)</a> for information about
    functions common to all XPC objects.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PRIMITIVE_TYPES"><a class="permalink" href="#PRIMITIVE_TYPES">PRIMITIVE
  TYPES</a></h1>
XPC objects can encapsulate a wide variety of primitive C language types:
<section class="Ss">
<h2 class="Ss" id="INTEGERS"><a class="permalink" href="#INTEGERS">INTEGERS</a></h2>
Boxed representations of 64-bit wide signed and unsigned integer types may be
  created with <code class="Fn">xpc_int64_create</code>() and
  <code class="Fn">xpc_uint64_create</code>() respectively. The boxed values may
  be retrieved using <code class="Fn">xpc_int64_get_value</code>() and
  <code class="Fn">xpc_uint64_get_value</code>().
</section>
<section class="Ss">
<h2 class="Ss" id="FLOATING_POINT"><a class="permalink" href="#FLOATING_POINT">FLOATING
  POINT</a></h2>
Boxed representations of double-precision floating point value representations
  may be created with the <code class="Fn">xpc_double_create</code>() function
  and retrieved with the <code class="Fn">xpc_double_get_value</code>()
  function.
</section>
<section class="Ss">
<h2 class="Ss" id="DATES"><a class="permalink" href="#DATES">DATES</a></h2>
Boxed representations of date and time values, expressed as an integral number
  of nanoseconds before or after the Unix epoch, can be created with the
  <code class="Fn">xpc_date_create</code>() function and retrieved with the
  <code class="Fn">xpc_date_get_value</code>() function. A date object
  representing the current date may be created with
  <code class="Fn">xpc_date_create_from_current</code>() convenience function.
</section>
<section class="Ss">
<h2 class="Ss" id="NULL_AND_BOOLEAN_SINGLETONS"><a class="permalink" href="#NULL_AND_BOOLEAN_SINGLETONS">NULL
  AND BOOLEAN SINGLETONS</a></h2>
Boxed representations of null and Boolean values are expressed as XPC object
  singletons. The <code class="Fn">xpc_bool_create</code>() function returns one
  of two constant singleton Boolean values:
<ul class="Bl-bullet Bd-indent Bl-compact">
  <li><var class="Ft">XPC_BOOL_TRUE</var></li>
  <li><var class="Ft">XPC_BOOL_FALSE</var></li>
</ul>
<p class="Pp">The singleton values may be compared using direct pointer
    equality. Similarly, no type checking is required when retrieving these
    values from collections:</p>
<div class="Bd Pp Bd-indent">
<pre>
xpc_object_t xbool = xpc_dictionary_get_value(dictionary, &quot;key&quot;);
if (xbool == XPC_BOOL_TRUE) {
	// Handle the true case.
} else if (xbool == XPC_BOOL_FALSE)
	// Handle the false case.
} else {
	// Handle the case where there was a type mismatch or where there was no
	// value for the key &quot;key&quot;.
}
</pre>
</div>
<p class="Pp">The <code class="Fn">xpc_null_create</code>() function returns a
    constant singleton representation of a null value. There is currently no
    defined constant for this singleton.</p>
<p class="Pp">It is safe to call <a class="Xr">xpc_retain(3)</a> and
    <a class="Xr">xpc_release(3)</a> on Boolean and null objects.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="DATA,_STRINGS_AND_UUIDS"><a class="permalink" href="#DATA,_STRINGS_AND_UUIDS">DATA,
  STRINGS AND UUIDS</a></h1>
<section class="Ss">
<h2 class="Ss" id="DATA"><a class="permalink" href="#DATA">DATA</a></h2>
Boxed representations of arbitrary byte values may be created with the
  <code class="Fn">xpc_data_create</code>() function which takes a pointer to a
  <var class="Fa">buffer</var> and <var class="Fa">length</var>. A pointer to
  the underlying storage of the data object may be obtained using
  <code class="Fn">xpc_data_get_bytes_ptr</code>().
<p class="Pp"><i class="Em">Important</i>: This pointer is only valid for the
    lifetime of the data object. The underlying storage of the pointer value
    must not be modified by the caller. When ARC is enabled, care needs to be
    taken that the data object is not released prematurely, see
    <a class="Xr">xpc_object(3)</a> for details.</p>
<p class="Pp">The contents of a data object may be copied to an external buffer
    using the <code class="Fn">xpc_data_get_bytes</code>() function. This
    function takes a pointer to a <var class="Fa">buffer</var> of size
    <var class="Fa">length</var> to which the data will be copied. The caller
    may also specify a non-zero <var class="Fa">offset</var> into the source
    data at which to start the copy. The return value of this function is the
    number of bytes that were copied into the <var class="Fa">buffer</var>. If
    the destination <var class="Fa">buffer</var> is smaller than the size of the
    source data, as many bytes as possible will be copied and the return value
    will be equal to the number of bytes specified in
    <var class="Fa">length</var>.</p>
<p class="Pp">The underlying size of the data value may be determined using the
    <code class="Fn">xpc_data_get_length</code>() function.</p>
<p class="Pp">When creating a data object, the contents of the provided buffer
    are copied into internal storage. If the caller wishes to avoid a copy, the
    buffer may first be encapsulated in a <var class="Ft">dispatch_data_t</var>
    object and passed to
    <code class="Fn">xpc_data_create_with_dispatch_data</code>(). See
    <a class="Xr">dispatch_data_create(3)</a> for more information.</p>
<p class="Pp"><i class="Em">Note</i>: When the time comes to send a message, the
    XPC runtime will serialize the object graph, which will result in a copy of
    any data objects contained therein. This can be very costly for large
    amounts of data. To completely avoid any copying in the message-send path
    for large data objects (where &quot;large&quot; is defined by the system),
    you may create a data object using <a class="Xr">dispatch_data_create(3)</a>
    with the <var class="Ft">DISPATCH_DATA_DESTRUCTOR_MUNMAP</var> destructor
    specified. This will hint to the system that the data buffer may be safely
    shared copy-on-write with the recipient of the message.</p>
<p class="Pp"><i class="Em">Important</i>: Data objects created with the
    intention of eliminating copies can <i class="Em">only</i> be safely created
    VM objects that the caller owns. Buffers returned by
    <a class="Xr">malloc(3)</a> do NOT satisfy this condition as the caller does
    not own the underlying VM object associated with an allocation returned by
    <a class="Xr">malloc(3)</a>. Similarly, if the caller receives a buffer from
    an external subsystem across an API boundary, this buffer is not owned by
    the caller unless part of the API contract specifies how the buffer should
    have been created. Sending buffers not owned by the caller in this way can
    result in information leakage from elsewhere on the heap.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="STRINGS"><a class="permalink" href="#STRINGS">STRINGS</a></h2>
Boxed representations of C string values may be created using the
  <code class="Fn">xpc_string_create</code>() function. The XPC framework
  assumes all strings are encoded as UTF-8 and does not support any other
  encodings. A pointer to the C string representation of a value may be obtained
  using <code class="Fn">xpc_string_get_string_ptr</code>().
<p class="Pp"><i class="Em">Important</i>: This pointer is only valid for the
    lifetime of the string object. The underlying storage of the pointer value
    must not be modified by the caller. When ARC is enabled, care needs to be
    taken that the string object is not released prematurely, see
    <a class="Xr">xpc_object(3)</a> for details.</p>
<p class="Pp">The length of the C string value may be determined using the
    <code class="Fn">xpc_string_get_length</code>() function. This length does
    not include the NUL terminator character, similar to
    <a class="Xr">strlen(3)</a>.</p>
<p class="Pp">String objects may also be constructed from
    <a class="Xr">printf(3)</a> -style format strings using the
    <code class="Fn">xpc_string_create_with_format</code>() function.
    Additionally, the
    <code class="Fn">xpc_string_create_with_format_and_arguments</code>()
    function allows the caller to pass an existing <var class="Ft">va_list</var>
    argument with which to construct the formatted string.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="UUIDs"><a class="permalink" href="#UUIDs">UUIDs</a></h2>
Boxed representations of UUID byte values may be created using
  <code class="Fn">xpc_uuid_create</code>(). See <a class="Xr">uuid(3)</a> for
  more information. A pointer to storage for the underlying UUID value may be
  obtained using <code class="Fn">xpc_uuid_get_bytes</code>(). The returned
  pointer may be safely passed to the relevant <a class="Xr">uuid(3)</a>
  functions.
<p class="Pp"><i class="Em">Important</i>: This pointer is only valid for the
    lifetime of the UUID object. The underlying storage of the UUID value must
    not be modified by the caller. When ARC is enabled, care needs to be taken
    that the UUID object is not released prematurely, see
    <a class="Xr">xpc_object(3)</a> for details.</p>
<p class="Pp">The pattern of returning a pointer instead of copying the result
    into a <var class="Ft">uuid_t</var> enables some convenient code
    simplification. For example:</p>
<div class="Bd Pp Bd-indent">
<pre>
if (uuid_compare(xpc_uuid_get_bytes(uuid_object), expected_uuid) == 0) {
	// They are the same.
}
</pre>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="OUT_OF_LINE_TYPES"><a class="permalink" href="#OUT_OF_LINE_TYPES">OUT-OF-LINE
  TYPES</a></h1>
Boxed representations of low-level operating system primitives such as file
  descriptors and shared memory regions may be created and shared between
  processes as part of an XPC dictionary that is sent as a message.
<section class="Ss">
<h2 class="Ss" id="FILE_DESCRIPTORS"><a class="permalink" href="#FILE_DESCRIPTORS">FILE
  DESCRIPTORS</a></h2>
Boxed representations of file descriptors may be created using the
  <code class="Fn">xpc_fd_create</code>() function. Once created, there is no
  way to retrieve the original file descriptor from the boxed representation.
  This function performs the equivalent of a <a class="Xr">dup(2)</a> on the
  descriptor, and thus it is safe to call <a class="Xr">close(2)</a> on the
  descriptor after boxing it.
<p class="Pp">The <code class="Fn">xpc_fd_dup</code>() function can be used to
    create a new file descriptor from a boxed representation in a similar manner
    to <a class="Xr">dup(2)</a>. The caller is responsible for calling
    <a class="Xr">close(2)</a> on the descriptor returned by
    <code class="Fn">xpc_fd_dup</code>().</p>
<p class="Pp">Multiple calls to <code class="Fn">xpc_fd_dup</code>() will
    produce multiple unique file descriptor values. If a failure occurs (i.e.
    process file descriptor table is full), the invalid file descriptor value -1
    will be returned.</p>
<p class="Pp"><i class="Em">Important</i>: When file descriptors are copied with
    <a class="Xr">dup(2)</a>, they share some state, including flags and
    <a class="Xr">lseek(2)</a> file offset. The same sharing obtains when these
    boxing and unboxing functions create copies of file descriptors, and when a
    boxed representation of a file descriptor is sent to another process using
    XPC.</p>
<p class="Pp">For example, suppose one process opens a file and sends the file
    descriptor to another process. Then, the first process uses
    <a class="Xr">read(2)</a> to read the first 100 bytes from the file. If the
    second process then calls <a class="Xr">read(2)</a> on the descriptor that
    it received from the first process, the data it reads will start at the
    101st byte of the file, not the 1st.</p>
<p class="Pp">This is not usually the desired behavior.</p>
<p class="Pp">Therefore, if you wish to send a file to another process, it is
    best not to box one shared file descriptor. Instead you should
    <a class="Xr">open(2)</a> the file afresh for each other process you wish to
    share with.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="SHARED_MEMORY"><a class="permalink" href="#SHARED_MEMORY">SHARED
  MEMORY</a></h2>
Boxed representations of shared memory regions allocated using
  <a class="Xr">mmap(2)</a> with the <var class="Ft">MAP_SHARED</var> flag
  passed in the <var class="Fa">flags</var> argument may be created using the
  <code class="Fn">xpc_shmem_create</code>() function. Memory objects created
  using <a class="Xr">malloc(3)</a> are not supported. The
  <var class="Fa">region</var> argument is a pointer to the beginning of the
  shared region and the <var class="Fa">length</var> argument specifies the
  length of the shared region.
<p class="Pp">The recipient of a shared memory object may map the underlying
    region into its address space using the
    <code class="Fn">xpc_shmem_map</code>() function. As with file descriptor
    objects, each call to this function returns a distinct but equivalent
    mapping. On output, the <var class="Fa">region</var> argument will point to
    the address of the new mapping, and the return value will be the size of
    that mapping. This size will always be an integral page size, as it is not
    possible to share memory regions at less than page granularity. The caller
    is responsible for unmapping the region with <a class="Xr">munmap(2)</a>. If
    the mapping operation failed, 0 will be returned.</p>
<p class="Pp">New mappings will be created with the maximum permission as
    specified by the creator of the region. Currently, there is no direct way to
    modify the permissions that the recipient of a region will have. If the
    caller wishes to maintain read-write permissions to a region, for example,
    while giving others read-only access, it can create an equivalent mapping
    with the desired permissions using a combination of
    <code class="Fn">mach_make_memory_entry_64</code>() and
    <code class="Fn">mach_vm_remap</code>(). The details of this procedure are
    left as an exercise to the reader.</p>
<p class="Pp">Certain operations that can operate on subranges of a region, such
    as <code class="Fn">vm_copy</code>(), <code class="Fn">vm_read</code>(), and
    <code class="Fn">vm_write</code>(), may fragment the underlying
    representation of a memory region in order to avoid physical copies. After
    this fragmentation has occurred, it is not safe to create a shared memory
    object out of the region. For this reason, it is recommended that any such
    operations be delayed until after the shared memory object has been created,
    as the existence of the object will hint to the VM that the region's
    internal representation should be kept contiguous. Note that this will
    necessarily defeat these optimizations and force physical copies of
    subranges.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<a class="Xr">xpc_object(3)</a>, <a class="Xr">xpc_dictionary_create(3)</a>,
  <a class="Xr">xpc_array_create(3)</a>,
  <a class="Xr">xpc_connection_create(3)</a>,
  <a class="Xr">dispatch_data_create(3)</a>, <a class="Xr">printf(3)</a>,
  <a class="Xr">uuid(3)</a>, <a class="Xr">dup(2)</a>,
  <a class="Xr">close(2)</a>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">1 July, 2011</td>
    <td class="foot-os">Darwin</td>
  </tr>
</table>
</body>
</html>
