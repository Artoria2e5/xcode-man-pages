<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Apache::TestUtil(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Apache::TestUtil(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Apache::TestUtil(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Apache::TestUtil - Utility functions for writing tests
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use Apache::Test;
  use Apache::TestUtil;

  ok t_cmp(&quot;foo&quot;, &quot;foo&quot;, &quot;sanity check&quot;);
  t_write_file(&quot;filename&quot;, @content);
  my $fh = t_open_file($filename);
  t_mkdir(&quot;/foo/bar&quot;);
  t_rmtree(&quot;/foo/bar&quot;);
  t_is_equal($a, $b);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<span class="Li">&quot;Apache::TestUtil&quot;</span> automatically exports a
  number of functions useful in writing tests.
<p class="Pp">All the files and directories created using the functions from
    this package will be automatically destroyed at the end of the program
    execution (via END block). You should not use these functions other than
    from within tests which should cleanup all the created directories and files
    at the end of the test.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
<dl class="Bl-tag">
  <dt><b>t_cmp()</b></dt>
  <dd><span class="Li"></span>
    <pre>
  t_cmp($received, $expected, $comment);
    </pre>
    <p class="Pp"><b>t_cmp()</b> prints the values of
        <i></i><i>$comment</i><i></i>, <i></i><i>$expected</i><i></i> and
        <i></i> <i>$received</i><i></i>. e.g.:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  t_cmp(1, 1, &quot;1 == 1?&quot;);
    </pre>
    <p class="Pp">prints:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  # testing : 1 == 1?
  # expected: 1
  # received: 1
    </pre>
    <p class="Pp">then it returns the result of comparison of the
        <i></i><i>$expected</i><i></i> and the <i></i><i>$received</i><i></i>
        variables. Usually, the return value of this function is fed directly to
        the <b>ok()</b> function, like this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  ok t_cmp(1, 1, &quot;1 == 1?&quot;);
    </pre>
    <p class="Pp">the third argument (<i></i><i>$comment</i><i></i>) is
        optional, mostly useful for telling what the comparison is trying to
      do.</p>
    <p class="Pp">It is valid to use <span class="Li">&quot;undef&quot;</span>
        as an expected value. Therefore:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $foo;
  t_cmp(undef, $foo, &quot;undef == undef?&quot;);
    </pre>
    <p class="Pp">will return a <i>true</i> value.</p>
    <p class="Pp">You can compare any two data-structures with <b>t_cmp()</b>.
        Just make sure that if you pass non-scalars, you have to pass their
        references. The datastructures can be deeply nested. For example you can
        compare:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  t_cmp({1 =&gt; [2..3,{5..8}], 4 =&gt; [5..6]},
        {1 =&gt; [2..3,{5..8}], 4 =&gt; [5..6]},
        &quot;hash of array of hashes&quot;);
    </pre>
    <p class="Pp">You can also compare the second argument against the first as
        a regex. Use the <span class="Li">&quot;qr//&quot;</span> function in
        the second argument. For example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  t_cmp(&quot;abcd&quot;, qr/^abc/, &quot;regex compare&quot;);
    </pre>
    <p class="Pp">will do:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  &quot;abcd&quot; =~ /^abc/;
    </pre>
    <p class="Pp">This function is exported by default.</p>
  </dd>
  <dt><b>t_filepath_cmp()</b></dt>
  <dd>This function is used to compare two filepaths via <b>t_cmp()</b>. For
      non-Win32, it simply uses <b>t_cmp()</b> for the comparison, but for
      Win32, <b>Win32::GetLongPathName()</b> is invoked to convert the first two
      arguments to their DOS long pathname. This is useful when there is a
      possibility the two paths being compared are not both represented by their
      long or short pathname.
    <p class="Pp">This function is exported by default.</p>
  </dd>
  <dt><b>t_debug()</b></dt>
  <dd><span class="Li"></span>
    <pre>
  t_debug(&quot;testing feature foo&quot;);
  t_debug(&quot;test&quot;, [1..3], 5, {a=&gt;[1..5]});
    </pre>
    <p class="Pp"><b>t_debug()</b> prints out any datastructure while prepending
        <span class="Li">&quot;#&quot;</span> at the beginning of each line, to
        make the debug printouts comply with
        <span class="Li">&quot;Test::Harness&quot;</span>'s requirements. This
        function should be always used for debug prints, since if in the future
        the debug printing will change (e.g. redirected into a file) your tests
        won't need to be changed.</p>
    <p class="Pp">the special global variable
        <span class="Li">$Apache::TestUtil::DEBUG_OUTPUT</span> can be used to
        redirect the output from <b>t_debug()</b> and related calls such as
        <b>t_write_file()</b>. for example, from a server-side test you would
        probably need to redirect it to STDERR:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  sub handler {
    plan $r, tests =&gt; 1;

    local $Apache::TestUtil::DEBUG_OUTPUT = \*STDERR;

    t_write_file('/tmp/foo', 'bar');
    ...
  }
    </pre>
    <p class="Pp">left to its own devices, <b>t_debug()</b> will collide with
        the standard HTTP protocol during server-side tests, resulting in a
        situation both confusing difficult to debug. but STDOUT is left as the
        default, since you probably don't want debug output under normal
        circumstances unless running under verbose mode.</p>
    <p class="Pp">This function is exported by default.</p>
  </dd>
  <dt><b>t_write_test_lib()</b></dt>
  <dd><span class="Li"></span>
    <pre>
  t_write_test_lib($filename, @lines)
    </pre>
    <p class="Pp"><b>t_write_test_lib()</b> creates a new file at
        <i></i><i>$filename</i><i></i> or overwrites the existing file with the
        content passed in <i></i><i>@lines</i><i></i>. The file is created in a
        temporary directory which is added to <span class="Li">@INC</span> at
        test configuration time. It is intended to be used for creating
        temporary packages for testing which can be modified at run time, see
        the Apache::Reload unit tests for an example.</p>
  </dd>
  <dt><b>t_write_file()</b></dt>
  <dd><span class="Li"></span>
    <pre>
  t_write_file($filename, @lines);
    </pre>
    <p class="Pp"><b>t_write_file()</b> creates a new file at
        <i></i><i>$filename</i><i></i> or overwrites the existing file with the
        content passed in <i></i><i>@lines</i><i></i>. If only the
        <i></i><i>$filename</i><i></i> is passed, an empty file will be
      created.</p>
    <p class="Pp">If parent directories of <span class="Li">$filename</span>
        don't exist they will be automagically created.</p>
    <p class="Pp">The generated file will be automatically deleted at the end of
        the program's execution.</p>
    <p class="Pp">This function is exported by default.</p>
  </dd>
  <dt><b>t_append_file()</b></dt>
  <dd><span class="Li"></span>
    <pre>
  t_append_file($filename, @lines);
    </pre>
    <p class="Pp"><b>t_append_file()</b> is similar to <b>t_write_file()</b>,
        but it doesn't clobber existing files and appends
        <span class="Li">@lines</span> to the end of the file. If the file
        doesn't exist it will create it.</p>
    <p class="Pp">If parent directories of <span class="Li">$filename</span>
        don't exist they will be automagically created.</p>
    <p class="Pp">The generated file will be registered to be automatically
        deleted at the end of the program's execution, only if the file was
        created by <b>t_append_file()</b>.</p>
    <p class="Pp">This function is exported by default.</p>
  </dd>
  <dt><b>t_write_shell_script()</b></dt>
  <dd><span class="Li"></span>
    <pre>
  Apache::TestUtil::t_write_shell_script($filename, @lines);
    </pre>
    <p class="Pp">Similar to <b>t_write_file()</b> but creates a portable
        shell/batch script. The created filename is constructed from
        <span class="Li">$filename</span> and an appropriate extension
        automatically selected according to the platform the code is running
        under.</p>
    <p class="Pp">It returns the extension of the created file.</p>
  </dd>
  <dt><b>t_write_perl_script()</b></dt>
  <dd><span class="Li"></span>
    <pre>
  Apache::TestUtil::t_write_perl_script($filename, @lines);
    </pre>
    <p class="Pp">Similar to <b>t_write_file()</b> but creates a executable Perl
        script with correctly set shebang line.</p>
  </dd>
  <dt><b>t_open_file()</b></dt>
  <dd><span class="Li"></span>
    <pre>
  my $fh = t_open_file($filename);
    </pre>
    <p class="Pp"><b>t_open_file()</b> opens a file
        <i></i><i>$filename</i><i></i> for writing and returns the file handle
        to the opened file.</p>
    <p class="Pp">If parent directories of <span class="Li">$filename</span>
        don't exist they will be automagically created.</p>
    <p class="Pp">The generated file will be automatically deleted at the end of
        the program's execution.</p>
    <p class="Pp">This function is exported by default.</p>
  </dd>
  <dt><b>t_mkdir()</b></dt>
  <dd><span class="Li"></span>
    <pre>
  t_mkdir($dirname);
    </pre>
    <p class="Pp"><b>t_mkdir()</b> creates a directory
        <i></i><i>$dirname</i><i></i>. The operation will fail if the parent
        directory doesn't exist.</p>
    <p class="Pp">If parent directories of <span class="Li">$dirname</span>
        don't exist they will be automagically created.</p>
    <p class="Pp">The generated directory will be automatically deleted at the
        end of the program's execution.</p>
    <p class="Pp">This function is exported by default.</p>
  </dd>
  <dt><b>t_rmtree()</b></dt>
  <dd><span class="Li"></span>
    <pre>
  t_rmtree(@dirs);
    </pre>
    <p class="Pp"><b>t_rmtree()</b> deletes the whole directories trees passed
        in <i></i><i>@dirs</i><i></i>.</p>
    <p class="Pp">This function is exported by default.</p>
  </dd>
  <dt><b>t_chown()</b></dt>
  <dd><span class="Li"></span>
    <pre>
  Apache::TestUtil::t_chown($file);
    </pre>
    <p class="Pp">Change ownership of <span class="Li">$file</span> to the
        test's <i>User</i>/<i>Group</i>. This function is noop on platforms
        where <b>chown</b>(2) is unsupported (e.g. Win32).</p>
  </dd>
  <dt><b>t_is_equal()</b></dt>
  <dd><span class="Li"></span>
    <pre>
  t_is_equal($a, $b);
    </pre>
    <p class="Pp"><b>t_is_equal()</b> compares any two datastructures and
        returns 1 if they are exactly the same, otherwise 0. The datastructures
        can be nested hashes, arrays, scalars, undefs or a combination of any of
        these. See <b>t_cmp()</b> for an example.</p>
    <p class="Pp">If <span class="Li">$b</span> is a regex reference, the regex
        comparison <span class="Li">&quot;$a =~ $b&quot;</span> is performed.
        For example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  t_is_equal($server_version, qr{^Apache});
    </pre>
    <p class="Pp">If comparing non-scalars make sure to pass the references to
        the datastructures.</p>
    <p class="Pp">This function is exported by default.</p>
  </dd>
  <dt><b>t_server_log_error_is_expected()</b></dt>
  <dd>If the handler's execution results in an error or a warning logged to the
      <i>error_log</i> file which is expected, it's a good idea to have a
      disclaimer printed before the error itself, so one can tell real problems
      with tests from expected errors. For example when testing how the package
      behaves under error conditions the <i>error_log</i> file might be loaded
      with errors, most of which are expected.
    <p class="Pp">For example if a handler is about to generate a run-time
        error, this function can be used as:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  use Apache::TestUtil;
  ...
  sub handler {
      my $r = shift;
      ...
      t_server_log_error_is_expected();
      die &quot;failed because ...&quot;;
  }
    </pre>
    <p class="Pp">After running this handler the <i>error_log</i> file will
        include:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  *** The following error entry is expected and harmless ***
  [Tue Apr 01 14:00:21 2003] [error] failed because ...
    </pre>
    <p class="Pp">When more than one entry is expected, an optional numerical
        argument, indicating how many entries to expect, can be passed. For
        example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  t_server_log_error_is_expected(2);
    </pre>
    <p class="Pp">will generate:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  *** The following 2 error entries are expected and harmless ***
    </pre>
    <p class="Pp">If the error is generated at compile time, the logging must be
        done in the BEGIN block at the very beginning of the file:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  BEGIN {
      use Apache::TestUtil;
      t_server_log_error_is_expected();
  }
  use DOES_NOT_exist;
    </pre>
    <p class="Pp">After attempting to run this handler the <i>error_log</i> file
        will include:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  *** The following error entry is expected and harmless ***
  [Tue Apr 01 14:04:49 2003] [error] Can't locate &quot;DOES_NOT_exist.pm&quot;
  in @INC (@INC contains: ...
    </pre>
    <p class="Pp">Also see
        <span class="Li">&quot;t_server_log_warn_is_expected()&quot;</span>
        which is similar but used for warnings.</p>
    <p class="Pp">This function is exported by default.</p>
  </dd>
  <dt><b>t_server_log_warn_is_expected()</b></dt>
  <dd><span class="Li">&quot;t_server_log_warn_is_expected()&quot;</span>
      generates a disclaimer for expected warnings.
    <p class="Pp">See the explanation for
        <span class="Li">&quot;t_server_log_error_is_expected()&quot;</span> for
        more details.</p>
    <p class="Pp">This function is exported by default.</p>
  </dd>
  <dt><b>t_client_log_error_is_expected()</b></dt>
  <dd><span class="Li">&quot;t_client_log_error_is_expected()&quot;</span>
      generates a disclaimer for expected errors. But in contrast to
      <span class="Li">&quot;t_server_log_error_is_expected()&quot;</span>
      called by the client side of the script.
    <p class="Pp">See the explanation for
        <span class="Li">&quot;t_server_log_error_is_expected()&quot;</span> for
        more details.</p>
    <p class="Pp">For example the following client script fails to find the
        handler:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  use Apache::Test;
  use Apache::TestUtil;
  use Apache::TestRequest qw(GET);

  plan tests =&gt; 1;

  t_client_log_error_is_expected();
  my $url = &quot;/error_document/cannot_be_found&quot;;
  my $res = GET($url);
  ok t_cmp(404, $res-&gt;code, &quot;test 404&quot;);
    </pre>
    <p class="Pp">After running this test the <i>error_log</i> file will include
        an entry similar to the following snippet:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  *** The following error entry is expected and harmless ***
  [Tue Apr 01 14:02:55 2003] [error] [client 127.0.0.1]
  File does not exist: /tmp/test/t/htdocs/error
    </pre>
    <p class="Pp">When more than one entry is expected, an optional numerical
        argument, indicating how many entries to expect, can be passed. For
        example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  t_client_log_error_is_expected(2);
    </pre>
    <p class="Pp">will generate:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  *** The following 2 error entries are expected and harmless ***
    </pre>
    <p class="Pp">This function is exported by default.</p>
  </dd>
  <dt><b>t_client_log_warn_is_expected()</b></dt>
  <dd><span class="Li">&quot;t_client_log_warn_is_expected()&quot;</span>
      generates a disclaimer for expected warnings on the client side.
    <p class="Pp">See the explanation for
        <span class="Li">&quot;t_client_log_error_is_expected()&quot;</span> for
        more details.</p>
    <p class="Pp">This function is exported by default.</p>
  </dd>
  <dt>t_catfile('a', 'b', 'c')</dt>
  <dd>This function is essentially
      <span class="Li">&quot;File::Spec-&gt;catfile&quot;</span>, but on Win32
      will use <span class="Li">&quot;Win32::GetLongpathName()&quot;</span> to
      convert the result to a long path name (if the result is an absolute
      file). The function is not exported by default.</dd>
  <dt>t_catfile_apache('a', 'b', 'c')</dt>
  <dd>This function is essentially
      <span class="Li">&quot;File::Spec::Unix-&gt;catfile&quot;</span>, but on
      Win32 will use
      <span class="Li">&quot;Win32::GetLongpathName()&quot;</span> to convert
      the result to a long path name (if the result is an absolute file). It is
      useful when comparing something to that returned by Apache, which uses a
      Unix-style specification with forward slashes for directory separators.
      The function is not exported by default.</dd>
  <dt><b>t_start_error_log_watch()</b>, <b>t_finish_error_log_watch()</b></dt>
  <dd>This pair of functions provides an easy interface for checking the
      presence or absense of any particular message or messages in the httpd
      error_log that were generated by the httpd daemon as part of a test suite.
      It is likely, that you should proceed this with a call to one of the
      t_*<b>_is_expected()</b> functions.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  t_start_error_log_watch();
  do_it;
  ok grep {...} t_finish_error_log_watch();
    </pre>
    <p class="Pp">Another usage case could be a handler that emits some
        debugging messages to the error_log. Now, if this handler is called in a
        series of other test cases it can be hard to find the relevant messages
        manually. In such cases the following sequence in the test file may
        help:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  t_start_error_log_watch();
  GET '/this/or/that';
  t_debug t_finish_error_log_watch();
    </pre>
  </dd>
  <dt><b>t_start_file_watch()</b></dt>
  <dd><span class="Li"></span>
    <pre>
  Apache::TestUtil::t_start_file_watch('access_log');
    </pre>
    <p class="Pp">This function is similar to
        <span class="Li">&quot;t_start_error_log_watch()&quot;</span> but allows
        for other files than <span class="Li">&quot;error_log&quot;</span> to be
        watched. It opens the given file and positions the file pointer at its
        end. Subsequent calls to
        <span class="Li">&quot;t_read_file_watch()&quot;</span> or
        <span class="Li">&quot;t_finish_file_watch()&quot;</span> will read
        lines that have been appended after this call.</p>
    <p class="Pp">A file name can be passed as parameter. If omitted or
        undefined the <span class="Li">&quot;error_log&quot;</span> is opened.
        Relative file name are evaluated relative to the directory containing
        <span class="Li">&quot;error_log&quot;</span>.</p>
    <p class="Pp">If the specified file does not exist (yet) no error is
        returned. It is assumed that it will appear soon. In this case
        <span class="Li">&quot;t_{read,finish}_file_watch()&quot;</span> will
        open the file silently and read from the beginning.</p>
  </dd>
  <dt><b>t_read_file_watch()</b>, <b>t_finish_file_watch()</b></dt>
  <dd><span class="Li"></span>
    <pre>
  local $/ = &quot;\n&quot;;
  $line1=Apache::TestUtil::t_read_file_watch('access_log');
  $line2=Apache::TestUtil::t_read_file_watch('access_log');

  @lines=Apache::TestUtil::t_finish_file_watch('access_log');
    </pre>
    <p class="Pp">This pair of functions reads the file opened by
        <span class="Li">&quot;t_start_error_log_watch()&quot;</span>.</p>
    <p class="Pp">As does the core <span class="Li">&quot;readline&quot;</span>
        function, they return one line if called in scalar context, otherwise
        all lines until end of file.</p>
    <p class="Pp">Before calling <span class="Li">&quot;readline&quot;</span>
        these functions do not set <span class="Li">$/</span> as does
        <span class="Li">&quot;t_finish_error_log_watch&quot;</span>. So, if the
        file has for example a fixed record length use this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  {
    local $/=\$record_length;
    @lines=t_finish_file_watch($name);
  }
    </pre>
  </dd>
  <dt><b>t_file_watch_for()</b></dt>
  <dd><span class="Li"></span>
    <pre>
  @lines=Apache::TestUtil::t_file_watch_for('access_log',
                                            qr/condition/,
                                            $timeout);
    </pre>
    <p class="Pp">This function reads the file from the current position and
        looks for the first line that matches
        <span class="Li">&quot;qr/condition/&quot;</span>. If no such line could
        be found until end of file the function pauses and retries until either
        such a line is found or the timeout (in seconds) is reached.</p>
    <p class="Pp">In scalar or void context only the matching line is returned.
        In list context all read lines are returned with the matching one in
        last position.</p>
    <p class="Pp">The function uses <span class="Li">&quot;\n&quot;</span> and
        end-of-line marker and waits for complete lines.</p>
    <p class="Pp">The timeout although it can be specified with sub-second
        precision is not very accurate. It is simply multiplied by 10. The
        result is used as a maximum loop count. For the intented purpose this
        should be good enough.</p>
    <p class="Pp">Use this function to check for logfile entries when you cannot
        be sure that they are already written when the test program reaches the
        point, for example to check for messages that are written in a
        PerlCleanupHandler or a PerlLogHandler.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 ok t_file_watch_for 'access_log', qr/expected log entry/, 2;
    </pre>
    <p class="Pp">This call reads the
        <span class="Li">&quot;access_log&quot;</span> and waits for maximum 2
        seconds for the expected entry to appear.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Stas Bekman &lt;stas@stason.org&gt;, Torsten F&#x00F6;rtsch
  &lt;torsten.foertsch@gmx.net&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<b>perl</b>(1)
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-06-18</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
