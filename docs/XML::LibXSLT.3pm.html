<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>LibXSLT(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">LibXSLT(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">LibXSLT(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
XML::LibXSLT - Interface to the GNOME libxslt library
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use XML::LibXSLT;
  use XML::LibXML;

  my $xslt = XML::LibXSLT-&gt;new();

  my $source = XML::LibXML-&gt;load_xml(location =&gt; 'foo.xml');
  my $style_doc = XML::LibXML-&gt;load_xml(location=&gt;'bar.xsl', no_cdata=&gt;1);

  my $stylesheet = $xslt-&gt;parse_stylesheet($style_doc);

  my $results = $stylesheet-&gt;transform($source);

  print $stylesheet-&gt;output_as_bytes($results);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module is an interface to the GNOME project's libxslt. This is an extremely
  good XSLT engine, highly compliant and also very fast. I have tests showing
  this to be more than twice as fast as Sablotron.
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
XML::LibXSLT has some global options. Note that these are probably not thread or
  even fork safe - so only set them once per process. Each one of these options
  can be called either as class methods, or as instance methods. However either
  way you call them, it still sets global options.
<p class="Pp">Each of the option methods returns its previous value, and can be
    called without a parameter to retrieve the current value.</p>
<dl class="Bl-tag">
  <dt>max_depth</dt>
  <dd><span class="Li"></span>
    <pre>
  XML::LibXSLT-&gt;max_depth(1000);
    </pre>
    <p class="Pp">This option sets the maximum recursion depth for a stylesheet.
        See the very end of section 5.4 of the XSLT specification for more
        details on recursion and detecting it. If your stylesheet or XML file
        requires seriously deep recursion, this is the way to set it. Default
        value is 250.</p>
  </dd>
  <dt>max_vars</dt>
  <dd><span class="Li"></span>
    <pre>
  XML::LibXSLT-&gt;max_vars(100_000);
    </pre>
    <p class="Pp">This option sets the maximum number of variables for a
        stylesheet. If your stylesheet or XML file requires many variables, this
        is the way to increase their limit. Default value is system-specific and
        may vary.</p>
  </dd>
  <dt>debug_callback</dt>
  <dd><span class="Li"></span>
    <pre>
  XML::LibXSLT-&gt;debug_callback($subref);
    </pre>
    <p class="Pp">Sets a callback to be used for debug messages. If you don't
        set this, debug messages will be ignored.</p>
  </dd>
  <dt>register_function</dt>
  <dd><span class="Li"></span>
    <pre>
  XML::LibXSLT-&gt;register_function($uri, $name, $subref);
  $stylesheet-&gt;register_function($uri, $name, $subref);
    </pre>
    <p class="Pp">Registers an XSLT extension function mapped to the given URI.
        For example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  XML::LibXSLT-&gt;register_function(&quot;urn:foo&quot;, &quot;bar&quot;,
    sub { scalar localtime });
    </pre>
    <p class="Pp">Will register a <span class="Li">&quot;bar&quot;</span>
        function in the <span class="Li">&quot;urn:foo&quot;</span> namespace
        (which you have to define in your XSLT using
        <span class="Li">&quot;xmlns:...&quot;</span>) that will return the
        current date and time as a string:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  &lt;xsl:stylesheet version=&quot;1.0&quot;
    xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;
    xmlns:foo=&quot;urn:foo&quot;&gt;
  &lt;xsl:template match=&quot;/&quot;&gt;
    The time is: &lt;xsl:value-of select=&quot;foo:bar()&quot;/&gt;
  &lt;/xsl:template&gt;
  &lt;/xsl:stylesheet&gt;
    </pre>
    <p class="Pp">Parameters can be in whatever format you like. If you pass in
        a nodelist it will be a XML::LibXML::NodeList object in your perl code,
        but ordinary values (strings, numbers and booleans) will be ordinary
        perl scalars. If you wish them to be
        <span class="Li">&quot;XML::LibXML::Literal&quot;</span>,
        <span class="Li">&quot;XML::LibXML::Number&quot;</span> and
        <span class="Li">&quot;XML::LibXML::Number&quot;</span> values
        respectively then set the variable
        <span class="Li">$XML::LibXSLT::USE_LIBXML_DATA_TYPES</span> to a true
        value. Return values can be a nodelist or a plain value - the code will
        just do the right thing. But only a single return value is supported (a
        list is not converted to a nodelist).</p>
  </dd>
  <dt>register_element</dt>
  <dd><span class="Li"></span>
    <pre>
        $stylesheet-&gt;register_element($uri, $name, $subref)
    </pre>
    <p class="Pp">Registers an XSLT extension element
        <span class="Li">$name</span> mapped to the given URI. For example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $stylesheet-&gt;register_element(&quot;urn:foo&quot;, &quot;hello&quot;, sub {
          my $name = $_[2]-&gt;getAttribute( &quot;name&quot; );
          return XML::LibXML::Text-&gt;new( &quot;Hello, $name!&quot; );
  });
    </pre>
    <p class="Pp">Will register a <span class="Li">&quot;hello&quot;</span>
        element in the <span class="Li">&quot;urn:foo&quot;</span> namespace
        that returns a &quot;Hello, X!&quot; text node. You must define this
        namespace in your XSLT and include its prefix in the
        <span class="Li">&quot;extension-element-prefixes&quot;</span> list:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  &lt;xsl:stylesheet version=&quot;1.0&quot;
    xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;
    xmlns:foo=&quot;urn:foo&quot;
        extension-element-prefixes=&quot;foo&quot;&gt;
  &lt;xsl:template match=&quot;/&quot;&gt;
    &lt;foo:hello name=&quot;bob&quot;/&gt;
  &lt;/xsl:template&gt;
  &lt;/xsl:stylesheet&gt;
    </pre>
    <p class="Pp">The callback is passed the input document node as
        <span class="Li">$_</span>[1] and the stylesheet node as
        <span class="Li">$_</span>[2]. <span class="Li">$_</span>[0] is reserved
        for future use.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="API"><a class="permalink" href="#API">API</a></h1>
The following methods are available on the new XML::LibXSLT object:
<dl class="Bl-tag">
  <dt>parse_stylesheet($stylesheet_doc)</dt>
  <dd><span class="Li">$stylesheet_doc</span> here is an XML::LibXML::Document
      object (see XML::LibXML) representing an XSLT file. This method will
      return a XML::LibXSLT::Stylesheet object, or undef on failure. If the XSLT
      is invalid, an exception will be thrown, so wrap the call to
      parse_stylesheet in an eval{} block to trap this.
    <p class="Pp">IMPORTANT: <span class="Li">$stylesheet_doc</span> should not
        contain CDATA sections, otherwise libxslt may misbehave. The best way to
        assure this is to load the stylesheet with no_cdata flag, e.g.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $stylesheet_doc = XML::LibXML-&gt;load_xml(location=&gt;&quot;some.xsl&quot;, no_cdata=&gt;1);
    </pre>
  </dd>
  <dt>parse_stylesheet_file($filename)</dt>
  <dd>Exactly the same as the above, but parses the given filename
    directly.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Input_Callbacks"><a class="permalink" href="#Input_Callbacks">Input
  Callbacks</a></h1>
To define XML::LibXSLT or XML::LibXSLT::Stylesheet specific input callbacks,
  reuse the XML::LibXML input callback API as described in
  <b>XML::LibXML::InputCallback</b>(3).
<dl class="Bl-tag">
  <dt>input_callbacks($icb)</dt>
  <dd>Enable the callbacks in <span class="Li">$icb</span> only for this
      XML::LibXSLT object. <span class="Li">$icb</span> should be a
      <span class="Li">&quot;XML::LibXML::InputCallback&quot;</span> object.
      This will call <span class="Li">&quot;init_callbacks&quot;</span> and
      <span class="Li">&quot;cleanup_callbacks&quot;</span> automatically during
      parsing or transformation.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Security_Callbacks"><a class="permalink" href="#Security_Callbacks">Security
  Callbacks</a></h1>
To create security preferences for the transformation see
  XML::LibXSLT::Security. Once the security preferences have been defined you
  can apply them to an XML::LibXSLT or XML::LibXSLT::Stylesheet instance using
  the <span class="Li">&quot;security_callbacks()&quot;</span> method.
</section>
<section class="Sh">
<h1 class="Sh" id="XML::LibXSLT::Stylesheet"><a class="permalink" href="#XML::LibXSLT::Stylesheet">XML::LibXSLT::Stylesheet</a></h1>
The main API is on the stylesheet, though it is fairly minimal.
<p class="Pp">One of the main advantages of XML::LibXSLT is that you have a
    generic stylesheet object which you call the <b>transform()</b> method
    passing in a document to transform. This allows you to have multiple
    transformations happen with one stylesheet without requiring a reparse.</p>
<dl class="Bl-tag">
  <dt>transform(doc, %params)</dt>
  <dd><span class="Li"></span>
    <pre>
  my $results = $stylesheet-&gt;transform($doc, foo =&gt; &quot;'bar'&quot;);
  print $stylesheet-&gt;output_as_bytes($results);
    </pre>
    <p class="Pp">Transforms the passed in XML::LibXML::Document object, and
        returns a new XML::LibXML::Document. Extra hash entries are used as
        parameters. Be sure to keep in mind the caveat with regard to quotes
        explained in the section on &quot;Parameters&quot; below.</p>
  </dd>
  <dt>transform_file(filename, %params)</dt>
  <dd><span class="Li"></span>
    <pre>
  my $results = $stylesheet-&gt;transform_file($filename, bar =&gt; &quot;'baz'&quot;);
    </pre>
    <p class="Pp">Note the string parameter caveat, detailed in the section on
        &quot;Parameters&quot; below.</p>
  </dd>
  <dt>output_as_bytes(result)</dt>
  <dd>Returns a scalar that is the XSLT rendering of the XML::LibXML::Document
      object using the desired output format (specified in the xsl:output tag in
      the stylesheet). Note that you can also call
      <span class="Li">$result</span>-&gt;toString, but that will *always*
      output the document in XML format which may not be what you asked for in
      the xsl:output tag. The scalar is a byte string encoded in the output
      encoding specified in the stylesheet.</dd>
  <dt>output_as_chars(result)</dt>
  <dd>Like <span class="Li">&quot;output_as_bytes(result)&quot;</span>, but
      always return the output as (UTF-8 encoded) string of characters.</dd>
  <dt>output_string(result)</dt>
  <dd>DEPRECATED: This method is something between
      <span class="Li">&quot;output_as_bytes(result)&quot;</span> and
      <span class="Li">&quot;output_as_bytes(result)&quot;</span>: The scalar
      returned by this function appears to Perl as characters (UTF8 flag is on)
      if the output encoding specified in the XSLT stylesheet was UTF-8 and as
      bytes if no output encoding was specified or if the output encoding was
      other than UTF-8. Since the behavior of this function depends on the
      particular stylesheet, it is deprecated in favor of
      <span class="Li">&quot;output_as_bytes(result)&quot;</span> and
      <span class="Li">&quot;output_as_chars(result)&quot;</span>.</dd>
  <dt>output_fh(result, fh)</dt>
  <dd>Outputs the result to the filehandle given in
    <span class="Li">$fh</span>.</dd>
  <dt>output_file(result, filename)</dt>
  <dd>Outputs the result to the file named in
    <span class="Li">$filename</span>.</dd>
  <dt><b>output_encoding()</b></dt>
  <dd>Returns the output encoding of the results. Defaults to
    &quot;UTF-8&quot;.</dd>
  <dt><b>output_method()</b></dt>
  <dd>Returns the value of the <span class="Li">&quot;method&quot;</span>
      attribute from <span class="Li">&quot;xsl:output&quot;</span> (usually
      <span class="Li">&quot;xml&quot;</span>,
      <span class="Li">&quot;html&quot;</span> or
      <span class="Li">&quot;text&quot;</span>). If this attribute is
      unspecified, the default value is initially
      <span class="Li">&quot;xml&quot;</span>. If the transform method is used
      to produce an HTML document, as per the XSLT spec
      &lt;http://www.w3.org/TR/xslt#output&gt;, the default value will change to
      <span class="Li">&quot;html&quot;</span>. To override this behavior
      completely, supply an <span class="Li">&quot;xsl:output&quot;</span>
      element in the stylesheet source document.</dd>
  <dt><b>media_type()</b></dt>
  <dd>Returns the value of the <span class="Li">&quot;media-type&quot;</span>
      attribute from <span class="Li">&quot;xsl:output&quot;</span>. If this
      attribute is unspecified, the default media type is initially
      <span class="Li">&quot;text/xml&quot;</span>. This default changes to
      <span class="Li">&quot;text/html&quot;</span> under the same conditions as
      output_method.</dd>
  <dt>input_callbacks($icb)</dt>
  <dd>Enable the callbacks in <span class="Li">$icb</span> only for this
      stylesheet. <span class="Li">$icb</span> should be a
      <span class="Li">&quot;XML::LibXML::InputCallback&quot;</span> object.
      This will call <span class="Li">&quot;init_callbacks&quot;</span> and
      <span class="Li">&quot;cleanup_callbacks&quot;</span> automatically during
      transformation.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Parameters"><a class="permalink" href="#Parameters">Parameters</a></h1>
LibXSLT expects parameters in XPath format. That is, if you wish to pass a
  string to the XSLT engine, you actually have to pass it as a quoted string:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $stylesheet-&gt;transform($doc, param =&gt; &quot;'string'&quot;);
</pre>
<p class="Pp">Note the quotes within quotes there!</p>
<p class="Pp">Obviously this isn't much fun, so you can make it easy on
    yourself:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $stylesheet-&gt;transform($doc, XML::LibXSLT::xpath_to_string(
        param =&gt; &quot;string&quot;
        ));
</pre>
<p class="Pp">The utility function does the right thing with respect to strings
    in XPath, including when you have quotes already embedded within your
    string.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="XML::LibXSLT::Security"><a class="permalink" href="#XML::LibXSLT::Security">XML::LibXSLT::Security</a></h1>
Provides an interface to the libxslt security framework by allowing callbacks to
  be defined that can restrict access to various resources (files or URLs)
  during a transformation.
<p class="Pp">The libxslt security framework allows callbacks to be defined for
    certain actions that a stylesheet may attempt during a transformation. It
    may be desirable to restrict some of these actions (for example, writing a
    new file using exsl:document). The actions that may be restricted are:</p>
<dl class="Bl-tag">
  <dt>read_file</dt>
  <dd>Called when the stylesheet attempts to open a local file (ie: when using
      the <b>document()</b> function).</dd>
  <dt>write_file</dt>
  <dd>Called when an attempt is made to write a local file (ie: when using the
      exsl:document element).</dd>
  <dt>create_dir</dt>
  <dd>Called when a directory needs to be created in order to write a file.
    <p class="Pp">NOTE: By default, create_dir is not allowed. To enable it a
        callback must be registered.</p>
  </dd>
  <dt>read_net</dt>
  <dd>Called when the stylesheet attempts to read from the network.</dd>
  <dt>write_net</dt>
  <dd>Called when the stylesheet attempts to write to the network.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Using_XML::LibXSLT::Security"><a class="permalink" href="#Using_XML::LibXSLT::Security">Using
  XML::LibXSLT::Security</a></h2>
The interface for this module is similar to XML::LibXML::InputCallback. After
  creating a new instance you may register callbacks for each of the security
  options listed above. Then you apply the security preferences to the
  XML::LibXSLT or XML::LibXSLT::Stylesheet object using
  <span class="Li">&quot;security_callbacks()&quot;</span>.
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $security = XML::LibXSLT::Security-&gt;new();
  $security-&gt;register_callback( read_file  =&gt; $read_cb );
  $security-&gt;register_callback( write_file =&gt; $write_cb );
  $security-&gt;register_callback( create_dir =&gt; $create_cb );
  $security-&gt;register_callback( read_net   =&gt; $read_net_cb );
  $security-&gt;register_callback( write_net  =&gt; $write_net_cb );

  $xslt-&gt;security_callbacks( $security );
   -OR-
  $stylesheet-&gt;security_callbacks( $security );
</pre>
<p class="Pp">The registered callback functions are called when access to a
    resource is requested. If the access should be allowed the callback should
    return 1, if not it should return 0. The callback functions should accept
    the following arguments:</p>
<dl class="Bl-tag">
  <dt>$tctxt</dt>
  <dd>This is the transform context (XML::LibXSLT::TransformContext). You can
      use this to get the current XML::LibXSLT::Stylesheet object by calling
      <span class="Li">&quot;stylesheet()&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $stylesheet = $tctxt-&gt;stylesheet();
    </pre>
    <p class="Pp">The stylesheet object can then be used to share contextual
        information between different calls to the security callbacks.</p>
  </dd>
  <dt>$value</dt>
  <dd>This is the name of the resource (file or URI) that has been
    requested.</dd>
</dl>
<p class="Pp">If a particular option (except for
    <span class="Li">&quot;create_dir&quot;</span>) doesn't have a registered
    callback, then the stylesheet will have full access for that action.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Interface"><a class="permalink" href="#Interface">Interface</a></h2>
<dl class="Bl-tag">
  <dt><b>new()</b></dt>
  <dd>Creates a new XML::LibXSLT::Security object.</dd>
  <dt>register_callback( $option, $callback )</dt>
  <dd>Registers a callback function for the given security option (listed
      above).</dd>
  <dt>unregister_callback( $option )</dt>
  <dd>Removes the callback for the given option. This has the effect of allowing
      all access for the given option (except for
      <span class="Li">&quot;create_dir&quot;</span>).</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BENCHMARK"><a class="permalink" href="#BENCHMARK">BENCHMARK</a></h1>
Included in the distribution is a simple benchmark script, which has two drivers
  - one for LibXSLT and one for Sablotron. The benchmark requires the testcases
  files from the XSLTMark distribution which you can find at
  http://www.datapower.com/XSLTMark/
<p class="Pp">Put the testcases directory in the directory created by this
    distribution, and then run:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  perl benchmark.pl -h
</pre>
<p class="Pp">to get a list of options.</p>
<p class="Pp">The benchmark requires XML::XPath at the moment, but I hope to
    factor that out of the equation fairly soon. It also requires Time::HiRes,
    which I could be persuaded to factor out, replacing it with Benchmark.pm,
    but I haven't done so yet.</p>
<p class="Pp">I would love to get drivers for XML::XSLT and XML::Transformiix,
    if you would like to contribute them. Also if you get this running on Win32,
    I'd love to get a driver for MSXSLT via OLE, to see what we can do against
    those Redmond boys!</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY_VERSIONS"><a class="permalink" href="#LIBRARY_VERSIONS">LIBRARY
  VERSIONS</a></h1>
For debugging purposes, XML::LibXSLT provides version information about the
  libxslt C library (but do not confuse it with the version number of
  XML::LibXSLT module itself, i.e. with
  <span class="Li">$XML::LibXSLT::VERSION</span>). XML::LibXSLT issues a warning
  if the runtime version of the library is less then the compile-time version.
<dl class="Bl-tag">
  <dt><b>XML::LibXSLT::LIBXSLT_VERSION()</b></dt>
  <dd>Returns version number of libxslt library which was used to compile
      XML::LibXSLT as an integer. For example, for libxslt-1.1.18, it will
      return 10118.</dd>
  <dt><b>XML::LibXSLT::LIBXSLT_DOTTED_VERSION()</b></dt>
  <dd>Returns version number of libxslt library which was used to compile
      XML::LibXSLT as a string, e.g. &quot;1.1.18&quot;.</dd>
  <dt><b>XML::LibXSLT::LIBXSLT_RUNTIME_VERSION()</b></dt>
  <dd>Returns version number of libxslt library to which XML::LibXSLT is linked
      at runtime (either dynamically or statically). For example, for example,
      for libxslt.so.1.1.18, it will return 10118.</dd>
  <dt><b>XML::LibXSLT::HAVE_EXLT()</b></dt>
  <dd>Returns 1 if the module was compiled with libexslt, 0 otherwise.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This is free software, you may use it and distribute it under the same terms as
  Perl itself.
<p class="Pp">Copyright 2001-2009, AxKit.com Ltd.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Matt Sergeant, matt@sergeant.org
<p class="Pp">Security callbacks implementation contributed by Shane
  Corgatelli.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINER"><a class="permalink" href="#MAINTAINER">MAINTAINER</a></h1>
Petr Pajas , pajas@matfyz.org
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
Please report bugs via
<p class="Pp"><span class="Li"></span></p>
<pre>
  http://rt.cpan.org/NoAuth/Bugs.html?Dist=XML-LibXSLT
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
XML::LibXML
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-01-16</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
