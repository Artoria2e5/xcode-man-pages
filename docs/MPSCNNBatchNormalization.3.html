<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   -*- nroff -*-
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>MPSCNNBatchNormalization(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">MPSCNNBatchNormalization(3)</td>
    <td class="head-vol">MetalPerformanceShaders.framework</td>
    <td class="head-rtitle">MPSCNNBatchNormalization(3)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
MPSCNNBatchNormalization
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp">#import &lt;MPSCNNBatchNormalization.h&gt;</p>
<p class="Pp">Inherits <b>MPSCNNKernel</b>.</p>
<section class="Ss">
<h2 class="Ss" id="Instance_Methods"><a class="permalink" href="#Instance_Methods">Instance
  Methods</a></h2>
<br/>
(nonnull instancetype) - <b>initWithDevice:dataSource:</b>
<br/>
(nonnull instancetype) - <b>initWithDevice:dataSource:fusedNeuronDescriptor:</b>
<br/>
(nonnull instancetype) - <b>initWithDevice:</b>
<br/>
(nullable instancetype) - <b>initWithCoder:device:</b>
<br/>
(void) -
  <b>encodeToCommandBuffer:sourceImage:batchNormalizationState:destinationImage:</b>
<br/>
(void) -
  <b>encodeBatchToCommandBuffer:sourceImages:batchNormalizationState:destinationImages:</b>
<br/>
(void) -
  <b>encodeToCommandBuffer:sourceImage:destinationState:destinationImage:</b>
<br/>
(<b>MPSImage</b> *__nonnull) -
  <b>encodeToCommandBuffer:sourceImage:destinationState:destinationStateIsTemporary:</b>
<br/>
(void) -
  <b>encodeBatchToCommandBuffer:sourceImages:destinationStates:destinationImages:</b>
<br/>
(<b>MPSImageBatch</b> *__nonnull) -
  <b>encodeBatchToCommandBuffer:sourceImages:destinationStates:destinationStateIsTemporary:</b>
<br/>
(<b>MPSCNNBatchNormalizationState</b> *__nullable) -
  <b>resultStateForSourceImage:sourceStates:destinationImage:</b>
<br/>
(<b>MPSCNNBatchNormalizationState</b> *__nullable) -
  <b>temporaryResultStateForCommandBuffer:sourceImage:sourceStates:destinationImage:</b>
<br/>
(void) - <b>reloadDataSource:</b>
<br/>
(void) - <b>reloadGammaAndBetaFromDataSource</b>
<br/>
(void) - <b>reloadMeanAndVarianceFromDataSource</b>
<br/>
(void) - <b>reloadGammaAndBetaWithCommandBuffer:gammaAndBetaState:</b>
<br/>
(void) - <b>reloadMeanAndVarianceWithCommandBuffer:meanAndVarianceState:</b>
<br/>
<br/>
</section>
<section class="Ss">
<h2 class="Ss" id="Properties"><a class="permalink" href="#Properties">Properties</a></h2>
<br/>
NSUInteger <b>numberOfFeatureChannels</b>
<br/>
float <b>epsilon</b>
<br/>
id&lt; <b>MPSCNNBatchNormalizationDataSource</b> &gt; <b>dataSource</b>
<br/>
<br/>
</section>
<section class="Ss">
<h2 class="Ss" id="Additional_Inherited_Members"><a class="permalink" href="#Additional_Inherited_Members">Additional
  Inherited Members</a></h2>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Detailed_Description"><a class="permalink" href="#Detailed_Description">Detailed
  Description</a></h1>
This depends on Metal.framework <b>MPSCNNBatchNormalization</b> normalizes input
  images using per-channel means and variances.
<p class="Pp">for (c = 0; c &lt; numberOfFeatureChannels; ++c) { input_image =
    in(:,:,c,:); output_image = (input_image - mean[c]) * gamma[c] /
    sqrt(variance[c] + epsilon) + beta[c]; out(:,:,c,:) = output_image; }</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Method_Documentation"><a class="permalink" href="#Method_Documentation">Method
  Documentation</a></h1>
<section class="Ss">
<h2 class="Ss" id="_-_(void)_encodeBatchToCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImageBatch_fP_*__nonnull)_sourceImages(_fBMPSCNNBatchNormalizationState_fP_*__nonnull)_batchNormalizationState(_fBMPSImageBatch_fP_*__nonnull)_destinationImages"><a class="permalink" href="#_-_(void)_encodeBatchToCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImageBatch_fP_*__nonnull)_sourceImages(_fBMPSCNNBatchNormalizationState_fP_*__nonnull)_batchNormalizationState(_fBMPSImageBatch_fP_*__nonnull)_destinationImages">-
  (void) encodeBatchToCommandBuffer: (nonnull id&lt; MTLCommandBuffer &gt;)
  commandBuffer(<b>MPSImageBatch</b> *__nonnull)
  sourceImages(<b>MPSCNNBatchNormalizationState</b> *__nonnull)
  batchNormalizationState(<b>MPSImageBatch</b> *__nonnull)
  destinationImages</a></h2>
Encode this kernel to a command buffer for a batch of images using a batch
  normalization state.
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>commandBuffer</i> <b>A</b> valid command buffer to
  receive the kernel.
<br/>
<i>sourceImages</i> The batch of source images.
<br/>
<i>batchNormalizationState</i> <b>A</b> <b>MPSCNNBatchNormalizationState</b>
  containing weights and/or statistics to use for the batch normalization. If
  the state is temporary its read count will be decremented.
<br/>
<i>destinationImages</i> The batch of images to contain the normalized and
  scaled result images.</div>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(void)_encodeBatchToCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImageBatch_fP_*__nonnull)_sourceImages(_fBMPSStateBatch_fP_*__nullable)_destinationStates(_fBMPSImageBatch_fP_*__nonnull)_destinationImages"><a class="permalink" href="#_-_(void)_encodeBatchToCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImageBatch_fP_*__nonnull)_sourceImages(_fBMPSStateBatch_fP_*__nullable)_destinationStates(_fBMPSImageBatch_fP_*__nonnull)_destinationImages">-
  (void) encodeBatchToCommandBuffer: (nonnull id&lt; MTLCommandBuffer &gt;)
  commandBuffer(<b>MPSImageBatch</b> *__nonnull)
  sourceImages(<b>MPSStateBatch</b> *__nullable)
  destinationStates(<b>MPSImageBatch</b> *__nonnull) destinationImages</a></h2>
Encode a <b>MPSCNNKernel</b> with a destination state into a command Buffer.
  This is typically used during training. The state is commonly a
  <b>MPSNNGradientState</b>. Please see
  -resultStateForSourceImages:SourceStates:destinationImage and batch+temporary
  variants.
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>commandBuffer</i> <b>A</b> valid MTLCommandBuffer to
  receive the encoded filter
<br/>
<i>sourceImages</i> <b>A</b> valid <b>MPSImage</b> object containing the source
  images.
<br/>
<i>destinationStates</i> <b>A</b> list of states to be overwritten by results
<br/>
<i>destinationImages</i> <b>A</b> valid <b>MPSImage</b> to be overwritten by
  result images. destinationImages may not alias sourceImages, even at different
  indices.</div>
<p class="Pp">Reimplemented from <b>MPSCNNKernel</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(_fBMPSImageBatch_fP_*___nonnull)_encodeBatchToCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImageBatch_fP_*__nonnull)_sourceImages(__autoreleasing__fBMPSStateBatch_fP_*__nullable_*__nonnull)_outStates(BOOL)_isTemporary"><a class="permalink" href="#_-_(_fBMPSImageBatch_fP_*___nonnull)_encodeBatchToCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImageBatch_fP_*__nonnull)_sourceImages(__autoreleasing__fBMPSStateBatch_fP_*__nullable_*__nonnull)_outStates(BOOL)_isTemporary">-
  (<b>MPSImageBatch</b> * __nonnull) encodeBatchToCommandBuffer: (nonnull id&lt;
  MTLCommandBuffer &gt;) commandBuffer(<b>MPSImageBatch</b> *__nonnull)
  sourceImages(__autoreleasing <b>MPSStateBatch</b> *__nullable *__nonnull)
  outStates(BOOL) isTemporary</a></h2>
Encode a <b>MPSCNNKernel</b> into a command Buffer. Create a MPSImageBatch and
  MPSStateBatch to hold the results and return them. In the first iteration on
  this method, encodeToCommandBuffer:sourceImage:destinationImage: some work was
  left for the developer to do in the form of correctly setting the offset
  property and sizing the result buffer. With the introduction of the padding
  policy (see padding property) the filter can do this work itself. If you would
  like to have some input into what sort of <b>MPSImage</b> (e.g. temporary vs.
  regular) or what size it is or where it is allocated, you may set the
  destinationImageAllocator to allocate the image yourself.
<p class="Pp">This method uses the <b>MPSNNPadding</b> padding property to
    figure out how to size the result image and to set the offset property. See
    discussion in <b>MPSNeuralNetworkTypes.h</b>. All images in a batch must
    have <b>MPSImage.numberOfImages</b> = 1.</p>
<p class="Pp">Usage:</p>
<p class="Pp"></p>
<pre>
MPSStateBatch * outStates = nil;    // autoreleased
MPSImageBatch * result = [k encodeBatchToCommandBuffer: cmdBuf
                                          sourceImages: sourceImages
                                     destinationStates: &amp;outStates ];
</pre>
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>commandBuffer</i> The command buffer
<br/>
<i>sourceImages</i> <b>A</b> MPSImages to use as the source images for the
  filter.
<br/>
<i>outStates</i> <b>A</b> pointer to storage to hold a MPSStateBatch* where
  output states are returned</div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent">An array of MPSImages or MPSTemporaryImages allocated per
  the destinationImageAllocator containing the output of the graph. The offset
  property will be adjusted to reflect the offset used during the encode. The
  returned images will be automatically released when the command buffer
  completes. If you want to keep them around for longer, retain the
  images.</div>
<p class="Pp">Reimplemented from <b>MPSCNNKernel</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(void)_encodeToCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImage_fP_*__nonnull)_sourceImage(_fBMPSCNNBatchNormalizationState_fP_*__nonnull)_batchNormalizationState(_fBMPSImage_fP_*__nonnull)_destinationImage"><a class="permalink" href="#_-_(void)_encodeToCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImage_fP_*__nonnull)_sourceImage(_fBMPSCNNBatchNormalizationState_fP_*__nonnull)_batchNormalizationState(_fBMPSImage_fP_*__nonnull)_destinationImage">-
  (void) encodeToCommandBuffer: (nonnull id&lt; MTLCommandBuffer &gt;)
  commandBuffer(<b>MPSImage</b> *__nonnull)
  sourceImage(<b>MPSCNNBatchNormalizationState</b> *__nonnull)
  batchNormalizationState(<b>MPSImage</b> *__nonnull) destinationImage</a></h2>
Encode this kernel to a command buffer for a single image using a batch
  normalization state.
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>commandBuffer</i> <b>A</b> valid command buffer to
  receive the kernel.
<br/>
<i>sourceImage</i> The source <b>MPSImage</b>.
<br/>
<i>batchNormalizationState</i> <b>A</b> <b>MPSCNNBatchNormalizationState</b>
  containing weights and/or statistics to use for the batch normalization. If
  the state is temporary its read count will be decremented.
<br/>
<i>destinationImage</i> An <b>MPSImage</b> to contain the resulting normalized
  and scaled image.</div>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(void)_encodeToCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImage_fP_*__nonnull)_sourceImage(_fBMPSState_fP_*__nonnull)_destinationState(_fBMPSImage_fP_*__nonnull)_destinationImage"><a class="permalink" href="#_-_(void)_encodeToCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImage_fP_*__nonnull)_sourceImage(_fBMPSState_fP_*__nonnull)_destinationState(_fBMPSImage_fP_*__nonnull)_destinationImage">-
  (void) encodeToCommandBuffer: (nonnull id&lt; MTLCommandBuffer &gt;)
  commandBuffer(<b>MPSImage</b> *__nonnull) sourceImage(<b>MPSState</b>
  *__nonnull) destinationState(<b>MPSImage</b> *__nonnull)
  destinationImage</a></h2>
Encode a <b>MPSCNNKernel</b> with a destination state into a command Buffer.
  This is typically used during training. The state is commonly a
  <b>MPSNNGradientState</b>. Please see
  -resultStateForSourceImages:SourceStates: and batch+temporary variants.
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>commandBuffer</i> <b>A</b> valid MTLCommandBuffer to
  receive the encoded filter
<br/>
<i>sourceImage</i> <b>A</b> valid <b>MPSImage</b> object containing the source
  image.
<br/>
<i>destinationState</i> <b>A</b> state to be overwritten by additional state
  information.
<br/>
<i>destinationImage</i> <b>A</b> valid <b>MPSImage</b> to be overwritten by
  result image. destinationImage may not alias sourceImage.</div>
<p class="Pp">Reimplemented from <b>MPSCNNKernel</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(_fBMPSImage_fP_*___nonnull)_encodeToCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImage_fP_*__nonnull)_sourceImage(__autoreleasing__fBMPSState_fP_*__nullable_*__nonnull)_outState(BOOL)_isTemporary"><a class="permalink" href="#_-_(_fBMPSImage_fP_*___nonnull)_encodeToCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImage_fP_*__nonnull)_sourceImage(__autoreleasing__fBMPSState_fP_*__nullable_*__nonnull)_outState(BOOL)_isTemporary">-
  (<b>MPSImage</b> * __nonnull) encodeToCommandBuffer: (nonnull id&lt;
  MTLCommandBuffer &gt;) commandBuffer(<b>MPSImage</b> *__nonnull)
  sourceImage(__autoreleasing <b>MPSState</b> *__nullable *__nonnull)
  outState(BOOL) isTemporary</a></h2>
Encode a <b>MPSCNNKernel</b> into a command Buffer. Create a texture and state
  to hold the results and return them. In the first iteration on this method,
  encodeToCommandBuffer:sourceImage:destinationState:destinationImage: some work
  was left for the developer to do in the form of correctly setting the offset
  property and sizing the result buffer. With the introduction of the padding
  policy (see padding property) the filter can do this work itself. If you would
  like to have some input into what sort of <b>MPSImage</b> (e.g. temporary vs.
  regular) or what size it is or where it is allocated, you may set the
  destinationImageAllocator to allocate the image yourself.
<p class="Pp">This method uses the <b>MPSNNPadding</b> padding property to
    figure out how to size the result image and to set the offset property. See
    discussion in <b>MPSNeuralNetworkTypes.h</b>. All images in a batch must
    have <b>MPSImage.numberOfImages</b> = 1.</p>
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>commandBuffer</i> The command buffer
<br/>
<i>sourceImage</i> <b>A</b> <b>MPSImage</b> to use as the source images for the
  filter.
<br/>
<i>outState</i> <b>A</b> new state object is returned here.</div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent"><b>A</b> <b>MPSImage</b> or <b>MPSTemporaryImage</b>
  allocated per the destinationImageAllocator containing the output of the
  graph. The offset property will be adjusted to reflect the offset used during
  the encode. The returned image will be automatically released when the command
  buffer completes. If you want to keep it around for longer, retain the image.
  (ARC will do this for you if you use it later.)</div>
<p class="Pp">Reimplemented from <b>MPSCNNKernel</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(nullable_instancetype)__fBinitWithCoder:_fP_(NSCoder_*__nonnull)_aDecoder(nonnull_id__MTLDevice__)_device"><a class="permalink" href="#_-_(nullable_instancetype)__fBinitWithCoder:_fP_(NSCoder_*__nonnull)_aDecoder(nonnull_id__MTLDevice__)_device">-
  (nullable instancetype) <b>initWithCoder:</b> (NSCoder *__nonnull)
  aDecoder(nonnull id&lt; MTLDevice &gt;) device</a></h2>
<b>NSSecureCoding</b> compatability While the standard NSSecureCoding/NSCoding
  method -initWithCoder: should work, since the file can't know which device
  your data is allocated on, we have to guess and may guess incorrectly. To
  avoid that problem, use a subclass of NSCoder that implements the
  &lt;MPSDeviceProvider&gt; protocol to tell MPS the MTLDevice to use.
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>aDecoder</i> The NSCoder subclass with your serialized
  <b>MPSKernel</b>
<br/>
<i>device</i> The MTLDevice on which to make the <b>MPSKernel</b></div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent"><b>A</b> new <b>MPSCNNBatchNormalization</b> object, or
  nil if failure.</div>
<p class="Pp">Reimplemented from <b>MPSCNNKernel</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(nonnull_instancetype)_initWithDevice:_(nonnull_id__MTLDevice__)_device"><a class="permalink" href="#_-_(nonnull_instancetype)_initWithDevice:_(nonnull_id__MTLDevice__)_device">-
  (nonnull instancetype) initWithDevice: (nonnull id&lt; MTLDevice &gt;)
  device</a></h2>
Use initWithDevice:dataSource instead
<p class="Pp">Reimplemented from <b>MPSCNNKernel</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(nonnull_instancetype)__fBinitWithDevice:_fP_(nonnull_id__MTLDevice__)_device(nonnull_id___fBMPSCNNBatchNormalizationDataSource_fP__)_dataSource"><a class="permalink" href="#_-_(nonnull_instancetype)__fBinitWithDevice:_fP_(nonnull_id__MTLDevice__)_device(nonnull_id___fBMPSCNNBatchNormalizationDataSource_fP__)_dataSource">-
  (nonnull instancetype) <b>initWithDevice:</b> (nonnull id&lt; MTLDevice &gt;)
  device(nonnull id&lt; <b>MPSCNNBatchNormalizationDataSource</b> &gt;)
  dataSource</a></h2>
Initializes a batch normalization kernel using a data source.
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>device</i> The MTLDevice on which this filter will be
  used
<br/>
<i>dataSource</i> <b>A</b> pointer to a object that conforms to the
  <b>MPSCNNBatchNormalizationDataSource</b> protocol. The data source provides
  filter weights and bias terms and, optionally, image statistics which may be
  used to perform the normalization.</div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent"><b>A</b> valid <b>MPSCNNBatchNormalization</b> object or
  nil, if failure.</div>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(nonnull_instancetype)__fBinitWithDevice:_fP_(nonnull_id__MTLDevice__)_device(nonnull_id___fBMPSCNNBatchNormalizationDataSource_fP__)_dataSource(_fBMPSNNNeuronDescriptor_fP_*__nullable)_fusedNeuronDescriptor"><a class="permalink" href="#_-_(nonnull_instancetype)__fBinitWithDevice:_fP_(nonnull_id__MTLDevice__)_device(nonnull_id___fBMPSCNNBatchNormalizationDataSource_fP__)_dataSource(_fBMPSNNNeuronDescriptor_fP_*__nullable)_fusedNeuronDescriptor">-
  (nonnull instancetype) <b>initWithDevice:</b> (nonnull id&lt; MTLDevice &gt;)
  device(nonnull id&lt; <b>MPSCNNBatchNormalizationDataSource</b> &gt;)
  dataSource(<b>MPSNNNeuronDescriptor</b> *__nullable)
  fusedNeuronDescriptor</a></h2>
Initializes a batch normalization kernel using a data source and a neuron
  descriptor.
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>device</i> The MTLDevice on which this filter will be
  used
<br/>
<i>dataSource</i> <b>A</b> pointer to a object that conforms to the
  <b>MPSCNNBatchNormalizationDataSource</b> protocol. The data source provides
  filter weights and bias terms and, optionally, image statistics which may be
  used to perform the normalization.
<br/>
<i>fusedNeuronDescriptor</i> <b>A</b> <b>MPSNNNeuronDescriptor</b> object which
  specifies a neuron activation function to be applied to the result of the
  batch normalization.</div>
<p class="Pp"><b>Returns:</b></p>
<div class="Bd-indent"><b>A</b> valid <b>MPSCNNBatchNormalization</b> object or
  nil, if failure.</div>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(void)_reloadDataSource:_(__nonnull_id___fBMPSCNNBatchNormalizationDataSource_fP__)_dataSource"><a class="permalink" href="#_-_(void)_reloadDataSource:_(__nonnull_id___fBMPSCNNBatchNormalizationDataSource_fP__)_dataSource">-
  (void) reloadDataSource: (__nonnull id&lt;
  <b>MPSCNNBatchNormalizationDataSource</b> &gt;) dataSource</a></h2>
Reinitialize the filter using a data source.
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>dataSource</i> The data source which will provide the
  weights and, optionally, the image batch statistics with which to
  normalize.</div>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(void)_reloadGammaAndBetaFromDataSource"><a class="permalink" href="#_-_(void)_reloadGammaAndBetaFromDataSource">-
  (void) reloadGammaAndBetaFromDataSource </a></h2>
Reinitialize the filter's gamma and beta values using the data source provided
  at kernel initialization.
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(void)_reloadGammaAndBetaWithCommandBuffer:_(__nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSCNNNormalizationGammaAndBetaState_fP_*__nonnull)_gammaAndBetaState"><a class="permalink" href="#_-_(void)_reloadGammaAndBetaWithCommandBuffer:_(__nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSCNNNormalizationGammaAndBetaState_fP_*__nonnull)_gammaAndBetaState">-
  (void) reloadGammaAndBetaWithCommandBuffer: (__nonnull id&lt; MTLCommandBuffer
  &gt;) commandBuffer(<b>MPSCNNNormalizationGammaAndBetaState</b> *__nonnull)
  gammaAndBetaState</a></h2>
Reload data using new gamma and beta terms contained within an
  <b>MPSCNNNormalizationGammaAndBetaState</b> object.
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>commandBuffer</i> The command buffer on which to
  encode the reload.
<br/>
<i>gammaAndBetaState</i> The state containing the updated weights which are to
  be reloaded.</div>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(void)_reloadMeanAndVarianceFromDataSource"><a class="permalink" href="#_-_(void)_reloadMeanAndVarianceFromDataSource">-
  (void) reloadMeanAndVarianceFromDataSource </a></h2>
Reinitialize the filter's mean and variance values using the data source
  provided at kernel initialization.
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(void)_reloadMeanAndVarianceWithCommandBuffer:_(__nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSCNNNormalizationMeanAndVarianceState_fP_*__nonnull)_meanAndVarianceState"><a class="permalink" href="#_-_(void)_reloadMeanAndVarianceWithCommandBuffer:_(__nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSCNNNormalizationMeanAndVarianceState_fP_*__nonnull)_meanAndVarianceState">-
  (void) reloadMeanAndVarianceWithCommandBuffer: (__nonnull id&lt;
  MTLCommandBuffer &gt;)
  commandBuffer(<b>MPSCNNNormalizationMeanAndVarianceState</b> *__nonnull)
  meanAndVarianceState</a></h2>
Reload data using new mean and variance terms contained within an
  <b>MPSCNNNormalizationMeanAndVarianceState</b> object.
<p class="Pp"><b>Parameters:</b></p>
<div class="Bd-indent"><i>commandBuffer</i> The command buffer on which to
  encode the reload.
<br/>
<i>meanAndVarianceState</i> The state containing the updated statistics which
  are to be reloaded.</div>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(_fBMPSCNNBatchNormalizationState_fP_*___nullable)_resultStateForSourceImage:_(_fBMPSImage_fP_*__nonnull)_sourceImage(NSArray___fBMPSState_fP_*___*__nullable)_sourceStates(_fBMPSImage_fP_*__nonnull)_destinationImage"><a class="permalink" href="#_-_(_fBMPSCNNBatchNormalizationState_fP_*___nullable)_resultStateForSourceImage:_(_fBMPSImage_fP_*__nonnull)_sourceImage(NSArray___fBMPSState_fP_*___*__nullable)_sourceStates(_fBMPSImage_fP_*__nonnull)_destinationImage">-
  (<b>MPSCNNBatchNormalizationState</b> * __nullable) resultStateForSourceImage:
  (<b>MPSImage</b> *__nonnull) sourceImage(NSArray&lt; <b>MPSState</b> * &gt;
  *__nullable) sourceStates(<b>MPSImage</b> *__nonnull)
  destinationImage</a></h2>
Return an <b>MPSCNNBatchNormalizationState</b> object which may be used with a
  <b>MPSCNNBatchNormalization</b> filter.
<p class="Pp">Reimplemented from <b>MPSCNNKernel</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_-_(_fBMPSCNNBatchNormalizationState_fP_*___nullable)_temporaryResultStateForCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImage_fP_*__nonnull)_sourceImage(NSArray___fBMPSState_fP_*___*__nullable)_sourceStates(_fBMPSImage_fP_*__nonnull)_destinationImage"><a class="permalink" href="#_-_(_fBMPSCNNBatchNormalizationState_fP_*___nullable)_temporaryResultStateForCommandBuffer:_(nonnull_id__MTLCommandBuffer__)_commandBuffer(_fBMPSImage_fP_*__nonnull)_sourceImage(NSArray___fBMPSState_fP_*___*__nullable)_sourceStates(_fBMPSImage_fP_*__nonnull)_destinationImage">-
  (<b>MPSCNNBatchNormalizationState</b> * __nullable)
  temporaryResultStateForCommandBuffer: (nonnull id&lt; MTLCommandBuffer &gt;)
  commandBuffer(<b>MPSImage</b> *__nonnull) sourceImage(NSArray&lt;
  <b>MPSState</b> * &gt; *__nullable) sourceStates(<b>MPSImage</b> *__nonnull)
  destinationImage</a></h2>
Return a temporary <b>MPSCNNBatchNormalizationState</b> object which may be used
  with a <b>MPSCNNBatchNormalization</b> filter.
<p class="Pp">Reimplemented from <b>MPSCNNKernel</b>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Property_Documentation"><a class="permalink" href="#Property_Documentation">Property
  Documentation</a></h1>
<section class="Ss">
<h2 class="Ss" id="_-_(id__fBMPSCNNBatchNormalizationDataSource_fP_)_dataSource_fC__read__fP,__fC__nonatomic__fP,__fC__retain__fP"><a class="permalink" href="#_-_(id__fBMPSCNNBatchNormalizationDataSource_fP_)_dataSource_fC__read__fP,__fC__nonatomic__fP,__fC__retain__fP">-
  (id&lt;<b>MPSCNNBatchNormalizationDataSource</b>&gt;) dataSource [read]<b>,
  [nonatomic]</b>, [retain]<b></b></a></h2>
The data source the batch normalization was initialized with
</section>
<section class="Ss">
<h2 class="Ss" id="_-_epsilon_fC__read__fP,__fC__write__fP,__fC__nonatomic__fP,__fC__assign__fP"><a class="permalink" href="#_-_epsilon_fC__read__fP,__fC__write__fP,__fC__nonatomic__fP,__fC__assign__fP">-
  epsilon [read]<b>, [write]</b>, [nonatomic]<b>, [assign]</b></a></h2>
The epsilon value used in the batch normalization formula to bias the variance
  when normalizing.
</section>
<section class="Ss">
<h2 class="Ss" id="_-_numberOfFeatureChannels_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP"><a class="permalink" href="#_-_numberOfFeatureChannels_fC__read__fP,__fC__nonatomic__fP,__fC__assign__fP">-
  numberOfFeatureChannels [read]<b>, [nonatomic]</b>, [assign]<b></b></a></h2>
The number of feature channels in an image to be normalized.
<p class="Pp"></p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Author"><a class="permalink" href="#Author">Author</a></h1>
Generated automatically by Doxygen for MetalPerformanceShaders.framework from
  the source code.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">Mon Jul 9 2018</td>
    <td class="foot-os">Version MetalPerformanceShaders-119.3</td>
  </tr>
</table>
</body>
</html>
