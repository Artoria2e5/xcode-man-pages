<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>DBI::ProfileData(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBI::ProfileData(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBI::ProfileData(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
DBI::ProfileData - manipulate DBI::ProfileDumper data dumps
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
The easiest way to use this module is through the dbiprof frontend (see dbiprof
  for details):
<p class="Pp"><span class="Li"></span></p>
<pre>
  dbiprof --number 15 --sort count
</pre>
<p class="Pp">This module can also be used to roll your own profile
  analysis:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # load data from dbi.prof
  $prof = DBI::ProfileData-&gt;new(File =&gt; &quot;dbi.prof&quot;);

  # get a count of the records (unique paths) in the data set
  $count = $prof-&gt;count();

  # sort by longest overall time
  $prof-&gt;sort(field =&gt; &quot;longest&quot;);

  # sort by longest overall time, least to greatest
  $prof-&gt;sort(field =&gt; &quot;longest&quot;, reverse =&gt; 1);

  # exclude records with key2 eq 'disconnect'
  $prof-&gt;exclude(key2 =&gt; 'disconnect');

  # exclude records with key1 matching /^UPDATE/i
  $prof-&gt;exclude(key1 =&gt; qr/^UPDATE/i);

  # remove all records except those where key1 matches /^SELECT/i
  $prof-&gt;match(key1 =&gt; qr/^SELECT/i);

  # produce a formatted report with the given number of items
  $report = $prof-&gt;report(number =&gt; 10);

  # clone the profile data set
  $clone = $prof-&gt;clone();

  # get access to hash of header values
  $header = $prof-&gt;header();

  # get access to sorted array of nodes
  $nodes = $prof-&gt;nodes();

  # format a single node in the same style as report()
  $text = $prof-&gt;format($nodes-&gt;[0]);

  # get access to Data hash in DBI::Profile format
  $Data = $prof-&gt;Data();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module offers the ability to read, manipulate and format DBI::ProfileDumper
  profile data.
<p class="Pp">Conceptually, a profile consists of a series of records, or nodes,
    each of each has a set of statistics and set of keys. Each record must have
    a unique set of keys, but there is no requirement that every record have the
    same number of keys.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
The following methods are supported by DBI::ProfileData objects.
<section class="Ss">
<h2 class="Ss" id="$prof_=_DBI::ProfileData_-_new(File_=___dbi.prof_)"><a class="permalink" href="#$prof_=_DBI::ProfileData_-_new(File_=___dbi.prof_)">$prof
  = DBI::ProfileData-&gt;new(File =&gt; &quot;dbi.prof&quot;)</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="$prof_=_DBI::ProfileData_-_new(File_=___dbi.prof_,_Filter_=__sub___...__)"><a class="permalink" href="#$prof_=_DBI::ProfileData_-_new(File_=___dbi.prof_,_Filter_=__sub___...__)">$prof
  = DBI::ProfileData-&gt;new(File =&gt; &quot;dbi.prof&quot;, Filter =&gt; sub {
  ... })</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="$prof_=_DBI::ProfileData_-_new(Files_=_____dbi.prof.1_,__dbi.prof.2___)"><a class="permalink" href="#$prof_=_DBI::ProfileData_-_new(Files_=_____dbi.prof.1_,__dbi.prof.2___)">$prof
  = DBI::ProfileData-&gt;new(Files =&gt; [ &quot;dbi.prof.1&quot;,
  &quot;dbi.prof.2&quot; ])</a></h2>
Creates a new DBI::ProfileData object. Takes either a single file through the
  File option or a list of Files in an array ref. If multiple files are
  specified then the header data from the first file is used.
<p class="Pp"><i>Files</i></p>
<p class="Pp">Reference to an array of file names to read.</p>
<p class="Pp"><i>File</i></p>
<p class="Pp">Name of file to read. Takes precedence over
    <span class="Li">&quot;Files&quot;</span>.</p>
<p class="Pp"><i>DeleteFiles</i></p>
<p class="Pp">If true, the files are deleted after being read.</p>
<p class="Pp">Actually the files are renamed with a C.deleteme&gt; suffix before
    being read, and then, after reading all the files, they're all deleted
    together.</p>
<p class="Pp">The files are locked while being read which, combined with the
    rename, makes it safe to 'consume' files that are still being generated by
    DBI::ProfileDumper.</p>
<p class="Pp"><i>Filter</i></p>
<p class="Pp">The <span class="Li">&quot;Filter&quot;</span> parameter can be
    used to supply a code reference that can manipulate the profile data as it
    is being read. This is most useful for editing SQL statements so that
    slightly different statements in the raw data will be merged and aggregated
    in the loaded data. For example:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Filter =&gt; sub {
      my ($path_ref, $data_ref) = @_;
      s/foo = '.*?'/foo = '...'/ for @$path_ref;
  }
</pre>
<p class="Pp">Here's an example that performs some normalization on the SQL. It
    converts all numbers to <span class="Li">&quot;N&quot;</span> and all quoted
    strings to <span class="Li">&quot;S&quot;</span>. It can also convert digits
    to N within names. Finally, it summarizes long &quot;IN (...)&quot;
  clauses.</p>
<p class="Pp">It's aggressive and simplistic, but it's often sufficient, and
    serves as an example that you can tailor to suit your own needs:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Filter =&gt; sub {
      my ($path_ref, $data_ref) = @_;
      local $_ = $path_ref-&gt;[0]; # whichever element contains the SQL Statement
      s/\b\d+\b/N/g;             # 42 -&gt; N
      s/\b0x[0-9A-Fa-f]+\b/N/g;  # 0xFE -&gt; N
      s/'.*?'/'S'/g;             # single quoted strings (doesn't handle escapes)
      s/&quot;.*?&quot;/&quot;S&quot;/g;             # double quoted strings (doesn't handle escapes)
      # convert names like log_20001231 into log_NNNNNNNN, controlled by $opt{n}
      s/([a-z_]+)(\d{$opt{n},})/$1.('N' x length($2))/ieg if $opt{n};
      # abbreviate massive &quot;in (...)&quot; statements and similar
      s!(([NS],){100,})!sprintf(&quot;$2,{repeated %d times}&quot;,length($1)/2)!eg;
  }
</pre>
<p class="Pp">It's often better to perform this kinds of normalization in the
    DBI while the data is being collected, to avoid too much memory being used
    by storing profile data for many different SQL statement. See
  DBI::Profile.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$copy_=_$prof_-__fIclone()_fP;"><a class="permalink" href="#$copy_=_$prof_-__fIclone()_fP;">$copy
  = $prof-&gt;<i>clone()</i>;</a></h2>
Clone a profile data set creating a new object.
</section>
<section class="Ss">
<h2 class="Ss" id="$header_=_$prof_-__fIheader()_fP;"><a class="permalink" href="#$header_=_$prof_-__fIheader()_fP;">$header
  = $prof-&gt;<i>header()</i>;</a></h2>
Returns a reference to a hash of header values. These are the key value pairs
  included in the header section of the DBI::ProfileDumper data format. For
  example:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $header = {
    Path    =&gt; [ '!Statement', '!MethodName' ],
    Program =&gt; 't/42profile_data.t',
  };
</pre>
<p class="Pp">Note that modifying this hash will modify the header data stored
    inside the profile object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$nodes_=_$prof_-__fInodes()_fP"><a class="permalink" href="#$nodes_=_$prof_-__fInodes()_fP">$nodes
  = $prof-&gt;<i>nodes()</i></a></h2>
Returns a reference the sorted nodes array. Each element in the array is a
  single record in the data set. The first seven elements are the same as the
  elements provided by DBI::Profile. After that each key is in a separate
  element. For example:
<p class="Pp"><span class="Li"></span></p>
<pre>
 $nodes = [
            [
              2,                      # 0, count
              0.0312958955764771,     # 1, total duration
              0.000490069389343262,   # 2, first duration
              0.000176072120666504,   # 3, shortest duration
              0.00140702724456787,    # 4, longest duration
              1023115819.83019,       # 5, time of first event
              1023115819.86576,       # 6, time of last event
              'SELECT foo FROM bar'   # 7, key1
              'execute'               # 8, key2
                                      # 6+N, keyN
            ],
                                      # ...
          ];
</pre>
<p class="Pp">Note that modifying this array will modify the node data stored
    inside the profile object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$count_=_$prof_-__fIcount()_fP"><a class="permalink" href="#$count_=_$prof_-__fIcount()_fP">$count
  = $prof-&gt;<i>count()</i></a></h2>
Returns the number of items in the profile data set.
</section>
<section class="Ss">
<h2 class="Ss" id="$prof_-_sort(field_=___field_)"><a class="permalink" href="#$prof_-_sort(field_=___field_)">$prof-&gt;sort(field
  =&gt; &quot;field&quot;)</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="$prof_-_sort(field_=___field_,_reverse_=__1)"><a class="permalink" href="#$prof_-_sort(field_=___field_,_reverse_=__1)">$prof-&gt;sort(field
  =&gt; &quot;field&quot;, reverse =&gt; 1)</a></h2>
Sorts data by the given field. Available fields are:
<p class="Pp"><span class="Li"></span></p>
<pre>
  longest
  total
  count
  shortest
</pre>
<p class="Pp">The default sort is greatest to smallest, which is the opposite of
    the normal Perl meaning. This, however, matches the expected behavior of the
    dbiprof frontend.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="$count_=_$prof_-_exclude(key2_=___disconnect_)"><a class="permalink" href="#$count_=_$prof_-_exclude(key2_=___disconnect_)">$count
  = $prof-&gt;exclude(key2 =&gt; &quot;disconnect&quot;)</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="$count_=_$prof_-_exclude(key2_=___disconnect_,_case_sensitive_=__1)"><a class="permalink" href="#$count_=_$prof_-_exclude(key2_=___disconnect_,_case_sensitive_=__1)">$count
  = $prof-&gt;exclude(key2 =&gt; &quot;disconnect&quot;, case_sensitive =&gt;
  1)</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="$count_=_$prof_-_exclude(key1_=__qr/_SELECT/i)"><a class="permalink" href="#$count_=_$prof_-_exclude(key1_=__qr/_SELECT/i)">$count
  = $prof-&gt;exclude(key1 =&gt; qr/^SELECT/i)</a></h2>
Removes records from the data set that match the given string or regular
  expression. This method modifies the data in a permanent fashion - use
  <i>clone()</i> first to maintain the original data after <i>exclude()</i>.
  Returns the number of nodes left in the profile data set.
</section>
<section class="Ss">
<h2 class="Ss" id="$count_=_$prof_-_match(key2_=___disconnect_)"><a class="permalink" href="#$count_=_$prof_-_match(key2_=___disconnect_)">$count
  = $prof-&gt;match(key2 =&gt; &quot;disconnect&quot;)</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="$count_=_$prof_-_match(key2_=___disconnect_,_case_sensitive_=__1)"><a class="permalink" href="#$count_=_$prof_-_match(key2_=___disconnect_,_case_sensitive_=__1)">$count
  = $prof-&gt;match(key2 =&gt; &quot;disconnect&quot;, case_sensitive =&gt;
  1)</a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="$count_=_$prof_-_match(key1_=__qr/_SELECT/i)"><a class="permalink" href="#$count_=_$prof_-_match(key1_=__qr/_SELECT/i)">$count
  = $prof-&gt;match(key1 =&gt; qr/^SELECT/i)</a></h2>
Removes records from the data set that do not match the given string or regular
  expression. This method modifies the data in a permanent fashion - use
  <i>clone()</i> first to maintain the original data after <i>match()</i>.
  Returns the number of nodes left in the profile data set.
</section>
<section class="Ss">
<h2 class="Ss" id="$Data_=_$prof_-__fIData()_fP"><a class="permalink" href="#$Data_=_$prof_-__fIData()_fP">$Data
  = $prof-&gt;<i>Data()</i></a></h2>
Returns the same Data hash structure as seen in DBI::Profile. This structure is
  not sorted. The <i>nodes()</i> structure probably makes more sense for most
  analysis.
</section>
<section class="Ss">
<h2 class="Ss" id="$text_=_$prof_-_format($nodes_-__0_)"><a class="permalink" href="#$text_=_$prof_-_format($nodes_-__0_)">$text
  = $prof-&gt;format($nodes-&gt;[0])</a></h2>
Formats a single node into a human-readable block of text.
</section>
<section class="Ss">
<h2 class="Ss" id="$text_=_$prof_-_report(number_=__10)"><a class="permalink" href="#$text_=_$prof_-_report(number_=__10)">$text
  = $prof-&gt;report(number =&gt; 10)</a></h2>
Produces a report with the given number of items.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Sam Tregar &lt;sam@tregar.com&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
Copyright (C) 2002 Sam Tregar
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl 5 itself.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-06-24</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
