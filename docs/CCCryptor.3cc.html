<!DOCTYPE html>
<html>
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>CCCryptor(3cc)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">CCCryptor(3cc)</td>
    <td class="head-vol">3cc</td>
    <td class="head-rtitle">CCCryptor(3cc)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<code class="Nm">CCCryptorCreate</code>,
  <code class="Nm">CCryptorCreateFromData</code>,
  <code class="Nm">CCCryptorRelease</code>,
  <code class="Nm">CCCryptorUpdate</code>,
  <code class="Nm">CCCryptorFinal</code>,
  <code class="Nm">CCCryptorGetOutputLength</code>,
  <code class="Nm">CCCryptorReset</code>, <code class="Nm">CCCrypt</code>
  &#x2014;
<div class="Nd">Common Cryptographic Algorithm Interfaces</div>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY"><a class="permalink" href="#LIBRARY">LIBRARY</a></h1>
These functions are found in libSystem.
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<code class="In">#include
  &lt;<a class="In">CommonCrypto/CommonCryptor.h</a>&gt;</code>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorCreate</code>(<var class="Fa" style="white-space: nowrap;">CCOperation
    op</var>, <var class="Fa" style="white-space: nowrap;">CCAlgorithm
    alg</var>, <var class="Fa" style="white-space: nowrap;">CCOptions
    options</var>, <var class="Fa" style="white-space: nowrap;">const void
    *key</var>, <var class="Fa" style="white-space: nowrap;">size_t
    keyLength</var>, <var class="Fa" style="white-space: nowrap;">const void
    *iv</var>, <var class="Fa" style="white-space: nowrap;">CCCryptorRef
    *cryptorRef</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorCreateFromData</code>(<var class="Fa" style="white-space: nowrap;">CCOperation
    op</var>, <var class="Fa" style="white-space: nowrap;">CCAlgorithm
    alg</var>, <var class="Fa" style="white-space: nowrap;">CCOptions
    options</var>, <var class="Fa" style="white-space: nowrap;">const void
    *key</var>, <var class="Fa" style="white-space: nowrap;">size_t
    keyLength</var>, <var class="Fa" style="white-space: nowrap;">const void
    *iv</var>, <var class="Fa" style="white-space: nowrap;">const void
    *data</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataLength</var>, <var class="Fa" style="white-space: nowrap;">CCCryptorRef
    *cryptorRef</var>, <var class="Fa" style="white-space: nowrap;">size_t
    *dataUsed</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorRelease</code>(<var class="Fa" style="white-space: nowrap;">CCCryptorRef
    cryptorRef</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorUpdate</code>(<var class="Fa" style="white-space: nowrap;">CCCryptorRef
    cryptorRef</var>, <var class="Fa" style="white-space: nowrap;">const void
    *dataIn</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataInLength</var>, <var class="Fa" style="white-space: nowrap;">void
    *dataOut</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataOutAvailable</var>, <var class="Fa" style="white-space: nowrap;">size_t
    *dataOutMoved</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorFinal</code>(<var class="Fa" style="white-space: nowrap;">CCCryptorRef
    cryptorRef</var>, <var class="Fa" style="white-space: nowrap;">void
    *dataOut</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataOutAvailable</var>, <var class="Fa" style="white-space: nowrap;">size_t
    *dataOutMoved</var>);</p>
<p class="Pp"><var class="Ft">size_t</var>
  <br/>
  <code class="Fn">CCCryptorGetOutputLength</code>(<var class="Fa" style="white-space: nowrap;">CCCryptorRef
    cryptorRef</var>, <var class="Fa" style="white-space: nowrap;">size_t
    inputLength</var>, <var class="Fa" style="white-space: nowrap;">bool
    final</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorReset</code>(<var class="Fa" style="white-space: nowrap;">CCCryptorRef
    cryptorRef</var>, <var class="Fa" style="white-space: nowrap;">const void
    *iv</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCrypt</code>(<var class="Fa" style="white-space: nowrap;">CCOperation
    op</var>, <var class="Fa" style="white-space: nowrap;">CCAlgorithm
    alg</var>, <var class="Fa" style="white-space: nowrap;">CCOptions
    options</var>, <var class="Fa" style="white-space: nowrap;">const void
    *key</var>, <var class="Fa" style="white-space: nowrap;">size_t
    keyLength</var>, <var class="Fa" style="white-space: nowrap;">const void
    *iv</var>, <var class="Fa" style="white-space: nowrap;">const void
    *dataIn</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataInLength</var>, <var class="Fa" style="white-space: nowrap;">void
    *dataOut</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataOutAvailable</var>, <var class="Fa" style="white-space: nowrap;">size_t
    *dataOutMoved</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This interface provides access to a number of symmetric encryption algorithms.
  Symmetric encryption algorithms come in two &quot;flavors&quot; - block
  ciphers, and stream ciphers. Block ciphers process data (while both encrypting
  and decrypting) in discrete chunks of data called blocks; stream ciphers
  operate on arbitrary sized data.
<p class="Pp">The object declared in this interface, CCCryptor, provides access
    to both block ciphers and stream ciphers with the same API; however some
    options are available for block ciphers that do not apply to stream
  ciphers.</p>
<p class="Pp">The general operation of a CCCryptor is: initialize it with raw
    key data and other optional fields with CCCryptorCreate(); process input
    data via one or more calls to CCCryptorUpdate(), each of which may result in
    output data being written to caller-supplied memory; and obtain possible
    remaining output data with CCCryptorFinal(). The CCCryptor is disposed of
    via CCCryptorRelease(), or it can be reused (with the same key data as
    provided to CCCryptorCreate()) by calling CCCryptorReset().</p>
<p class="Pp">CCCryptors can be dynamically allocated by this module, or their
    memory can be allocated by the caller.</p>
<p class="Pp">One option for block ciphers is padding, as defined in PKCS7; when
    padding is enabled, the total amount of data encrypted does not have to be
    an even multiple of the block size, and the actual length of plaintext is
    calculated during decryption.</p>
<p class="Pp">Another option for block ciphers is Cipher Block Chaining, known
    as CBC mode. When using CBC mode, an Initialization Vector (IV) is provided
    along with the key when starting an encrypt or decrypt operation. If CBC
    mode is selected and no IV is provided, an IV of all zeroes will be
  used.</p>
<p class="Pp">CCCryptor also implements block bufferring, so that individual
    calls to CCCryptorUpdate() do not have to provide data whose length is
    aligned to the block size. (If padding is disabled, encrypting with block
    ciphers does require that the *total* length of data input to
    CCCryptorUpdate() call(s) be aligned to the block size.)</p>
<p class="Pp">Encryption and decryption can be performed &quot;in-place&quot;,
    with the same buffer used for input and output. The .Fn CCCryptorUpdate does
    not support in-place operation for ciphers modes that work with blocks of
    data such as CBC and ECB, because of block buffering.</p>
<p class="Pp"></p>
<p class="Pp">A given CCCryptor can only be used by one thread at a time;
    multiple threads can use safely different CCCryptors at the same time.</p>
<p class="Pp"><var class="Ft">CCCryptorRef</var> objects created with
    <code class="Fn">CCCryptorCreate</code>() or
    <code class="Fn">CCCryptorCreateFromData</code>() must be disposed of via
    <code class="Fn">CCCRyptorRelease</code>() ; which clears sensitive data and
    deallocates the <var class="Ft">CCCryptorRef</var> when the caller is
    finished using the <var class="Ft">CCCryptorRef.</var></p>
<p class="Pp"><code class="Fn">CCCryptorUpdate</code>() is used to encrypt or
    decrypt data. This routine can be called multiple times. The caller does not
    need to align input data lengths to block sizes; input is bufferred as
    necessary for block ciphers.</p>
<p class="Pp">When performing symmetric encryption with block ciphers, and
    padding is enabled via <var class="Ft">kCCOptionPKCS7Padding,</var> the
    total number of bytes provided by all the calls to this function when
    encrypting can be arbitrary (i.e., the total number of bytes does not have
    to be block aligned). However if padding is disabled, or when decrypting,
    the total number of bytes does have to be aligned to the block size;
    otherwise <code class="Fn">CCCryptFinal</code>() will return
    <var class="Ft">kCCAlignmentError.</var></p>
<p class="Pp">A general rule for the size of the output buffer which must be
    provided by the caller is that for block ciphers, the output length is never
    larger than the input length plus the block size. For stream ciphers, the
    output length is always exactly the same as the input length. See the
    discussion for <code class="Fn">CCCryptorGetOutputLength</code>() for more
    information on this topic.</p>
<p class="Pp"><code class="Fn">CCCryptFinal</code>() finishes encryption and
    decryption operations and obtains the final data output. Except when
    <var class="Ft">kCCBufferTooSmall</var> is returned, the
    <var class="Ft">CCCryptorRef</var> can no longer be used for subsequent
    operations unless <code class="Fn">CCCryptorReset</code>() is called on
  it.</p>
<p class="Pp">It is not necessary to call
    <code class="Fn">CCCryptorFinal</code>() when performing symmetric
    encryption or decryption if padding is disabled, or when using a stream
    cipher.</p>
<p class="Pp">It is not necessary to call
    <code class="Fn">CCCryptorFinal</code>() prior to
    <code class="Fn">CCCryptorRelease</code>() when aborting an operation.</p>
<p class="Pp">Use <code class="Fn">CCCryptorGetOutputLength</code>() to
    determine output buffer size required to process a given input size. Some
    general rules apply that allow clients of this module to know a priori how
    much output buffer space will be required in a given situation. For stream
    ciphers, the output size is always equal to the input size, and
    <code class="Fn">CCCryptorFinal</code>() never produces any data. For block
    ciphers, the output size will always be less than or equal to the input size
    plus the size of one block. For block ciphers, if the input size provided to
    each call to <code class="Fn">CCCryptorUpdate</code>() is is an integral
    multiple of the block size, then the output size for each call to
    <code class="Fn">CCCryptorUpdate</code>() is less than or equal to the input
    size for that call to <code class="Fn">CCCryptorUpdate</code>().
    <code class="Fn">CCCryptorFinal</code>() only produces output when using a
    block cipher with padding enabled.</p>
<p class="Pp"><code class="Fn">CCCryptorReset</code>() reinitializes an existing
    <var class="Ft">CCCryptorRef</var> with a (possibly) new initialization
    vector. The key contained in the <var class="Ft">CCCryptorRef</var> is
    unchanged. This function is not implemented for stream ciphers. This can be
    called on a CCCryptorRef with data pending (i.e. in a padded mode operation
    before <code class="Fn">CCCryptFinal</code>() is called); however any
    pending data will be lost in that case.</p>
<p class="Pp"><code class="Fn">CCCrypt</code>() is a stateless, one-shot encrypt
    or decrypt operation. This basically performs a sequence of
    <code class="Fn">CCCrytorCreate</code>(),
    <code class="Fn">CCCryptorUpdate</code>(),
    <code class="Fn">CCCryptorFinal</code>(), and
    <code class="Fn">CCCryptorRelease</code>().</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
The following values may be returned as a status of type
  <var class="Ft">CCCryptorStatus</var>.
<p class="Pp"><code class="Er">kCCSuccess</code> - Operation completed
  normally.</p>
<p class="Pp"><code class="Er">kCCParamError</code> - Illegal parameter
  value.</p>
<p class="Pp"><code class="Er">kCCBufferTooSmall</code> - Insufficent buffer
    provided for specified operation.</p>
<p class="Pp"><code class="Er">kCCMemoryFailure</code> - Memory allocation
    failure.</p>
<p class="Pp"><code class="Er">kCCAlignmentError</code> - Input size was not
    aligned properly.</p>
<p class="Pp"><code class="Er">kCCDecodeError</code> - Input data did not decode
    or decrypt properly.</p>
<p class="Pp"><code class="Er">kCCUnimplemented</code> - Function not
    implemented for the current algorithm.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
These functions are available in OS X 10.5 and later.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<a class="Xr">CCHmac(3cc)</a>, <a class="Xr">CC_MD5(3cc)</a>,
  <a class="Xr">CC_SHA(3cc)</a>, <a class="Xr">CC_crypto(3cc)</a>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARDS"><a class="permalink" href="#STANDARDS">STANDARDS</a></h1>
<dl class="Bl-tag">
  <dt>AES:</dt>
  <dd>Federal Information Processing Standard FIPS PUB 197 (Advanced Encryption
      Standard),</dd>
  <dt>DES:</dt>
  <dd>Federal Information Processing Standard FIPS PUB 46-3 (Data Encryption
      Standard)</dd>
  <dt>3DES:</dt>
  <dd>NIST Special PublicationPUB 800-67 (Recommendation for the Triple Data
      Encryption Algorithm (TDEA) Block Cipher)</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">March 22, 2007</td>
    <td class="foot-os">Mac OS X 11.0</td>
  </tr>
</table>
</body>
</html>
