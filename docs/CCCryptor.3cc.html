<!DOCTYPE html>
<html>
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>CCCryptor(3cc)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">CCCryptor(3cc)</td>
    <td class="head-vol">3cc</td>
    <td class="head-rtitle">CCCryptor(3cc)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<code class="Nm">CCCryptorCreate</code>,
  <code class="Nm">CCCryptorCreateFromData</code>,
  <code class="Nm">CCCryptorRelease</code>,
  <code class="Nm">CCCryptorUpdate</code>,
  <code class="Nm">CCCryptorFinal</code>,
  <code class="Nm">CCCryptorGetOutputLength</code>,
  <code class="Nm">CCCryptorReset</code>, <code class="Nm">CCCrypt</code>
  &#x2014;
<div class="Nd">Common Cryptographic Algorithm Interfaces</div>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY"><a class="permalink" href="#LIBRARY">LIBRARY</a></h1>
These functions are found in libSystem.
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<code class="In">#include
  &lt;<a class="In">CommonCrypto/CommonCryptor.h</a>&gt;</code>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorCreate</code>(<var class="Fa" style="white-space: nowrap;">CCOperation
    op</var>, <var class="Fa" style="white-space: nowrap;">CCAlgorithm
    alg</var>, <var class="Fa" style="white-space: nowrap;">CCOptions
    options</var>, <var class="Fa" style="white-space: nowrap;">const void
    *key</var>, <var class="Fa" style="white-space: nowrap;">size_t
    keyLength</var>, <var class="Fa" style="white-space: nowrap;">const void
    *iv</var>, <var class="Fa" style="white-space: nowrap;">CCCryptorRef
    *cryptorRef</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorCreateFromData</code>(<var class="Fa" style="white-space: nowrap;">CCOperation
    op</var>, <var class="Fa" style="white-space: nowrap;">CCAlgorithm
    alg</var>, <var class="Fa" style="white-space: nowrap;">CCOptions
    options</var>, <var class="Fa" style="white-space: nowrap;">const void
    *key</var>, <var class="Fa" style="white-space: nowrap;">size_t
    keyLength</var>, <var class="Fa" style="white-space: nowrap;">const void
    *iv</var>, <var class="Fa" style="white-space: nowrap;">const void
    *data</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataLength</var>, <var class="Fa" style="white-space: nowrap;">CCCryptorRef
    *cryptorRef</var>, <var class="Fa" style="white-space: nowrap;">size_t
    *dataUsed</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorCreateWithMode</code>(<var class="Fa" style="white-space: nowrap;">CCOperation
    op</var>, <var class="Fa" style="white-space: nowrap;">CCMode mode</var>,
    <var class="Fa" style="white-space: nowrap;">CCAlgorithm alg&quot;CCPadding
    padding</var>, <var class="Fa" style="white-space: nowrap;">const void
    *iv</var>, <var class="Fa" style="white-space: nowrap;">const void
    *key</var>, <var class="Fa" style="white-space: nowrap;">size_t
    keyLength</var>, <var class="Fa" style="white-space: nowrap;">const void
    *tweak</var>, <var class="Fa" style="white-space: nowrap;">size_t
    tweakLength</var>, <var class="Fa" style="white-space: nowrap;">int
    numRounds</var>, <var class="Fa" style="white-space: nowrap;">CCModeOptions
    options</var>, <var class="Fa" style="white-space: nowrap;">CCryptorRef
    *cryptorRef</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorRelease</code>(<var class="Fa" style="white-space: nowrap;">CCCryptorRef
    cryptorRef</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorUpdate</code>(<var class="Fa" style="white-space: nowrap;">CCCryptorRef
    cryptorRef</var>, <var class="Fa" style="white-space: nowrap;">const void
    *dataIn</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataInLength</var>, <var class="Fa" style="white-space: nowrap;">void
    *dataOut</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataOutAvailable</var>, <var class="Fa" style="white-space: nowrap;">size_t
    *dataOutMoved</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorFinal</code>(<var class="Fa" style="white-space: nowrap;">CCCryptorRef
    cryptorRef</var>, <var class="Fa" style="white-space: nowrap;">void
    *dataOut</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataOutAvailable</var>, <var class="Fa" style="white-space: nowrap;">size_t
    *dataOutMoved</var>);</p>
<p class="Pp"><var class="Ft">size_t</var>
  <br/>
  <code class="Fn">CCCryptorGetOutputLength</code>(<var class="Fa" style="white-space: nowrap;">CCCryptorRef
    cryptorRef</var>, <var class="Fa" style="white-space: nowrap;">size_t
    inputLength</var>, <var class="Fa" style="white-space: nowrap;">bool
    final</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCryptorReset</code>(<var class="Fa" style="white-space: nowrap;">CCCryptorRef
    cryptorRef</var>, <var class="Fa" style="white-space: nowrap;">const void
    *iv</var>);</p>
<p class="Pp"><var class="Ft">CCCryptorStatus</var>
  <br/>
  <code class="Fn">CCCrypt</code>(<var class="Fa" style="white-space: nowrap;">CCOperation
    op</var>, <var class="Fa" style="white-space: nowrap;">CCAlgorithm
    alg</var>, <var class="Fa" style="white-space: nowrap;">CCOptions
    options</var>, <var class="Fa" style="white-space: nowrap;">const void
    *key</var>, <var class="Fa" style="white-space: nowrap;">size_t
    keyLength</var>, <var class="Fa" style="white-space: nowrap;">const void
    *iv</var>, <var class="Fa" style="white-space: nowrap;">const void
    *dataIn</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataInLength</var>, <var class="Fa" style="white-space: nowrap;">void
    *dataOut</var>, <var class="Fa" style="white-space: nowrap;">size_t
    dataOutAvailable</var>, <var class="Fa" style="white-space: nowrap;">size_t
    *dataOutMoved</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This interface provides access to a number of symmetric encryption algorithms.
  Symmetric encryption algorithms come in two &quot;flavors&quot; - block
  ciphers, and stream ciphers. Block ciphers process data (while both encrypting
  and decrypting) in discrete chunks of data called blocks; stream ciphers
  operate on arbitrary sized data.
<p class="Pp">The object declared in this interface,
    <code class="Fn">CCCryptor,</code>() provides access to both block ciphers
    and stream ciphers with the same API; however some options are available for
    block ciphers that do not apply to stream ciphers.</p>
<p class="Pp">The general operation of a call to
    <code class="Fn">CCCryptor</code>() is: initialize it with raw key data and
    other optional fields with <code class="Fn">CCCryptorCreate</code>() ;
    process input data via one or more calls to
    <code class="Fn">CCCryptorUpdate</code>() each of which may result in output
    data being written to caller-supplied memory; and obtain possible remaining
    output data with <code class="Fn">CCCryptorFinal.</code>() The
    <var class="Ft">CCCryptor</var> is disposed of via
    <code class="Fn">CCCryptorRelease,</code>() or in CBC and CTR modes (and
    only those modes), it can be reused (with the same key data as provided to
    <code class="Fn">CCCryptorCreate</code>() ) by calling
    <code class="Fn">CCCryptorReset</code>() <code class="Fn">CCCrypt</code>()
    can be called.</p>
<p class="Pp"><var class="Ft">CCCryptors</var> can be dynamically allocated by
    this module, or their memory can be allocated by the caller.</p>
<p class="Pp">A call to <code class="Fn">CCCryptorCreate</code>() or
    <code class="Fn">CCCrypt</code>() will require a
    <var class="Ft">CCOperation</var> , which can be either
    <var class="Ft">kCCEncrypt</var> , or <var class="Ft">kCCDecrypt.</var> The
    <var class="Ft">CCAlgorithm</var> choice allows specification of the cipher
    to use, with <var class="Ft">kCCAlgorithmAES</var> being the recommended
    choice. All supported stream ciphers (e.g., RC2 and RC4) are no longer
    considered secure and should not be used.</p>
<p class="Pp">The options parameter is only used when specifying a block-cipher,
    and should be set to 0 if a stream-cipher is being used. Otherwise the
    following options are allowed, and may be ORed together. The options allow
    for the use of PKCS7 padding by setting the flag
    <var class="Ft">kCCOptionPKCS7Padding</var> , and the use of the non-default
    mode of the cipher <var class="Ft">kCCOptionECBMode.</var> This flag puts
    the cipher in Electronic Code Book mode and should not be used for
    encryption as this is known to be insecure, but rather it is provided to
    allow for direct access to the output of the block-cipher.</p>
<p class="Pp">PKCS7; when padding is enabled, the total amount of data encrypted
    does not have to be an even multiple of the block size, and the actual
    length of plaintext is calculated during decryption.</p>
<p class="Pp">If the ECB mode option is not specified, then by default block
    ciphers are used in Cipher Block Chaining mode, also known as CBC mode. When
    using CBC mode, an Initialization Vector (IV) should be provided along with
    the key when starting an encrypt or decrypt operation. The IV should be the
    same length in bytes as the block-cipher's length. If CBC mode is selected
    and no IV is provided, an IV of all zeroes will be used, which in many
    applications will result in security issues.</p>
<p class="Pp"><code class="Fn">CCCryptor</code>() also implements block
    buffering, so that individual calls to
    <code class="Fn">CCCryptorUpdate</code>() do not have to provide data whose
    length is aligned to the block size. (If padding is disabled, encrypting
    with block ciphers does require that the *total* length of data input to
    <code class="Fn">CCCryptorUpdate</code>() call(s) be aligned to the block
    size.)</p>
<p class="Pp">Encryption and decryption can be performed &quot;in-place&quot;,
    with the same buffer used for input and output. The
    <code class="Fn">CCCryptorUpdate</code>() does not support in-place
    operation for ciphers modes that work with blocks of data such as CBC and
    ECB, because of block buffering.</p>
<p class="Pp">A given <code class="Fn">CCCryptor</code>() can only be used by
    one thread at a time; multiple threads can safely use different
    <code class="Fn">CCCryptors</code>() at the same time.</p>
<p class="Pp"><var class="Ft">CCCryptorRef</var> objects created with
    <code class="Fn">CCCryptorCreate</code>() or
    <code class="Fn">CCCryptorCreateFromData</code>() must be disposed of via
    <code class="Fn">CCCRyptorRelease</code>() ; which clears sensitive data and
    deallocates the <var class="Ft">CCCryptorRef</var> when the caller is
    finished using the <var class="Ft">CCCryptorRef.</var></p>
<p class="Pp"><code class="Fn">CCCryptorUpdate</code>() is used to encrypt or
    decrypt data. This routine can be called multiple times. The caller does not
    need to align input data lengths to block sizes; input is buffered as
    necessary for block ciphers.</p>
<p class="Pp">When performing symmetric encryption with block ciphers, and
    padding is enabled via <var class="Ft">kCCOptionPKCS7Padding,</var> the
    total number of bytes provided by all the calls to this function when
    encrypting can be arbitrary (i.e., the total number of bytes does not have
    to be block aligned). However if padding is disabled, or when decrypting,
    the total number of bytes does have to be aligned to the block size;
    otherwise <code class="Fn">CCCryptFinal</code>() will return
    <var class="Ft">kCCAlignmentError.</var></p>
<p class="Pp">A general rule for the size of the output buffer which must be
    provided by the caller is that for block ciphers, the output length is never
    larger than the input length plus the block size. For stream ciphers, the
    output length is always exactly the same as the input length. See the
    discussion for <code class="Fn">CCCryptorGetOutputLength</code>() for more
    information on this topic.</p>
<p class="Pp"><code class="Fn">CCCryptFinal</code>() finishes encryption and
    decryption operations and obtains the final data output. Except when
    <var class="Ft">kCCBufferTooSmall</var> is returned, the
    <var class="Ft">CCCryptorRef</var> can no longer be used for subsequent
    operations unless <code class="Fn">CCCryptorReset</code>() is called on it,
    but this is only available in CBC or CTR mode.</p>
<p class="Pp">It is not necessary to call
    <code class="Fn">CCCryptorFinal</code>() when performing symmetric
    encryption or decryption if padding is disabled, or when using a stream
    cipher.</p>
<p class="Pp">It is not necessary to call
    <code class="Fn">CCCryptorFinal</code>() prior to
    <code class="Fn">CCCryptorRelease</code>() when aborting an operation.</p>
<p class="Pp">Use <code class="Fn">CCCryptorGetOutputLength</code>() to
    determine output buffer size required to process a given input size. Some
    general rules apply that allow clients of this module to know a priori how
    much output buffer space will be required in a given situation. For stream
    ciphers, the output size is always equal to the input size, and
    <code class="Fn">CCCryptorFinal</code>() never produces any data. For block
    ciphers, the output size will always be less than or equal to the input size
    plus the size of one block. For block ciphers, if the input size provided to
    each call to <code class="Fn">CCCryptorUpdate</code>() is is an integral
    multiple of the block size, then the output size for each call to
    <code class="Fn">CCCryptorUpdate</code>() is less than or equal to the input
    size for that call to <code class="Fn">CCCryptorUpdate</code>().
    <code class="Fn">CCCryptorFinal</code>() only produces output when using a
    block cipher with padding enabled.</p>
<p class="Pp"><code class="Fn">CCCryptorReset</code>() reinitializes an existing
    <var class="Ft">CCCryptorRef</var> with a (possibly) new initialization
    vector. The key contained in the <var class="Ft">CCCryptorRef</var> is
    unchanged. This function is not implemented for any modes other than CBC or
    CTR, nor is it implemented for stream ciphers, and will return an error in
    such cases. This can be called on a CCCryptorRef with data pending (i.e. in
    a padded mode operation before <code class="Fn">CCCryptFinal</code>() is
    called); however any pending data will be lost in that case.</p>
<p class="Pp"><code class="Fn">CCCrypt</code>() is a stateless, one-shot encrypt
    or decrypt operation. This basically performs a sequence of
    <code class="Fn">CCCrytorCreate</code>(),
    <code class="Fn">CCCryptorUpdate</code>(),
    <code class="Fn">CCCryptorFinal</code>(), and
    <code class="Fn">CCCryptorRelease</code>().</p>
<p class="Pp">If a mode other than CBC or ECB is desired,
    <code class="Fn">CCCryptorCreateWithMode</code>() can be used to specify
    other modes. Possible modes include Electronic Code Book, Cipher Block
    Chaining, Cipher Feedback, Output Feedback, and Counter Modes, which are
    specified by mode set respectively to:
  <br/>
   kCCModeECB,
  <br/>
   kCCModeCBC,
  <br/>
   kCCModeCFB,
  <br/>
   kCCModeCTR, and
  <br/>
   kCCModeOFB.</p>
<p class="Pp">In such calls, q.Ft tweak should be set to NULL, and
    <var class="Ft">tweakLength, numRounds</var> and
    <var class="Ft">options</var> are reserved for future use and must be set to
    0. Padding is set as either <var class="Ft">ccNoPadding,</var> or
    <var class="Ft">ccPKCS7Padding.</var></p>
<p class="Pp">Formally, the following ciphers are supported in CCCryptor
  <br/>
   kCCAlgorithmAES,
  <br/>
   kCCAlgorithmDES,
  <br/>
   kCCAlgorithm3DES,
  <br/>
   kCCAlgorithmCAST,
  <br/>
   kCCAlgorithmRC4,
  <br/>
   kCCAlgorithmRC2, and
  <br/>
   kCCAlgorithmBlowfish.</p>
<p class="Pp">Caution should be used as several of these ciphers are only
    supported for legacy reasons, and are now often considered broken, or too
    weak for use (ie. DES, CAST, RC4, and RC2). The small block length 3DES,
    CAST and Blowfish requires their use only in specific cases. Similarly, CAST
    should only be used with 16 byte keys.</p>
<p class="Pp">Block sizes, in bytes, for supported Ciphers.
    <var class="Ft">kCCBlockSizeAES128</var> is 16 bytes.
    <var class="Ft">kCCBlockSizeDES,</var>
    <var class="Ft">kCCBlockSize3DES,</var> and
    <var class="Ft">kCCBlockSizeCAST</var> are all 8 bytes.</p>
<p class="Pp">Key sizes supported for various ciphers are defined by the
    following constants, and must be given in fixed byte lengths. The following
    AES key bit length constants, define their corresponding byte equivalents:
  <br/>
   kCCKeySizeAES128 = 16,
  <br/>
   kCCKeySizeAES192 = 24, and
  <br/>
   kCCKeySizeAES256 = 32.</p>
<p class="Pp">DES and 3DES use
  <br/>
   kCCKeySizeDES = 8, and
  <br/>
   kCCKeySize3DES = 16, respectively.</p>
<p class="Pp">For the remaining ciphers:
  <br/>
   kCCKeySizeMinCAST = 5,
  <br/>
   kCCKeySizeMaxCAST = 16,
  <br/>
   kCCKeySizeMinRC4 = 1,
  <br/>
   kCCKeySizeMaxRC4 = 512,
  <br/>
   kCCKeySizeMinRC2 = 1,
  <br/>
   kCCKeySizeMaxRC2 = 128,
  <br/>
   kCCKeySizeMinBlowfish = 8, and
  <br/>
   kCCKeySizeMaxBlowfish = 56,</p>
<p class="Pp">define the relative minimum and maximum lengths of the keys. Note
    that any key shorter than 16 bytes frequently fails to provide suitable
    security guarantees. However, having a key of length 16 bytes does not
    ensure security. As mentioned earlier, many of the supported ciphers and
    modes are no longer considered secure.</p>
<p class="Pp">Minimum context sizes, for caller-allocated
    <var class="Ft">CCCryptorRefs.</var> To minimize dynamic allocation memory,
    a caller can create a by passing caller-supplied memory to the
    <code class="Fn">CCCryptorCreateFromData</code>() function.</p>
<p class="Pp">These constants define the minimum amount of memory, in bytes,
    needed for <code class="Fn">CCCryptorRefs</code>() for each supported
    cipher.</p>
<p class="Pp">Note: these constants are valid for the current version of this
    library; they may change in subsequent releases, so applications wishing to
    allocate their own memory for use in creating
    <var class="Ft">CCCryptorRefs</var> must be prepared to deal with a
    <var class="Ft">kCCBufferTooSmall</var> returned from
    <code class="Fn">CCCryptorCreateFromData.</code>()</p>
<p class="Pp"><var class="Ft">kCCContextSizeAES128</var> - Minimum context size
    for kCCAlgorithmAES128. <var class="Ft">kCCContextSizeDES</var> - Minimum
    context size for kCCAlgorithmDES. <var class="Ft">kCCContextSize3DES</var> -
    Minimum context size for kCCAlgorithm3DES.
    <var class="Ft">kCCContextSizeCAST</var> - Minimum context size for
    kCCAlgorithmCAST. <var class="Ft">kCCContextSizeRC4</var> - Minimum context
    size for kCCAlgorithmRC4.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
The following values may be returned as a status of type
  <var class="Ft">CCCryptorStatus</var>.
<p class="Pp"><code class="Er">kCCSuccess</code> - Operation completed
  normally.</p>
<p class="Pp"><code class="Er">kCCParamError</code> - Illegal parameter
  value.</p>
<p class="Pp"><code class="Er">kCCBufferTooSmall</code> - Insufficient buffer
    provided for specified operation.</p>
<p class="Pp"><code class="Er">kCCMemoryFailure</code> - Memory allocation
    failure.</p>
<p class="Pp"><code class="Er">kCCAlignmentError</code> - Input size was not
    aligned properly.</p>
<p class="Pp"><code class="Er">kCCDecodeError</code> - Input data did not decode
    or decrypt properly.</p>
<p class="Pp"><code class="Er">kCCUnimplemented</code> - Function not
    implemented for the current algorithm.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
These functions are available in OS X 10.5 and later.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<a class="Xr">CCHmac(3cc)</a>, <a class="Xr">CC_MD5(3cc)</a>,
  <a class="Xr">CC_SHA(3cc)</a>, <a class="Xr">CC_crypto(3cc)</a>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARDS"><a class="permalink" href="#STANDARDS">STANDARDS</a></h1>
<dl class="Bl-tag">
  <dt>AES:</dt>
  <dd>Federal Information Processing Standard FIPS PUB 197 (Advanced Encryption
      Standard),</dd>
  <dt>DES:</dt>
  <dd>Federal Information Processing Standard FIPS PUB 46-3 (Data Encryption
      Standard)</dd>
  <dt>3DES:</dt>
  <dd>NIST Special PublicationPUB 800-67 (Recommendation for the Triple Data
      Encryption Algorithm (TDEA) Block Cipher)</dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">March 22, 2007</td>
    <td class="foot-os">Mac OS X 11.0</td>
  </tr>
</table>
</body>
</html>
