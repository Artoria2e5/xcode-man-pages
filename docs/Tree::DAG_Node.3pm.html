<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Tree::DAG_Node(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Tree::DAG_Node(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Tree::DAG_Node(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Tree::DAG_Node - An N-ary tree
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
Using as a base class:
<p class="Pp"><span class="Li"></span></p>
<pre>
        package Game::Tree::Node;

        use parent 'Tree::DAG_Node';

        # Now add your own methods overriding/extending the methods in C&lt;Tree::DAG_Node&gt;...
</pre>
<p class="Pp">Using as a class of its own:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Tree::DAG_Node;

        my $root = Tree::DAG_Node-&gt;new();

        $root-&gt;name(&quot;I'm the tops&quot;);
        my $new_daughter = $root-&gt;new_daughter;
        $new_daughter-&gt;name(&quot;More&quot;);
        ...
</pre>
<p class="Pp">Using with utf-8 data:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        read_tree($file_name) works with utf-8 data. See t/read.tree.t and t/tree.utf8.attributes.txt.
        Such a file can be created by redirecting the output of tree2string() to a file of type utf-8.
</pre>
<p class="Pp">See the docs for Encode for the difference between utf8 and utf-8.
    In brief, use utf-8.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This class encapsulates/makes/manipulates objects that represent nodes in a tree
  structure. The tree structure is not an object itself, but is emergent from
  the linkages you create between nodes. This class provides the methods for
  making linkages that can be used to build up a tree, while preventing you from
  ever making any kinds of linkages which are not allowed in a tree (such as
  having a node be its own mother or ancestor, or having a node have two
  mothers).
<p class="Pp">This is what I mean by a &quot;tree structure&quot;, a bit
    redundantly stated:</p>
<dl class="Bl-tag">
  <dt>o A tree is a special case of an acyclic directed graph</dt>
  <dd></dd>
  <dt>o A tree is a network of nodes where there's exactly one root node</dt>
  <dd>Also, the only primary relationship between nodes is the mother-daughter
      relationship.</dd>
  <dt>o No node can be its own mother, or its mother's mother, etc</dt>
  <dd></dd>
  <dt>o Each node in the tree has exactly one parent</dt>
  <dd>Except for the root of course, which is parentless.</dd>
  <dt>o Each node can have any number (0 .. N) daughter nodes</dt>
  <dd>A given node's daughter nodes constitute an <i>ordered</i> list.
    <p class="Pp">However, you are free to consider this ordering irrelevant.
        Some applications do need daughters to be ordered, so I chose to
        consider this the general case.</p>
  </dd>
  <dt>o A node can appear in only one tree, and only once in that tree</dt>
  <dd>Notably (notable because it doesn't follow from the two above points), a
      node cannot appear twice in its mother's daughter list.</dd>
  <dt>o There's an idea of up versus down</dt>
  <dd>Up means towards to the root, and down means away from the root (and
      towards the leaves).</dd>
  <dt>o There's an idea of left versus right</dt>
  <dd>Left is toward the start (index 0) of a given node's daughter list, and
      right is toward the end of a given node's daughter list.</dd>
</dl>
<p class="Pp">Trees as described above have various applications, among them:
    representing syntactic constituency, in formal linguistics; representing
    contingencies in a game tree; representing abstract syntax in the parsing of
    any computer language -- whether in expression trees for programming
    languages, or constituency in the parse of a markup language document. (Some
    of these might not use the fact that daughters are ordered.)</p>
<p class="Pp">(Note: B-Trees are a very special case of the above kinds of
    trees, and are best treated with their own class. Check CPAN for modules
    encapsulating B-Trees; or if you actually want a database, and for some
    reason ended up looking here, go look at AnyDBM_File.)</p>
<p class="Pp">Many base classes are not usable except as such -- but
    <span class="Li">&quot;Tree::DAG_Node&quot;</span> can be used as a normal
    class. You can go ahead and say:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        use Tree::DAG_Node;
        my $root = Tree::DAG_Node-&gt;new();
        $root-&gt;name(&quot;I'm the tops&quot;);
        $new_daughter = Tree::DAG_Node-&gt;new();
        $new_daughter-&gt;name(&quot;More&quot;);
        $root-&gt;add_daughter($new_daughter);
</pre>
<p class="Pp">and so on, constructing and linking objects from
    <span class="Li">&quot;Tree::DAG_Node&quot;</span> and making useful tree
    structures out of them.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="A_NOTE_TO_THE_READER"><a class="permalink" href="#A_NOTE_TO_THE_READER">A
  NOTE TO THE READER</a></h1>
This class is big and provides lots of methods. If your problem is simple (say,
  just representing a simple parse tree), this class might seem like using an
  atomic sledgehammer to swat a fly. But the complexity of this module's bells
  and whistles shouldn't detract from the efficiency of using this class for a
  simple purpose. In fact, I'd be very surprised if any one user ever had use
  for more that even a third of the methods in this class. And remember: an
  atomic sledgehammer <b>will</b> kill that fly.
</section>
<section class="Sh">
<h1 class="Sh" id="OBJECT_CONTENTS"><a class="permalink" href="#OBJECT_CONTENTS">OBJECT
  CONTENTS</a></h1>
Implementationally, each node in a tree is an object, in the sense of being an
  arbitrarily complex data structure that belongs to a class (presumably
  <span class="Li">&quot;Tree::DAG_Node&quot;</span>, or ones derived from it)
  that provides methods.
<p class="Pp">The attributes of a node-object are:</p>
<dl class="Bl-tag">
  <dt>o mother -- this node's mother. undef if this is a root</dt>
  <dd></dd>
  <dt>o daughters -- the (possibly empty) list of daughters of this node</dt>
  <dd></dd>
  <dt>o name -- the name for this node</dt>
  <dd>Need not be unique, or even printable. This is printed in some of the
      various dumper methods, but it's up to you if you don't put anything
      meaningful or printable here.</dd>
  <dt>o attributes -- whatever the user wants to use it for</dt>
  <dd>Presumably a hashref to whatever other attributes the user wants to store
      without risk of colliding with the object's real attributes. (Example
      usage: attributes to an SGML tag -- you definitely wouldn't want the
      existence of a &quot;mother=foo&quot; pair in such a tag to collide with a
      node object's 'mother' attribute.)
    <p class="Pp">Aside from (by default) initializing it to {}, and having the
        access method called &quot;attributes&quot; (described a ways below), I
        don't do anything with the &quot;attributes&quot; in this module. I
        basically intended this so that users who don't want/need to bother
        deriving a class from
        <span class="Li">&quot;Tree::DAG_Node&quot;</span>, could still attach
        whatever data they wanted in a node.</p>
  </dd>
</dl>
<p class="Pp">&quot;mother&quot; and &quot;daughters&quot; are attributes that
    relate to linkage -- they are never written to directly, but are changed as
    appropriate by the &quot;linkage methods&quot;, discussed below.</p>
<p class="Pp">The other two (and whatever others you may add in derived classes)
    are simply accessed thru the same-named methods, discussed further
  below.</p>
<section class="Ss">
<h2 class="Ss" id="About_The_Documented_Interface"><a class="permalink" href="#About_The_Documented_Interface">About
  The Documented Interface</a></h2>
Stick to the documented interface (and comments in the source -- especially ones
  saying &quot;undocumented!&quot; and/or &quot;disfavored!&quot; -- do not
  count as documentation!), and don't rely on any behavior that's not in the
  documented interface.
<p class="Pp">Specifically, unless the documentation for a particular method
    says &quot;this method returns thus-and-such a value&quot;, then you should
    not rely on it returning anything meaningful.</p>
<p class="Pp">A <i>passing</i> acquaintance with at least the broader details of
    the source code for this class is assumed for anyone using this class as a
    base class -- especially if you're overriding existing methods, and
    <b>definitely</b> if you're overriding linkage methods.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="MAIN_CONSTRUCTOR,_AND_INITIALIZER"><a class="permalink" href="#MAIN_CONSTRUCTOR,_AND_INITIALIZER">MAIN
  CONSTRUCTOR, AND INITIALIZER</a></h1>
<dl class="Bl-tag">
  <dt>the constructor CLASS-&gt;<i>new()</i> or CLASS-&gt;new($options)</dt>
  <dd>This creates a new node object, calls
      <span class="Li">$object</span>-&gt;_init($options) to provide it sane
      defaults (like: undef name, undef mother, no daughters, 'attributes'
      setting of a new empty hashref), and returns the object created. (If you
      just said &quot;CLASS-&gt;<i>new()</i>&quot; or &quot;CLASS-&gt;new&quot;,
      then it pretends you called &quot;CLASS-&gt;new({})&quot;.)
    <p class="Pp">Currently no options for putting in hashref
        <span class="Li">$options</span> are part of the documented interface,
        but the options is here in case you want to add such behavior in a
        derived class.</p>
    <p class="Pp">Read on if you plan on using Tree::DAG_New as a base class.
        (Otherwise feel free to skip to the description of _init.)</p>
    <p class="Pp">There are, in my mind, two ways to do object construction:</p>
    <p class="Pp">Way 1: create an object, knowing that it'll have certain
        uninteresting sane default values, and then call methods to change those
        values to what you want. Example:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $node = Tree::DAG_Node-&gt;new;
    $node-&gt;name('Supahnode!');
    $root-&gt;add_daughter($node);
    $node-&gt;add_daughters(@some_others)
    </pre>
    <p class="Pp">Way 2: be able to specify some/most/all the object's
        attributes in the call to the constructor. Something like:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    $node = Tree::DAG_Node-&gt;new({
      name =&gt; 'Supahnode!',
      mother =&gt; $root,
      daughters =&gt; \@some_others
    });
    </pre>
    <p class="Pp">After some deliberation, I've decided that the second way is a
        Bad Thing. First off, it is <b>not</b> markedly more concise than the
        first way. Second off, it often requires subtly different syntax (e.g.,
        \@some_others vs <span class="Li">@some_others</span>). It just
        complicates things for the programmer and the user, without making
        either appreciably happier.</p>
    <p class="Pp">See however the comments under &quot;new($hashref)&quot; for
        options newly supported in the call to <i>new()</i>.</p>
    <p class="Pp">(This is not to say that options in general for a constructor
        are bad -- &quot;random_network($options)&quot;, discussed far below,
        necessarily takes options. But note that those are not options for the
        default values of attributes.)</p>
    <p class="Pp">Anyway, if you use
        <span class="Li">&quot;Tree::DAG_Node&quot;</span> as a superclass, and
        you add attributes that need to be initialized, what you need to do is
        provide an _init method that calls
        <span class="Li">$this</span>-&gt;SUPER::_init($options) to use its
        superclass's _init method, and then initializes the new attributes:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  sub _init {
    my($this, $options) = @_[0,1];
    $this-&gt;SUPER::_init($options); # call my superclass's _init to
      # init all the attributes I'm inheriting

    # Now init /my/ new attributes:
    $this-&gt;{'amigos'} = []; # for example
  }
    </pre>
    <p class="Pp">...or, as I prefer when I'm being a neat freak:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  sub _init {
    my($this, $options) = @_[0,1];
    $this-&gt;SUPER::_init($options);

    $this-&gt;_init_amigos($options);
  }

  sub _init_amigos {
    my $this = $_[0];
    # Or my($this,$options) = @_[0,1]; if I'm using $options
    $this-&gt;{'amigos'} = [];
  }
    </pre>
    <p class="Pp">In other words, I like to have each attribute initialized thru
        a method named _init_[attribute], which should expect the object as
        <span class="Li">$_</span>[0] and the options hashref (or {} if none was
        given) as <span class="Li">$_</span>[1]. If you insist on having your
        _init recognize options for setting attributes, you might as well have
        them dealt with by the appropriate _init_[attribute] method, like
      this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  sub _init {
    my($this, $options) = @_[0,1];
    $this-&gt;SUPER::_init($options);

    $this-&gt;_init_amigos($options);
  }

  sub _init_amigos {
    my($this,$options) = @_[0,1]; # I need options this time
    $this-&gt;{'amigos'} = [];
    $this-&gt;amigos(@{$options-&gt;{'amigos'}}) if $options-&gt;{'amigos'};
  }
    </pre>
    <p class="Pp">All this bookkeeping looks silly with just one new attribute
        in a class derived straight from
        <span class="Li">&quot;Tree::DAG_Node&quot;</span>, but if there's lots
        of new attributes running around, and if you're deriving from a class
        derived from a class derived from
        <span class="Li">&quot;Tree::DAG_Node&quot;</span>, then tidy
        stratification/modularization like this can keep you sane.</p>
  </dd>
  <dt>the constructor $obj-&gt;<i>new()</i> or $obj-&gt;new($options)</dt>
  <dd>Just another way to get at the &quot;new($hashref)&quot; method. This
      <b>does not copy</b> <span class="Li">$obj</span>, but merely constructs a
      new object of the same class as it. Saves you the bother of going
      <span class="Li">$class</span> = ref <span class="Li">$obj</span>;
      <span class="Li">$obj2</span> =
    <span class="Li">$class</span>-&gt;new;</dd>
  <dt>the method $node-&gt;_init($options)</dt>
  <dd>Initialize the object's attribute values. See the discussion above.
      Presumably this should be called only by the guts of the
      &quot;new($hashref)&quot; constructor -- never by the end user.
    <p class="Pp">Currently there are no documented options for putting in the
        <span class="Li">$options</span> hashref, but (in case you want to
        disregard the above rant) the option exists for you to use
        <span class="Li">$options</span> for something useful in a derived
        class.</p>
    <p class="Pp">Please see the source for more information.</p>
  </dd>
  <dt>see also (below) the constructors &quot;new_daughter&quot; and
    &quot;new_daughter_left&quot;</dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="add_daughter(_s-1LIST_s0)"><a class="permalink" href="#add_daughter(_s-1LIST_s0)">add_daughter(LIST)</a></h2>
An exact synonym for &quot;add_daughters(LIST)&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id="add_daughters(_s-1LIST_s0)"><a class="permalink" href="#add_daughters(_s-1LIST_s0)">add_daughters(LIST)</a></h2>
This method adds the node objects in LIST to the (right) end of
  <span class="Li">$mother</span>'s <i>daughter</i> list. Making a node N1 the
  daughter of another node N2 also means that N1's <i>mother</i> attribute is
  &quot;automatically&quot; set to N2; it also means that N1 stops being
  anything else's daughter as it becomes N2's daughter.
<p class="Pp">If you try to make a node its own mother, a fatal error results.
    If you try to take one of a node N1's ancestors and make it also a daughter
    of N1, a fatal error results. A fatal error results if anything in LIST
    isn't a node object.</p>
<p class="Pp">If you try to make N1 a daughter of N2, but it's <b>already</b> a
    daughter of N2, then this is a no-operation -- it won't move such nodes to
    the end of the list or anything; it just skips doing anything with them.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_daughter_left(_s-1LIST_s0)"><a class="permalink" href="#add_daughter_left(_s-1LIST_s0)">add_daughter_left(LIST)</a></h2>
An exact synonym for &quot;add_daughters_left(LIST)&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id="add_daughters_left(_s-1LIST_s0)"><a class="permalink" href="#add_daughters_left(_s-1LIST_s0)">add_daughters_left(LIST)</a></h2>
This method is just like &quot;add_daughters(LIST)&quot;, except that it adds
  the node objects in LIST to the (left) beginning of
  <span class="Li">$mother</span>'s daughter list, instead of the (right) end of
  it.
</section>
<section class="Ss">
<h2 class="Ss" id="add_left_sister(_s-1LIST_s0)"><a class="permalink" href="#add_left_sister(_s-1LIST_s0)">add_left_sister(LIST)</a></h2>
An exact synonym for &quot;add_left_sisters(LIST)&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id="add_left_sisters(_s-1LIST_s0)"><a class="permalink" href="#add_left_sisters(_s-1LIST_s0)">add_left_sisters(LIST)</a></h2>
This adds the elements in LIST (in that order) as immediate left sisters of
  <span class="Li">$node</span>. In other words, given that B's mother's
  daughter-list is (A,B,C,D), calling B-&gt;add_left_sisters(X,Y) makes B's
  mother's daughter-list (A,X,Y,B,C,D).
<p class="Pp">If LIST is empty, this is a no-op, and returns empty-list.</p>
<p class="Pp">This is basically implemented as a call to
    <span class="Li">$node</span>-&gt;replace_with(LIST,
    <span class="Li">$node</span>), and so all replace_with's limitations and
    caveats apply.</p>
<p class="Pp">The return value of
    <span class="Li">$node</span>-&gt;add_left_sisters(LIST) is the elements of
    LIST that got added, as returned by replace_with -- minus the copies of
    <span class="Li">$node</span> you'd get from a straight call to
    <span class="Li">$node</span>-&gt;replace_with(LIST,
    <span class="Li">$node</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="add_right_sister(_s-1LIST_s0)"><a class="permalink" href="#add_right_sister(_s-1LIST_s0)">add_right_sister(LIST)</a></h2>
An exact synonym for &quot;add_right_sisters(LIST)&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id="add_right_sisters(_s-1LIST_s0)"><a class="permalink" href="#add_right_sisters(_s-1LIST_s0)">add_right_sisters(LIST)</a></h2>
Just like add_left_sisters (which see), except that the elements in LIST (in
  that order) as immediate <b>right</b> sisters of
  <span class="Li">$node</span>;
<p class="Pp">In other words, given that B's mother's daughter-list is
    (A,B,C,D), calling B-&gt;add_right_sisters(X,Y) makes B's mother's
    daughter-list (A,B,X,Y,C,D).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIaddress()_fP"><a class="permalink" href="#_fIaddress()_fP"><i>address()</i></a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="address(_s-1ADDRESS_s0)"><a class="permalink" href="#address(_s-1ADDRESS_s0)">address(ADDRESS)</a></h2>
With the first syntax, returns the address of <span class="Li">$node</span>
  within its tree, based on its position within the tree. An address is formed
  by noting the path between the root and <span class="Li">$node</span>, and
  concatenating the daughter-indices of the nodes this passes thru (starting
  with 0 for the root, and ending with <span class="Li">$node</span>).
<p class="Pp">For example, if to get from node ROOT to node
    <span class="Li">$node</span>, you pass thru ROOT, A, B, and
    <span class="Li">$node</span>, then the address is determined as:</p>
<dl class="Bl-tag">
  <dt>o ROOT's my_daughter_index is 0</dt>
  <dd></dd>
  <dt>o A's my_daughter_index is, suppose, 2</dt>
  <dd>A is index 2 in ROOT's daughter list.</dd>
  <dt>o B's my_daughter_index is, suppose, 0</dt>
  <dd>B is index 0 in A's daughter list.</dd>
  <dt>o $node's my_daughter_index is, suppose, 4</dt>
  <dd><span class="Li">$node</span> is index 4 in B's daughter list.</dd>
</dl>
<p class="Pp">The address of the above-described <span class="Li">$node</span>
    is, therefore, &quot;0:2:0:4&quot;.</p>
<p class="Pp">(As a somewhat special case, the address of the root is always
    &quot;0&quot;; and since addresses start from the root, all addresses start
    with a &quot;0&quot;.)</p>
<p class="Pp">The second syntax, where you provide an address, starts from the
    root of the tree <span class="Li">$anynode</span> belongs to, and returns
    the node corresponding to that address. Returns undef if no node corresponds
    to that address. Note that this routine may be somewhat liberal in its
    interpretation of what can constitute an address; i.e., it accepts
    &quot;0.2.0.4&quot;, besides &quot;0:2:0:4&quot;.</p>
<p class="Pp">Also note that the address of a node in a tree is meaningful only
    in that tree as currently structured.</p>
<p class="Pp">(Consider how ($address1 cmp <span class="Li">$address2</span>)
    may be magically meaningful to you, if you meant to figure out what nodes
    are to the right of what other nodes.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIancestors()_fP"><a class="permalink" href="#_fIancestors()_fP"><i>ancestors()</i></a></h2>
Returns the list of this node's ancestors, starting with its mother, then
  grandmother, and ending at the root. It does this by simply following the
  'mother' attributes up as far as it can. So if <span class="Li">$item</span>
  IS the root, this returns an empty list.
<p class="Pp">Consider that scalar($node-&gt;ancestors) returns the ply of this
    node within the tree -- 2 for a granddaughter of the root, etc., and 0 for
    root itself.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIattribute()_fP"><a class="permalink" href="#_fIattribute()_fP"><i>attribute()</i></a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="attribute(_s-1SCALAR_s0)"><a class="permalink" href="#attribute(_s-1SCALAR_s0)">attribute(SCALAR)</a></h2>
Exact synonyms for &quot;<i>attributes()</i>&quot; and
  &quot;attributes(SCALAR)&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id="_fIattributes()_fP"><a class="permalink" href="#_fIattributes()_fP"><i>attributes()</i></a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="attributes(_s-1SCALAR_s0)"><a class="permalink" href="#attributes(_s-1SCALAR_s0)">attributes(SCALAR)</a></h2>
In the first form, returns the value of the node object's &quot;attributes&quot;
  attribute. In the second form, sets it to the value of SCALAR. I intend this
  to be used to store a reference to a (presumably anonymous) hash the user can
  use to store whatever attributes he doesn't want to have to store as object
  attributes. In this case, you needn't ever set the value of this. (_init has
  already initialized it to {}.) Instead you can just do...
<p class="Pp"><span class="Li"></span></p>
<pre>
  $node-&gt;attributes-&gt;{'foo'} = 'bar';
</pre>
<p class="Pp">...to write foo =&gt; bar.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIclear_daughters()_fP"><a class="permalink" href="#_fIclear_daughters()_fP"><i>clear_daughters()</i></a></h2>
This unlinks all <span class="Li">$mother</span>'s daughters. Returns the list
  of what used to be <span class="Li">$mother</span>'s daughters.
<p class="Pp">Not to be confused with &quot;remove_daughters(LIST)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="common(_s-1LIST_s0)"><a class="permalink" href="#common(_s-1LIST_s0)">common(LIST)</a></h2>
Returns the lowest node in the tree that is ancestor-or-self to the nodes
  <span class="Li">$node</span> and LIST.
<p class="Pp">If the nodes are far enough apart in the tree, the answer is just
    the root.</p>
<p class="Pp">If the nodes aren't all in the same tree, the answer is undef.</p>
<p class="Pp">As a degenerate case, if LIST is empty, returns
    <span class="Li">$node</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="common_ancestor(_s-1LIST_s0)"><a class="permalink" href="#common_ancestor(_s-1LIST_s0)">common_ancestor(LIST)</a></h2>
Returns the lowest node that is ancestor to all the nodes given (in nodes
  <span class="Li">$node</span> and LIST). In other words, it answers the
  question: &quot;What node in the tree, as low as possible, is ancestor to the
  nodes given ($node and LIST)?&quot;
<p class="Pp">If the nodes are far enough apart, the answer is just the root --
    except if any of the nodes are the root itself, in which case the answer is
    undef (since the root has no ancestor).</p>
<p class="Pp">If the nodes aren't all in the same tree, the answer is undef.</p>
<p class="Pp">As a degenerate case, if LIST is empty, returns
    <span class="Li">$node</span>'s mother; that'll be undef if
    <span class="Li">$node</span> is root.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="copy($option)"><a class="permalink" href="#copy($option)">copy($option)</a></h2>
Returns a copy the calling node (the invocant). E.g.: my($copy) =
  <span class="Li">$node</span> -&gt; copy;
<p class="Pp"><span class="Li">$option</span> is a hashref of options, with
    these (key =&gt; value) pairs:</p>
<dl class="Bl-tag">
  <dt>o no_attribute_copy =&gt; $Boolean</dt>
  <dd>If set to 1, do not copy the node's attributes.
    <p class="Pp">If not specified, defaults to 0, which copies attributes.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIcopy_at_and_under()_fP"><a class="permalink" href="#_fIcopy_at_and_under()_fP"><i>copy_at_and_under()</i></a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="copy_at_and_under($options)"><a class="permalink" href="#copy_at_and_under($options)">copy_at_and_under($options)</a></h2>
This returns a copy of the subtree consisting of <span class="Li">$node</span>
  and everything under it.
<p class="Pp">If you pass no options, copy_at_and_under pretends you've passed
    {}.</p>
<p class="Pp">This works by recursively building up the new tree from the
    leaves, duplicating nodes using
    <span class="Li">$orig_node</span>-&gt;copy($options_ref) and then linking
    them up into a new tree of the same shape.</p>
<p class="Pp">Options you specify are passed down to calls to
    <span class="Li">$node</span>-&gt;copy.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIcopy_tree()_fP"><a class="permalink" href="#_fIcopy_tree()_fP"><i>copy_tree()</i></a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="copy_tree($options)"><a class="permalink" href="#copy_tree($options)">copy_tree($options)</a></h2>
This returns the root of a copy of the tree that <span class="Li">$node</span>
  is a member of. If you pass no options, copy_tree pretends you've passed {}.
<p class="Pp">This method is currently implemented as just a call to
    <span class="Li">$this</span>-&gt;root-&gt;copy_at_and_under($options), but
    magic may be added in the future.</p>
<p class="Pp">Options you specify are passed down to calls to
    <span class="Li">$node</span>-&gt;copy.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIdaughters()_fP"><a class="permalink" href="#_fIdaughters()_fP"><i>daughters()</i></a></h2>
This returns the (possibly empty) list of daughters for
  <span class="Li">$node</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="_fIdelete_tree()_fP"><a class="permalink" href="#_fIdelete_tree()_fP"><i>delete_tree()</i></a></h2>
Destroys the entire tree that <span class="Li">$node</span> is a member of
  (starting at the root), by nulling out each node-object's attributes
  (including, most importantly, its linkage attributes -- hopefully this is more
  than sufficient to eliminate all circularity in the data structure), and then
  moving it into the class DEADNODE.
<p class="Pp">Use this when you're finished with the tree in question, and want
    to free up its memory. (If you don't do this, it'll get freed up anyway when
    your program ends.)</p>
<p class="Pp">If you try calling any methods on any of the node objects in the
    tree you've destroyed, you'll get an error like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  Can't locate object method &quot;leaves_under&quot;
    via package &quot;DEADNODE&quot;.
</pre>
<p class="Pp">So if you see that, that's what you've done wrong. (Actually, the
    class DEADNODE does provide one method: a no-op method
    &quot;delete_tree&quot;. So if you want to delete a tree, but think you may
    have deleted it already, it's safe to call
    <span class="Li">$node</span>-&gt;delete_tree on it (again).)</p>
<p class="Pp">The &quot;<i>delete_tree()</i>&quot; method is needed because
    Perl's garbage collector would never (as currently implemented) see that it
    was time to de-allocate the memory the tree uses -- until either you call
    <span class="Li">$node</span>-&gt;delete_tree, or until the program stops
    (at &quot;global destruction&quot; time, when <b>everything</b> is
    unallocated).</p>
<p class="Pp">Incidentally, there are better ways to do garbage-collecting on a
    tree, ways which don't require the user to explicitly call a method like
    &quot;<i>delete_tree()</i>&quot; -- they involve dummy classes, as explained
    at &lt;http://mox.perl.com/misc/circle-destroy.pod&gt;</p>
<p class="Pp">However, introducing a dummy class concept into
    <span class="Li">&quot;Tree::DAG_Node&quot;</span> would be rather a
    distraction. If you want to do this with your derived classes, via a DESTROY
    in a dummy class (or in a tree-metainformation class, maybe), then feel free
    to.</p>
<p class="Pp">The only case where I can imagine &quot;<i>delete_tree()</i>&quot;
    failing to totally void the tree, is if you use the hashref in the
    &quot;attributes&quot; attribute to store (presumably among other things)
    references to other nodes' &quot;attributes&quot; hashrefs -- which 1) is
    maybe a bit odd, and 2) is your problem, because it's your hash structure
    that's circular, not the tree's. Anyway, consider:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
      # null out all my &quot;attributes&quot; hashes
      $anywhere-&gt;root-&gt;walk_down({
        'callback' =&gt; sub {
          $hr = $_[0]-&gt;attributes; %$hr = (); return 1;
        }
      });
      # And then:
      $anywhere-&gt;delete_tree;
</pre>
<p class="Pp">(I suppose &quot;<i>delete_tree()</i>&quot; is a
    &quot;destructor&quot;, or as close as you can meaningfully come for a
    circularity-rich data structure in Perl.)</p>
<p class="Pp">See also &quot;WHEN AND HOW TO DESTROY THE TREE&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIdepth_under()_fP"><a class="permalink" href="#_fIdepth_under()_fP"><i>depth_under()</i></a></h2>
Returns an integer representing the number of branches between this
  <span class="Li">$node</span> and the most distant leaf under it. (In other
  words, this returns the ply of subtree starting of
  <span class="Li">$node</span>. Consider scalar($it-&gt;ancestors) if you want
  the ply of a node within the whole tree.)
</section>
<section class="Ss">
<h2 class="Ss" id="_fIdescendants()_fP"><a class="permalink" href="#_fIdescendants()_fP"><i>descendants()</i></a></h2>
Returns a list consisting of all the descendants of
  <span class="Li">$node</span>. Returns empty-list if
  <span class="Li">$node</span> is a terminal_node.
<p class="Pp">(Note that it's spelled &quot;descendants&quot;, not
    &quot;descendents&quot;.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="draw_ascii_tree(_$options_)"><a class="permalink" href="#draw_ascii_tree(_$options_)">draw_ascii_tree([$options])</a></h2>
Here, the [] refer to an optional parameter.
<p class="Pp">Returns an arrayref of lines suitable for printing.</p>
<p class="Pp">Draws a nice ASCII-art representation of the tree structure.</p>
<p class="Pp">The tree looks like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                     |
                  &lt;Root&gt;
           /-------+-----+---+---\
           |       |     |   |   |
          &lt;I&gt;     &lt;H&gt;   &lt;D&gt; &lt;E&gt; &lt;B&gt;
         /---\   /---\   |   |   |
         |   |   |   |  &lt;F&gt; &lt;F&gt; &lt;C&gt;
        &lt;J&gt; &lt;J&gt; &lt;J&gt; &lt;J&gt;  |   |
         |   |   |   |  &lt;G&gt; &lt;G&gt;
        &lt;K&gt; &lt;L&gt; &lt;K&gt; &lt;L&gt;
             |       |
            &lt;M&gt;     &lt;M&gt;
             |       |
            &lt;N&gt;     &lt;N&gt;
             |       |
            &lt;O&gt;     &lt;O&gt;
</pre>
<p class="Pp">See scripts/cut.and.paste.subtrees.pl.</p>
<p class="Pp">Example usage:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  print map(&quot;$_\n&quot;, @{$tree-&gt;draw_ascii_tree});
</pre>
<p class="Pp"><i></i><i>draw_ascii_tree()</i><i></i> takes parameters you set in
    the <span class="Li">$options</span> hashref:</p>
<dl class="Bl-tag">
  <dt>o h_compact</dt>
  <dd>Takes 0 or 1. Sets the extent to which
      <i></i><i>draw_ascii_tree()</i><i></i> tries to save horizontal space.
    <p class="Pp">If I think of a better scrunching algorithm, there'll be a
        &quot;2&quot; setting for this.</p>
    <p class="Pp">Default: 1.</p>
  </dd>
  <dt>o h_spacing</dt>
  <dd>Takes a number 0 or greater. Sets the number of spaces inserted
      horizontally between nodes (and groups of nodes) in a tree.
    <p class="Pp">Default: 1.</p>
  </dd>
  <dt>o no_name</dt>
  <dd>If true, <i></i><i>draw_ascii_tree()</i><i></i> doesn't print the name of
      the node; it simply prints a &quot;*&quot;.
    <p class="Pp">Default: 0 (i.e., print the node name.)</p>
  </dd>
  <dt>o v_compact</dt>
  <dd>Takes a number 0, 1, or 2. Sets the degree to which
      <i></i><i>draw_ascii_tree()</i><i></i> tries to save vertical space.
      Defaults to 1.</dd>
</dl>
<p class="Pp">The code occasionally returns trees that are a bit cock-eyed in
    parts; if anyone can suggest a better drawing algorithm, I'd be
    appreciative.</p>
<p class="Pp">See also &quot;tree2string([$options], [$some_tree])&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="dump_names($options)"><a class="permalink" href="#dump_names($options)">dump_names($options)</a></h2>
Returns an array.
<p class="Pp">Dumps, as an indented list, the names of the nodes starting at
    <span class="Li">$node</span>, and continuing under it. Options are:</p>
<dl class="Bl-tag">
  <dt>o _depth -- A nonnegative number</dt>
  <dd>Indicating the depth to consider <span class="Li">$node</span> as being at
      (and so the generation under that is that plus one, etc.). You may choose
      to use set _depth =&gt; scalar($node-&gt;ancestors).
    <p class="Pp">Default: 0.</p>
  </dd>
  <dt>o tick -- a string to preface each entry with</dt>
  <dd>This string goes between the indenting-spacing and the node's name. You
      may prefer &quot;*&quot; or &quot;-&gt; &quot; or something.
    <p class="Pp">Default: ''.</p>
  </dd>
  <dt>o indent -- the string used to indent with</dt>
  <dd>Another sane value might be '. ' (period, space). Setting it to
      empty-string suppresses indenting.
    <p class="Pp">Default: ' ' x 2.</p>
  </dd>
</dl>
<p class="Pp">The output is not printed, but is returned as a list, where each
    item is a line, with a &quot;\n&quot; at the end.</p>
<p class="Pp">Note: Names are converted to a printable form using the
    undocumented function <i>_dump_quote()</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="format_node(_$options_,__$node_)"><a class="permalink" href="#format_node(_$options_,__$node_)">format_node([$options],
  [$node])</a></h2>
Here, [] represent optional parameters.
<p class="Pp">Returns a string consisting of the node's name and, optionally,
    it's attributes.</p>
<p class="Pp">Possible keys in the <span class="Li">$options</span> hashref:</p>
<dl class="Bl-tag">
  <dt>o no_attributes =&gt; $Boolean</dt>
  <dd>If 1, the node's attributes are not included in the string returned.
    <p class="Pp">Default: 0 (include attributes).</p>
  </dd>
</dl>
<p class="Pp">Calls &quot;hashref2string($hashref)&quot;.</p>
<p class="Pp">Called by &quot;node2string([$options], [$node])&quot;.</p>
<p class="Pp">You would not normally call this method.</p>
<p class="Pp">If you don't wish to supply options, use format_node({},
    <span class="Li">$node</span>).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIgeneration()_fP"><a class="permalink" href="#_fIgeneration()_fP"><i>generation()</i></a></h2>
Returns a list of all nodes (going left-to-right) that are in
  <span class="Li">$node</span>'s generation -- i.e., that are the some number
  of nodes down from the root.
  <span class="Li">$root</span>-&gt;<i>generation()</i> is just
  <span class="Li">$root</span>.
<p class="Pp">Of course, <span class="Li">$node</span> is always in its own
    generation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="generation_under($node)"><a class="permalink" href="#generation_under($node)">generation_under($node)</a></h2>
Like &quot;<i>generation()</i>&quot;, but returns only the nodes in
  <span class="Li">$node</span>'s generation that are also descendants of
  <span class="Li">$node</span> -- in other words,
<p class="Pp"><span class="Li"></span></p>
<pre>
    @us = $node-&gt;generation_under( $node-&gt;mother-&gt;mother );
</pre>
<p class="Pp">is all <span class="Li">$node</span>'s first cousins (to borrow
    yet more kinship terminology) -- assuming <span class="Li">$node</span> does
    indeed have a grandmother. Actually &quot;cousins&quot; isn't quite an apt
    word, because <span class="Li">@us</span> ends up including
    <span class="Li">$node</span>'s siblings and
  <span class="Li">$node</span>.</p>
<p class="Pp">Actually, &quot;generation_under($node)&quot; is just an alias to
    &quot;<i>generation()</i>&quot;, but I figure that this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   @us = $node-&gt;generation_under($way_upline);
</pre>
<p class="Pp">is a bit more readable than this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   @us = $node-&gt;generation($way_upline);
</pre>
<p class="Pp">But it's up to you.</p>
<p class="Pp"><span class="Li">$node</span>-&gt;generation_under($node) returns
    just <span class="Li">$node</span>.</p>
<p class="Pp">If you call
    <span class="Li">$node</span>-&gt;generation_under($node) but NODE2 is not
    <span class="Li">$node</span> or an ancestor of
    <span class="Li">$node</span>, it behaves as if you called just
    <span class="Li">$node</span>-&gt;<i>generation()</i>.</p>
<p class="Pp">head2 hashref2string($hashref)</p>
<p class="Pp">Returns the given hashref as a string.</p>
<p class="Pp">Called by &quot;format_node([$options], [$node])&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="is_daughter_of($node2)"><a class="permalink" href="#is_daughter_of($node2)">is_daughter_of($node2)</a></h2>
Returns true iff <span class="Li">$node</span> is a daughter of
  <span class="Li">$node2</span>. Currently implemented as just a test of
  ($it-&gt;mother eq <span class="Li">$node2</span>).
</section>
<section class="Ss">
<h2 class="Ss" id="_fIis_node()_fP"><a class="permalink" href="#_fIis_node()_fP"><i>is_node()</i></a></h2>
This always returns true. More pertinently,
  <span class="Li">$object</span>-&gt;can('is_node') is true (regardless of what
  &quot;<i>is_node()</i>&quot; would do if called) for objects belonging to this
  class or for any class derived from it.
</section>
<section class="Ss">
<h2 class="Ss" id="_fIis_root()_fP"><a class="permalink" href="#_fIis_root()_fP"><i>is_root()</i></a></h2>
Returns 1 if the caller is the root, and 0 if it is not.
</section>
<section class="Ss">
<h2 class="Ss" id="_fIleaves_under()_fP"><a class="permalink" href="#_fIleaves_under()_fP"><i>leaves_under()</i></a></h2>
Returns a list (going left-to-right) of all the leaf nodes under
  <span class="Li">$node</span>. (&quot;Leaf nodes&quot; are also called
  &quot;terminal nodes&quot; -- i.e., nodes that have no daughters.) Returns
  <span class="Li">$node</span> in the degenerate case of
  <span class="Li">$node</span> being a leaf itself.
</section>
<section class="Ss">
<h2 class="Ss" id="_fIleft_sister()_fP"><a class="permalink" href="#_fIleft_sister()_fP"><i>left_sister()</i></a></h2>
Returns the node that's the immediate left sister of
  <span class="Li">$node</span>. If <span class="Li">$node</span> is the
  leftmost (or only) daughter of its mother (or has no mother), then this
  returns undef.
<p class="Pp">See also &quot;add_left_sisters(LIST)&quot; and
    &quot;add_right_sisters(LIST)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIleft_sisters()_fP"><a class="permalink" href="#_fIleft_sisters()_fP"><i>left_sisters()</i></a></h2>
Returns a list of nodes that're sisters to the left of
  <span class="Li">$node</span>. If <span class="Li">$node</span> is the
  leftmost (or only) daughter of its mother (or has no mother), then this
  returns an empty list.
<p class="Pp">See also &quot;add_left_sisters(LIST)&quot; and
    &quot;add_right_sisters(LIST)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="lol_to_tree($lol)"><a class="permalink" href="#lol_to_tree($lol)">lol_to_tree($lol)</a></h2>
This must be called as a class method.
<p class="Pp">Converts something like bracket-notation for &quot;Chomsky
    trees&quot; (or rather, the closest you can come with Perl
    list-of-lists(-of-lists(-of-lists))) into a tree structure. Returns the root
    of the tree converted.</p>
<p class="Pp">The conversion rules are that: 1) if the last (possibly the only)
    item in a given list is a scalar, then that is used as the &quot;name&quot;
    attribute for the node based on this list. 2) All other items in the list
    represent daughter nodes of the current node -- recursively so, if they are
    list references; otherwise, (non-terminal) scalars are considered to denote
    nodes with that name. So ['Foo', 'Bar', 'N'] is an alternate way to
    represent [['Foo'], ['Bar'], 'N'].</p>
<p class="Pp">An example will illustrate:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Tree::DAG_Node;
  $lol =
    [
      [
        [ [ 'Det:The' ],
          [ [ 'dog' ], 'N'], 'NP'],
        [ '/with rabies\\', 'PP'],
        'NP'
      ],
      [ 'died', 'VP'],
      'S'
    ];
   $tree = Tree::DAG_Node-&gt;lol_to_tree($lol);
   $diagram = $tree-&gt;draw_ascii_tree;
   print map &quot;$_\n&quot;, @$diagram;
</pre>
<p class="Pp">...returns this tree:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
                   |
                  &lt;S&gt;
                   |
                /------------------\
                |                  |
              &lt;NP&gt;                &lt;VP&gt;
                |                  |
        /---------------\        &lt;died&gt;
        |               |
      &lt;NP&gt;            &lt;PP&gt;
        |               |
     /-------\   &lt;/with rabies\&gt;
     |       |
 &lt;Det:The&gt;  &lt;N&gt;
             |
           &lt;dog&gt;
</pre>
<p class="Pp">By the way (and this rather follows from the above rules), when
    denoting a LoL tree consisting of just one node, this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $tree = Tree::DAG_Node-&gt;lol_to_tree( 'Lonely' );
</pre>
<p class="Pp">is okay, although it'd probably occur to you to denote it only
  as:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $tree = Tree::DAG_Node-&gt;lol_to_tree( ['Lonely'] );
</pre>
<p class="Pp">which is of course fine, too.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fImother()_fP"><a class="permalink" href="#_fImother()_fP"><i>mother()</i></a></h2>
This returns what node is <span class="Li">$node</span>'s mother. This is undef
  if <span class="Li">$node</span> has no mother -- i.e., if it is a root.
<p class="Pp">See also &quot;<i>is_root()</i>&quot; and
    &quot;<i>root()</i>&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fImy_daughter_index()_fP"><a class="permalink" href="#_fImy_daughter_index()_fP"><i>my_daughter_index()</i></a></h2>
Returns what index this daughter is, in its mother's
  <span class="Li">&quot;daughter&quot;</span> list. In other words, if
  <span class="Li">$node</span> is ($node-&gt;mother-&gt;daughters)[3], then
  <span class="Li">$node</span>-&gt;my_daughter_index returns 3.
<p class="Pp">As a special case, returns 0 if <span class="Li">$node</span> has
    no mother.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIname()_fP"><a class="permalink" href="#_fIname()_fP"><i>name()</i></a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="name(_s-1SCALAR_s0)"><a class="permalink" href="#name(_s-1SCALAR_s0)">name(SCALAR)</a></h2>
In the first form, returns the value of the node object's &quot;name&quot;
  attribute. In the second form, sets it to the value of SCALAR.
</section>
<section class="Ss">
<h2 class="Ss" id="new($hashref)"><a class="permalink" href="#new($hashref)">new($hashref)</a></h2>
These options are supported in <span class="Li">$hashref:</span>
<dl class="Bl-tag">
  <dt>o attributes =&gt; A hashref of attributes</dt>
  <dd></dd>
  <dt>o daughters =&gt; An arrayref of nodes</dt>
  <dd></dd>
  <dt>o mother =&gt; A node</dt>
  <dd></dd>
  <dt>o name =&gt; A string</dt>
  <dd></dd>
</dl>
<p class="Pp">See also &quot;MAIN CONSTRUCTOR, AND INITIALIZER&quot; for a long
    discussion on object creation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fInew_daughter()_fP"><a class="permalink" href="#_fInew_daughter()_fP"><i>new_daughter()</i></a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="new_daughter($options)"><a class="permalink" href="#new_daughter($options)">new_daughter($options)</a></h2>
This <b>constructs</b> a <b>new</b> node (of the same class as
  <span class="Li">$mother</span>), and adds it to the (right) end of the
  daughter list of <span class="Li">$mother</span>. This is essentially the same
  as going
<p class="Pp"><span class="Li"></span></p>
<pre>
      $daughter = $mother-&gt;new;
      $mother-&gt;add_daughter($daughter);
</pre>
<p class="Pp">but is rather more efficient because (since
    <span class="Li">$daughter</span> is guaranteed new and isn't linked to/from
    anything), it doesn't have to check that <span class="Li">$daughter</span>
    isn't an ancestor of <span class="Li">$mother</span>, isn't already daughter
    to a mother it needs to be unlinked from, isn't already in
    <span class="Li">$mother</span>'s daughter list, etc.</p>
<p class="Pp">As you'd expect for a constructor, it returns the node-object
    created.</p>
<p class="Pp"># Note that if you radically change 'mother'/'daughters'
    bookkeeping, # you may have to change this routine, since it's one of the
    places # that directly writes to 'daughters' and 'mother'.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fInew_daughter_left()_fP"><a class="permalink" href="#_fInew_daughter_left()_fP"><i>new_daughter_left()</i></a></h2>
</section>
<section class="Ss">
<h2 class="Ss" id="new_daughter_left($options)"><a class="permalink" href="#new_daughter_left($options)">new_daughter_left($options)</a></h2>
This is just like <span class="Li">$mother</span>-&gt;new_daughter, but adds the
  new daughter to the left (start) of <span class="Li">$mother</span>'s daughter
  list.
<p class="Pp"># Note that if you radically change 'mother'/'daughters'
    bookkeeping, # you may have to change this routine, since it's one of the
    places # that directly writes to 'daughters' and 'mother'.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="node2string($options,_$t,_$vert_dashes)"><a class="permalink" href="#node2string($options,_$t,_$vert_dashes)">node2string($options,
  $t, $vert_dashes)</a></h2>
Returns a string of the node's name and attributes, with a leading indent,
  suitable for printing.
<p class="Pp">Possible keys in the <span class="Li">$options</span> hashref:</p>
<dl class="Bl-tag">
  <dt>o no_attributes =&gt; $Boolean</dt>
  <dd>If 1, the node's attributes are not included in the string returned.
    <p class="Pp">Default: 0 (include attributes).</p>
  </dd>
</dl>
<p class="Pp">Calls &quot;format_node([$options], [$node])&quot;.</p>
<p class="Pp">Called by &quot;tree2string([$options], [$some_tree])&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="random_network($options)"><a class="permalink" href="#random_network($options)">random_network($options)</a></h2>
This method can be called as a class method or as an object method.
<p class="Pp">In the first case, constructs a randomly arranged network under a
    new node, and returns the root node of that tree. In the latter case,
    constructs the network under <span class="Li">$node</span>.</p>
<p class="Pp">Currently, this is implemented a bit half-heartedly, and
    half-wittedly. I basically needed to make up random-looking networks to
    stress-test the various tree-dumper methods, and so wrote this. If you
    actually want to rely on this for any application more serious than that, I
    suggest examining the source code and seeing if this does really what you
    need (say, in reliability of randomness); and feel totally free to suggest
    changes to me (especially in the form of &quot;I rewrote
    &quot;random_network($options)&quot;, here's the code...&quot;)</p>
<p class="Pp">It takes four options:</p>
<dl class="Bl-tag">
  <dt>o max_node_count -- maximum number of nodes this tree will be allowed to
    have (counting the root)</dt>
  <dd>Default: 25.</dd>
  <dt>o min_depth -- minimum depth for the tree</dt>
  <dd>Leaves can be generated only after this depth is reached, so the tree will
      be at least this deep -- unless max_node_count is hit first.
    <p class="Pp">Default: 2.</p>
  </dd>
  <dt>o max_depth -- maximum depth for the tree</dt>
  <dd>The tree will not be deeper than this.
    <p class="Pp">Default: 3 plus min_depth.</p>
  </dd>
  <dt>o max_children -- maximum number of children any mother in the tree can
    have.</dt>
  <dd>Default: 4.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="read_attributes($s)"><a class="permalink" href="#read_attributes($s)">read_attributes($s)</a></h2>
Parses the string <span class="Li">$s</span> and extracts the name and
  attributes, assuming the format is as generated by
  &quot;tree2string([$options], [$some_tree])&quot;.
<p class="Pp">This bascially means the string was generated by
    &quot;hashref2string($hashref)&quot;.</p>
<p class="Pp">Attributes may be absent, in which case they default to {}.</p>
<p class="Pp">Returns a new node with this name and these attributes.</p>
<p class="Pp">This method is for use by &quot;read_tree($file_name)&quot;.</p>
<p class="Pp">See t/tree.without.attributes.txt and t/tree.with.attributes.txt
    for sample data.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="read_tree($file_name)"><a class="permalink" href="#read_tree($file_name)">read_tree($file_name)</a></h2>
Returns the root of the tree read from <span class="Li">$file_name</span>.
<p class="Pp">The file must have been written by re-directing the output of
    &quot;tree2string([$options], [$some_tree])&quot; to a file, since it makes
    assumptions about the format of the stringified attributes.</p>
<p class="Pp"><i>read_tree()</i> works with utf-8 data. See t/read.tree.t and
    t/tree.utf8.attributes.txt.</p>
<p class="Pp">Note: To call this method you need a caller. It'll be a tree of 1
    node. The reason is that inside this method it calls various other methods,
    and for these calls it needs <span class="Li">$self</span>. That way, those
    methods can be called from anywhere, and not just from within
    <i>read_tree()</i>.</p>
<p class="Pp">For reading and writing trees to databases, see
    Tree::DAG_Node::Persist.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_daughter(_s-1LIST_s0)"><a class="permalink" href="#remove_daughter(_s-1LIST_s0)">remove_daughter(LIST)</a></h2>
An exact synonym for &quot;remove_daughters(LIST)&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id="remove_daughters(_s-1LIST_s0)"><a class="permalink" href="#remove_daughters(_s-1LIST_s0)">remove_daughters(LIST)</a></h2>
This removes the nodes listed in LIST from <span class="Li">$mother</span>'s
  daughter list. This is a no-operation if LIST is empty. If there are things in
  LIST that aren't a current daughter of <span class="Li">$mother</span>, they
  are ignored.
<p class="Pp">Not to be confused with &quot;<i>clear_daughters()</i>&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="replace_with(_s-1LIST_s0)"><a class="permalink" href="#replace_with(_s-1LIST_s0)">replace_with(LIST)</a></h2>
This replaces <span class="Li">$node</span> in its mother's daughter list, by
  unlinking <span class="Li">$node</span> and replacing it with the items in
  LIST. This returns a list consisting of <span class="Li">$node</span> followed
  by LIST, i.e., the nodes that replaced it.
<p class="Pp">LIST can include <span class="Li">$node</span> itself (presumably
    at most once). LIST can also be empty-list. However, if any items in LIST
    are sisters to <span class="Li">$node</span>, they are ignored, and are not
    in the copy of LIST passed as the return value.</p>
<p class="Pp">As you might expect for any linking operation, the items in LIST
    cannot be <span class="Li">$node</span>'s mother, or any ancestor to it; and
    items in LIST are, of course, unlinked from their mothers (if they have any)
    as they're linked to <span class="Li">$node</span>'s mother.</p>
<p class="Pp">(In the special (and bizarre) case where
    <span class="Li">$node</span> is root, this simply calls
    <span class="Li">$this</span>-&gt;unlink_from_mother on all the items in
    LIST, making them roots of their own trees.)</p>
<p class="Pp">Note that the daughter-list of <span class="Li">$node</span> is
    not necessarily affected; nor are the daughter-lists of the items in LIST. I
    mention this in case you think replace_with switches one node for another,
    with respect to its mother list <b>and</b> its daughter list, leaving the
    rest of the tree unchanged. If that's what you want, replacing
    <span class="Li">$Old</span> with <span class="Li">$New</span>, then you
    want:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $New-&gt;set_daughters($Old-&gt;clear_daughters);
  $Old-&gt;replace_with($New);
</pre>
<p class="Pp">(I can't say <span class="Li">$node</span>'s and LIST-items'
    daughter lists are <b>never</b> affected my replace_with -- they can be
    affected in this case:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $N1 = ($node-&gt;daughters)[0]; # first daughter of $node
  $N2 = ($N1-&gt;daughters)[0];   # first daughter of $N1;
  $N3 = Tree::DAG_Node-&gt;random_network; # or whatever
  $node-&gt;replace_with($N1, $N2, $N3);
</pre>
<p class="Pp">As a side affect of attaching <span class="Li">$N1</span> and
    <span class="Li">$N2</span> to <span class="Li">$node</span>'s mother,
    they're unlinked from their parents ($node, and <span class="Li">$N1</span>,
    respectively). But N3's daughter list is unaffected.</p>
<p class="Pp">In other words, this method does what it has to, as you'd expect
    it to.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIreplace_with_daughters()_fP"><a class="permalink" href="#_fIreplace_with_daughters()_fP"><i>replace_with_daughters()</i></a></h2>
This replaces <span class="Li">$node</span> in its mother's daughter list, by
  unlinking <span class="Li">$node</span> and replacing it with its daughters.
  In other words, <span class="Li">$node</span> becomes motherless and
  daughterless as its daughters move up and take its place. This returns a list
  consisting of <span class="Li">$node</span> followed by the nodes that were
  its daughters.
<p class="Pp">In the special (and bizarre) case where
    <span class="Li">$node</span> is root, this simply unlinks its daughters
    from it, making them roots of their own trees.</p>
<p class="Pp">Effectively the same as
    <span class="Li">$node</span>-&gt;replace_with($node-&gt;daughters), but
    more efficient, since less checking has to be done. (And I also think
    <span class="Li">$node</span>-&gt;replace_with_daughters is a more common
    operation in tree-wrangling than
    <span class="Li">$node</span>-&gt;replace_with(LIST), so deserves a named
    method of its own, but that's just me.)</p>
<p class="Pp"># Note that if you radically change 'mother'/'daughters'
    bookkeeping, # you may have to change this routine, since it's one of the
    places # that directly writes to 'daughters' and 'mother'.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIright_sister()_fP"><a class="permalink" href="#_fIright_sister()_fP"><i>right_sister()</i></a></h2>
Returns the node that's the immediate right sister of
  <span class="Li">$node</span>. If <span class="Li">$node</span> is the
  rightmost (or only) daughter of its mother (or has no mother), then this
  returns undef.
<p class="Pp">See also &quot;add_left_sisters(LIST)&quot; and
    &quot;add_right_sisters(LIST)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIright_sisters()_fP"><a class="permalink" href="#_fIright_sisters()_fP"><i>right_sisters()</i></a></h2>
Returns a list of nodes that're sisters to the right of
  <span class="Li">$node</span>. If <span class="Li">$node</span> is the
  rightmost (or only) daughter of its mother (or has no mother), then this
  returns an empty list.
<p class="Pp">See also &quot;add_left_sisters(LIST)&quot; and
    &quot;add_right_sisters(LIST)&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIroot()_fP"><a class="permalink" href="#_fIroot()_fP"><i>root()</i></a></h2>
Returns the root of whatever tree <span class="Li">$node</span> is a member of.
  If <span class="Li">$node</span> is the root, then the result is
  <span class="Li">$node</span> itself.
<p class="Pp">Not to be confused with &quot;<i>is_root()</i>&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIself_and_descendants()_fP"><a class="permalink" href="#_fIself_and_descendants()_fP"><i>self_and_descendants()</i></a></h2>
Returns a list consisting of itself (as element 0) and all the descendants of
  <span class="Li">$node</span>. Returns just itself if
  <span class="Li">$node</span> is a terminal_node.
<p class="Pp">(Note that it's spelled &quot;descendants&quot;, not
    &quot;descendents&quot;.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIself_and_sisters()_fP"><a class="permalink" href="#_fIself_and_sisters()_fP"><i>self_and_sisters()</i></a></h2>
Returns a list of all nodes (going left-to-right) that have the same mother as
  <span class="Li">$node</span> -- including <span class="Li">$node</span>
  itself. This is just like
  <span class="Li">$node</span>-&gt;mother-&gt;daughters, except that that fails
  where <span class="Li">$node</span> is root, whereas
  <span class="Li">$root</span>-&gt;self_and_siblings, as a special case,
  returns <span class="Li">$root</span>.
<p class="Pp">(Contrary to how you may interpret how this method is named,
    &quot;self&quot; is not (necessarily) the first element of what's
  returned.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="set_daughters(_s-1LIST_s0)"><a class="permalink" href="#set_daughters(_s-1LIST_s0)">set_daughters(LIST)</a></h2>
This unlinks all <span class="Li">$mother</span>'s daughters, and replaces them
  with the daughters in LIST.
<p class="Pp">Currently implemented as just
    <span class="Li">$mother</span>-&gt;clear_daughters followed by
    <span class="Li">$mother</span>-&gt;add_daughters(LIST).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="simple_lol_to_tree($simple_lol)"><a class="permalink" href="#simple_lol_to_tree($simple_lol)">simple_lol_to_tree($simple_lol)</a></h2>
This must be called as a class method.
<p class="Pp">This is like lol_to_tree, except that rule 1 doesn't apply --
    i.e., all scalars (or really, anything not a listref) in the LoL-structure
    end up as named terminal nodes, and only terminal nodes get names (and, of
    course, that name comes from that scalar value). This method is useful for
    making things like expression trees, or at least starting them off. Consider
    that this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $tree = Tree::DAG_Node-&gt;simple_lol_to_tree(
      [ 'foo', ['bar', ['baz'], 'quux'], 'zaz', 'pati' ]
    );
</pre>
<p class="Pp">converts from something like a Lispish or Iconish tree, if you
    pretend the brackets are parentheses.</p>
<p class="Pp">Note that there is a (possibly surprising) degenerate case of what
    I'm calling a &quot;simple-LoL&quot;, and it's like this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $tree = Tree::DAG_Node-&gt;simple_lol_to_tree('Lonely');
</pre>
<p class="Pp">This is the (only) way you can specify a tree consisting of only a
    single node, which here gets the name 'Lonely'.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIsisters()_fP"><a class="permalink" href="#_fIsisters()_fP"><i>sisters()</i></a></h2>
Returns a list of all nodes (going left-to-right) that have the same mother as
  <span class="Li">$node</span> -- <b>not including</b>
  <span class="Li">$node</span> itself. If <span class="Li">$node</span> is
  root, this returns empty-list.
</section>
<section class="Ss">
<h2 class="Ss" id="string2hashref($s)"><a class="permalink" href="#string2hashref($s)">string2hashref($s)</a></h2>
Returns a hashref built from the string.
<p class="Pp">The string is expected to be something like '{AutoCommit =&gt;
    '1', PrintError =&gt; &quot;0&quot;, ReportError =&gt; 1}'.</p>
<p class="Pp">The empty string is returned as {}.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fItree_to_lol()_fP"><a class="permalink" href="#_fItree_to_lol()_fP"><i>tree_to_lol()</i></a></h2>
Returns that tree (starting at <span class="Li">$node</span>) represented as a
  LoL, like what <span class="Li">$lol</span>, above, holds. (This is as opposed
  to &quot;tree_to_lol_notation($options)&quot;, which returns the viewable code
  like what gets evaluated and stored in <span class="Li">$lol</span>, above.)
<p class="Pp">Lord only knows what you use this for -- maybe for feeding to
    Data::Dumper, in case &quot;tree_to_lol_notation($options)&quot; doesn't do
    just what you want?</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tree_to_lol_notation($options)"><a class="permalink" href="#tree_to_lol_notation($options)">tree_to_lol_notation($options)</a></h2>
Dumps a tree (starting at <span class="Li">$node</span>) as the sort of LoL-like
  bracket notation you see in the above example code. Returns just one big block
  of text. The only option is &quot;multiline&quot; -- if true, it dumps the
  text as the sort of indented structure as seen above; if false (and it
  defaults to false), dumps it all on one line (with no indenting, of course).
<p class="Pp">For example, starting with the tree from the above example,
  this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  print $tree-&gt;tree_to_lol_notation, &quot;\n&quot;;
</pre>
<p class="Pp">prints the following (which I've broken over two lines for sake of
    printability of documentation):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  [[[['Det:The'], [['dog'], 'N'], 'NP'], [[&quot;/with rabies\x5c&quot;],
  'PP'], 'NP'], [['died'], 'VP'], 'S'],
</pre>
<p class="Pp">Doing this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  print $tree-&gt;tree_to_lol_notation({ multiline =&gt; 1 });
</pre>
<p class="Pp">prints the same content, just spread over many lines, and prettily
    indented.</p>
<p class="Pp">Note: Names are converted to a printable form using the
    undocumented function <i>_dump_quote()</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fItree_to_simple_lol()_fP"><a class="permalink" href="#_fItree_to_simple_lol()_fP"><i>tree_to_simple_lol()</i></a></h2>
Returns that tree (starting at <span class="Li">$node</span>) represented as a
  simple-LoL -- i.e., one where non-terminal nodes are represented as listrefs,
  and terminal nodes are gotten from the contents of those nodes' &quot;name'
  attributes.
<p class="Pp">Note that in the case of <span class="Li">$node</span> being
    terminal, what you get back is the same as
    <span class="Li">$node</span>-&gt;name.</p>
<p class="Pp">Compare to tree_to_simple_lol_notation.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tree_to_simple_lol_notation($options)"><a class="permalink" href="#tree_to_simple_lol_notation($options)">tree_to_simple_lol_notation($options)</a></h2>
A simple-LoL version of tree_to_lol_notation (which see); takes the same
  options.
<p class="Pp">Note: Names are converted to a printable form using the
    undocumented function <i>_dump_quote()</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tree2string(_$options_,__$some_tree_)"><a class="permalink" href="#tree2string(_$options_,__$some_tree_)">tree2string([$options],
  [$some_tree])</a></h2>
Here, the [] represent optional parameters.
<p class="Pp">Returns an arrayref of lines, suitable for printing.</p>
<p class="Pp">Draws a nice ASCII-art representation of the tree structure.</p>
<p class="Pp">The tree looks like:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        Root. Attributes: {# =&gt; &quot;0&quot;}
           |---I. Attributes: {# =&gt; &quot;1&quot;}
           |   |---J. Attributes: {# =&gt; &quot;3&quot;}
           |   |   |---K. Attributes: {# =&gt; &quot;3&quot;}
           |   |---J. Attributes: {# =&gt; &quot;4&quot;}
           |       |---L. Attributes: {# =&gt; &quot;5&quot;}
           |           |---M. Attributes: {# =&gt; &quot;5&quot;}
           |               |---N. Attributes: {# =&gt; &quot;5&quot;}
           |                   |---O. Attributes: {# =&gt; &quot;5&quot;}
           |---H. Attributes: {# =&gt; &quot;2&quot;}
           |   |---J. Attributes: {# =&gt; &quot;3&quot;}
           |   |   |---K. Attributes: {# =&gt; &quot;3&quot;}
           |   |---J. Attributes: {# =&gt; &quot;4&quot;}
           |       |---L. Attributes: {# =&gt; &quot;5&quot;}
           |           |---M. Attributes: {# =&gt; &quot;5&quot;}
           |               |---N. Attributes: {# =&gt; &quot;5&quot;}
           |                   |---O. Attributes: {# =&gt; &quot;5&quot;}
           |---D. Attributes: {# =&gt; &quot;6&quot;}
           |   |---F. Attributes: {# =&gt; &quot;8&quot;}
           |       |---G. Attributes: {# =&gt; &quot;8&quot;}
           |---E. Attributes: {# =&gt; &quot;7&quot;}
           |   |---F. Attributes: {# =&gt; &quot;8&quot;}
           |       |---G. Attributes: {# =&gt; &quot;8&quot;}
           |---B. Attributes: {# =&gt; &quot;9&quot;}
               |---C. Attributes: {# =&gt; &quot;9&quot;}
</pre>
<p class="Pp">Or, without attributes:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
        Root
           |---I
           |   |---J
           |   |   |---K
           |   |---J
           |       |---L
           |           |---M
           |               |---N
           |                   |---O
           |---H
           |   |---J
           |   |   |---K
           |   |---J
           |       |---L
           |           |---M
           |               |---N
           |                   |---O
           |---D
           |   |---F
           |       |---G
           |---E
           |   |---F
           |       |---G
           |---B
               |---C
</pre>
<p class="Pp">See scripts/cut.and.paste.subtrees.pl.</p>
<p class="Pp">Example usage:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  print map(&quot;$_\n&quot;, @{$tree-&gt;tree2string});
</pre>
<p class="Pp">Can be called with <span class="Li">$some_tree</span> set to any
    <span class="Li">$node</span>, and will print the tree assuming
    <span class="Li">$node</span> is the root.</p>
<p class="Pp">If you don't wish to supply options, use tree2string({},
    <span class="Li">$node</span>).</p>
<p class="Pp">Possible keys in the <span class="Li">$options</span> hashref
    (which defaults to {}):</p>
<dl class="Bl-tag">
  <dt>o no_attributes =&gt; $Boolean</dt>
  <dd>If 1, the node's attributes are not included in the string returned.
    <p class="Pp">Default: 0 (include attributes).</p>
  </dd>
</dl>
<p class="Pp">Calls &quot;node2string($options, <span class="Li">$t</span>,
    <span class="Li">$vert_dashes</span>)&quot;.</p>
<p class="Pp">See also &quot;draw_ascii_tree([$options])&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fIunlink_from_mother()_fP"><a class="permalink" href="#_fIunlink_from_mother()_fP"><i>unlink_from_mother()</i></a></h2>
This removes node from the daughter list of its mother. If it has no mother,
  this is a no-operation.
<p class="Pp">Returns the mother unlinked from (if any).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="walk_down($options)"><a class="permalink" href="#walk_down($options)">walk_down($options)</a></h2>
Performs a depth-first traversal of the structure at and under
  <span class="Li">$node</span>. What it does at each node depends on the value
  of the options hashref, which you must provide. There are three options,
  &quot;callback&quot; and &quot;callbackback&quot; (at least one of which must
  be defined, as a sub reference), and &quot;_depth&quot;.
<p class="Pp">This is what <i></i><i>walk_down()</i><i></i> does, in pseudocode
    form:</p>
<dl class="Bl-tag">
  <dt>o Starting point</dt>
  <dd>Start at the <span class="Li">$node</span> given.</dd>
  <dt>o Callback</dt>
  <dd>If there's a <i>callback</i>, call it with <span class="Li">$node</span>
      as the first argument, and the options hashref as the second argument
      (which contains the potentially useful <i>_depth</i>, remember). This
      function must return true or false -- if false, it will block the next
      step:</dd>
  <dt>o Daughters</dt>
  <dd>If <span class="Li">$node</span> has any daughter nodes, increment
      <i>_depth</i>, and call
      <span class="Li">$daughter</span>-&gt;walk_down($options) for each
      daughter (in order, of course), where options_hashref is the same hashref
      it was called with. When this returns, decrements <i>_depth</i>.</dd>
  <dt>Callbackback</dt>
  <dd>If there's a <i>callbackback</i>, call just it as with <i>callback</i>
      (but tossing out the return value). Note that <i>callback</i> returning
      false blocks traversal below <span class="Li">$node</span>, but doesn't
      block calling callbackback for <span class="Li">$node</span>.
      (Incidentally, in the unlikely case that <span class="Li">$node</span> has
      stopped being a node object, <i>callbackback</i> won't get called.)</dd>
  <dt>o Return</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li">$node</span>-&gt;walk_down($options) is the way
    to recursively do things to a tree (if you start at the root) or part of a
    tree; if what you're doing is best done via pre-pre order traversal, use
    <i>callback</i>; if what you're doing is best done with post-order
    traversal, use <i>callbackback</i>. <i></i><i>walk_down()</i><i></i> is even
    the basis for plenty of the methods in this class. See the source code for
    examples both simple and horrific.</p>
<p class="Pp">Note that if you don't specify <i>_depth</i>, it effectively
    defaults to 0. You should set it to scalar($node-&gt;ancestors) if you want
    <i>_depth</i> to reflect the true depth-in-the-tree for the nodes called,
    instead of just the depth below <span class="Li">$node</span>. (If
    <span class="Li">$node</span> is the root, there's difference, of
  course.)</p>
<p class="Pp">And <b>by the way</b>, it's a bad idea to modify the tree from the
    callback. Unpredictable things may happen. I instead suggest having your
    callback add to a stack of things that need changing, and then, once
    <i></i><i>walk_down()</i><i></i> is all finished, changing those nodes from
    that stack.</p>
<p class="Pp">Note that the existence of <i></i><i>walk_down()</i><i></i>
    doesn't mean you can't write you own special-use traversers.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WHEN_AND_HOW_TO_DESTROY_THE_TREE"><a class="permalink" href="#WHEN_AND_HOW_TO_DESTROY_THE_TREE">WHEN
  AND HOW TO DESTROY THE TREE</a></h1>
It should be clear to you that if you've built a big parse tree or something,
  and then you're finished with it, you should call
  <span class="Li">$some_node</span>-&gt;delete_tree on it if you want the
  memory back.
<p class="Pp">But consider this case: you've got this tree:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
      A
    / | \
   B  C  D
   |     | \
   E     X  Y
</pre>
<p class="Pp">Let's say you decide you don't want D or any of its descendants in
    the tree, so you call D-&gt;unlink_from_mother. This does NOT automagically
    destroy the tree D-X-Y. Instead it merely splits the tree into two:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
     A                        D
    / \                      / \
   B   C                    X   Y
   |
   E
</pre>
<p class="Pp">To destroy D and its little tree, you have to explicitly call
    delete_tree on it.</p>
<p class="Pp">Note, however, that if you call C-&gt;unlink_from_mother, and if
    you don't have a link to C anywhere, then it <b>does</b> magically go away.
    This is because nothing links to C -- whereas with the D-X-Y tree, D links
    to X and Y, and X and Y each link back to D. Note that calling
    C-&gt;delete_tree is harmless -- after all, a tree of only one node is still
    a tree.</p>
<p class="Pp">So, this is a surefire way of getting rid of all
    <span class="Li">$node</span>'s children and freeing up the memory
    associated with them and their descendants:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  foreach my $it ($node-&gt;clear_daughters) { $it-&gt;delete_tree }
</pre>
<p class="Pp">Just be sure not to do this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  foreach my $it ($node-&gt;daughters) { $it-&gt;delete_tree }
  $node-&gt;clear_daughters;
</pre>
<p class="Pp">That's bad; the first call to
    <span class="Li">$_</span>-&gt;delete_tree will climb to the root of
    <span class="Li">$node</span>'s tree, and nuke the whole tree, not just the
    bits under <span class="Li">$node</span>. You might as well have just called
    <span class="Li">$node</span>-&gt;delete_tree. (Moreavor, once
    <span class="Li">$node</span> is dead, you can't call clear_daughters on it,
    so you'll get an error there.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUG_REPORTS"><a class="permalink" href="#BUG_REPORTS">BUG
  REPORTS</a></h1>
If you find a bug in this library, report it to me as soon as possible, at the
  address listed in the MAINTAINER section, below. Please try to be as specific
  as possible about how you got the bug to occur.
</section>
<section class="Sh">
<h1 class="Sh" id="HELP!"><a class="permalink" href="#HELP!">HELP!</a></h1>
If you develop a given routine for dealing with trees in some way, and use it a
  lot, then if you think it'd be of use to anyone else, do email me about it; it
  might be helpful to others to include that routine, or something based on it,
  in a later version of this module.
<p class="Pp">It's occurred to me that you might like to (and might yourself
    develop routines to) draw trees in something other than ASCII art. If you do
    so -- say, for PostScript output, or for output interpretable by some
    external plotting program -- I'd be most interested in the results.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="RAMBLINGS"><a class="permalink" href="#RAMBLINGS">RAMBLINGS</a></h1>
This module uses &quot;strict&quot;, but I never wrote it with -w warnings in
  mind -- so if you use -w, do not be surprised if you see complaints from the
  guts of DAG_Node. As long as there is no way to turn off -w for a given module
  (instead of having to do it in every single subroutine with a &quot;local
  $^W&quot;), I'm not going to change this. However, I do, at points, get bursts
  of ambition, and I try to fix code in DAG_Node that generates warnings, <i>as
  I come across them</i> -- which is only occasionally. Feel free to email me
  any patches for any such fixes you come up with, tho.
<p class="Pp">Currently I don't assume (or enforce) anything about the class
    membership of nodes being manipulated, other than by testing whether each
    one provides a method &quot;<i>is_node()</i>&quot;, a la:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  die &quot;Not a node!!!&quot; unless UNIVERSAL::can($node, &quot;is_node&quot;);
</pre>
<p class="Pp">So, as far as I'm concerned, a given tree's nodes are free to
    belong to different classes, just so long as they provide/inherit
    &quot;<i>is_node()</i>&quot;, the few methods that this class relies on to
    navigate the tree, and have the same internal object structure, or a
    superset of it. Presumably this would be the case for any object belonging
    to a class derived from <span class="Li">&quot;Tree::DAG_Node&quot;</span>,
    or belonging to <span class="Li">&quot;Tree::DAG_Node&quot;</span>
  itself.</p>
<p class="Pp">When routines in this class access a node's &quot;mother&quot;
    attribute, or its &quot;daughters&quot; attribute, they (generally) do so
    directly (via <span class="Li">$node</span>-&gt;{'mother'}, etc.), for sake
    of efficiency. But classes derived from this class should probably do this
    instead thru a method (via <span class="Li">$node</span>-&gt;mother, etc.),
    for sake of portability, abstraction, and general goodness.</p>
<p class="Pp">However, no routines in this class (aside from, necessarily,
    <i></i> <i>_init()</i><i></i>, <i></i><i>_init_name()</i><i></i>, and
    &quot;<i>name()</i>&quot;) access the &quot;name&quot; attribute directly;
    routines (like the various tree draw/dump methods) get the &quot;name&quot;
    value thru a call to <span class="Li">$obj</span>-&gt;<i>name()</i>. So if
    you want the object's name to not be a real attribute, but instead have it
    derived dynamically from some feature of the object (say, based on some of
    its other attributes, or based on its address), you can to override the
    &quot;<i>name()</i>&quot; method, without causing problems. (Be sure to
    consider the case of <span class="Li">$obj</span>-&gt;name as a write
    method, as it's used in <i>/lol_to_tree($lol)</i> and
    &quot;random_network($options)&quot;.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FAQ"><a class="permalink" href="#FAQ">FAQ</a></h1>
<section class="Ss">
<h2 class="Ss" id="Which_is_the_best_tree_processing_module?"><a class="permalink" href="#Which_is_the_best_tree_processing_module?">Which
  is the best tree processing module?</a></h2>
<span class="Li">&quot;Tree::DAG_Node&quot;</span>, as it happens. More details:
  &quot;SEE ALSO&quot;.
</section>
<section class="Ss">
<h2 class="Ss" id="How_to_process_every_node_in_tree?"><a class="permalink" href="#How_to_process_every_node_in_tree?">How
  to process every node in tree?</a></h2>
See &quot;walk_down($options)&quot;. <span class="Li">$options</span> normally
  looks like this, assuming we wish to pass in an arrayref as a stack:
<p class="Pp"><span class="Li"></span></p>
<pre>
        my(@stack);

        $tree -&gt; walk_down
        ({
                callback =&gt;
                sub
                {
                        my(@node, $options) = @_;

                        # Process $node, using $options...

                        push @{$$options{stack} }, $node -&gt; name;

                        return 1; # Keep walking.
                },
                _depth =&gt; 0,
                stack  =&gt; \@stack,
        });

        # Process @stack...
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="How_do_I_switch_from_Tree_to_Tree::DAG_Node?"><a class="permalink" href="#How_do_I_switch_from_Tree_to_Tree::DAG_Node?">How
  do I switch from Tree to Tree::DAG_Node?</a></h2>
<dl class="Bl-tag">
  <dt>o The node's name</dt>
  <dd>In <span class="Li">&quot;Tree&quot;</span> you use
      <span class="Li">$node</span> -&gt; value and in
      <span class="Li">&quot;Tree::DAG_Node&quot;</span> it's
      <span class="Li">$node</span> -&gt; name.</dd>
  <dt>o The node's attributes</dt>
  <dd>In <span class="Li">&quot;Tree&quot;</span> you use
      <span class="Li">$node</span> -&gt; meta and in
      <span class="Li">&quot;Tree::DAG_Node&quot;</span> it's
      <span class="Li">$node</span> -&gt; attributes.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Are_there_techniques_for_processing_lists_of_nodes?"><a class="permalink" href="#Are_there_techniques_for_processing_lists_of_nodes?">Are
  there techniques for processing lists of nodes?</a></h2>
<dl class="Bl-tag">
  <dt>o Copy the daughter list, and change it</dt>
  <dd><span class="Li"></span>
    <pre>
        @them    = $mother-&gt;daughters;
        @removed = splice(@them, 0, 2, @new_nodes);

        $mother-&gt;set_daughters(@them);
    </pre>
  </dd>
  <dt>o Select a sub-set of nodes</dt>
  <dd><span class="Li"></span>
    <pre>
        $mother-&gt;set_daughters
        (
                grep($_-&gt;name =~ /wanted/, $mother-&gt;daughters)
        );
    </pre>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Why_did_you_break_up_the_sections_of_methods_in_the__s-1POD_s0?"><a class="permalink" href="#Why_did_you_break_up_the_sections_of_methods_in_the__s-1POD_s0?">Why
  did you break up the sections of methods in the POD?</a></h2>
Because I want to list the methods in alphabetical order.
</section>
<section class="Ss">
<h2 class="Ss" id="Why_did_you_move_the__s-1POD_s0_to_the_end?"><a class="permalink" href="#Why_did_you_move_the__s-1POD_s0_to_the_end?">Why
  did you move the POD to the end?</a></h2>
Because the apostrophes in the text confused the syntax hightlighter in my
  editor UltraEdit.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<dl class="Bl-tag">
  <dt>o HTML::Element, HTML::Tree and HTML::TreeBuilder</dt>
  <dd>Sean is also the author of these modules.</dd>
  <dt>o Tree</dt>
  <dd>Lightweight.</dd>
  <dt>o Tree::Binary</dt>
  <dd>Lightweight.</dd>
  <dt>o Tree::DAG_Node::Persist</dt>
  <dd>Lightweight.</dd>
  <dt>o Tree::Persist</dt>
  <dd>Lightweight.</dd>
  <dt>o Forest</dt>
  <dd>Uses Moose.</dd>
</dl>
<p class="Pp"><span class="Li">&quot;Tree::DAG_Node&quot;</span> itself is also
    lightweight.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="REFERENCES"><a class="permalink" href="#REFERENCES">REFERENCES</a></h1>
Wirth, Niklaus. 1976. <i>Algorithms + Data Structures = Programs</i>
  Prentice-Hall, Englewood Cliffs, NJ.
<p class="Pp">Knuth, Donald Ervin. 1997. <i>Art of Computer Programming, Volume
    1,</i> <i>Third Edition: Fundamental Algorithms</i>. Addison-Wesley,
    Reading, MA.</p>
<p class="Pp">Wirth's classic, currently and lamentably out of print, has a good
    section on trees. I find it clearer than Knuth's (if not quite as
    encyclopedic), probably because Wirth's example code is in a
    block-structured high-level language (basically Pascal), instead of in
    assembler (MIX).</p>
<p class="Pp">Until some kind publisher brings out a new printing of Wirth's
    book, try poking around used bookstores (or
    <span class="Li">&quot;www.abebooks.com&quot;</span>) for a copy. I think it
    was also republished in the 1980s under the title <i>Algorithms and Data
    Structures</i>, and in a German edition called <i>Algorithmen und
    Datenstrukturen</i>. (That is, I'm sure books by Knuth were published under
    those titles, but I'm <i>assuming</i> that they're just later
    printings/editions of <i>Algorithms + Data Structures =</i>
    <i>Programs</i>.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="MACHINE-READABLE_CHANGE_LOG"><a class="permalink" href="#MACHINE-READABLE_CHANGE_LOG">MACHINE-READABLE
  CHANGE LOG</a></h1>
The file Changes was converted into Changelog.ini by Module::Metadata::Changes.
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
Email the author, or log a bug on RT:
<p class="Pp">&lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Tree::DAG_Node&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ACKNOWLEDGEMENTS"><a class="permalink" href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></h1>
The code to print the tree, in <i>tree2string()</i>, was adapted from
  Forest::Tree::Writer::ASCIIWithBranches by the dread Stevan Little.
</section>
<section class="Sh">
<h1 class="Sh" id="MAINTAINER"><a class="permalink" href="#MAINTAINER">MAINTAINER</a></h1>
David Hand, <span class="Li">&quot;&lt;cogent@cpan.org&gt;&quot;</span> up to V
  1.06.
<p class="Pp">Ron Savage
    <span class="Li">&quot;&lt;rsavage@cpan.org&gt;&quot;</span> from V
  1.07.</p>
<p class="Pp">In this POD, usage of 'I' refers to Sean, up until V 1.07.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Sean M. Burke, <span class="Li">&quot;&lt;sburke@cpan.org&gt;&quot;</span>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT,_LICENSE,_AND_DISCLAIMER"><a class="permalink" href="#COPYRIGHT,_LICENSE,_AND_DISCLAIMER">COPYRIGHT,
  LICENSE, AND DISCLAIMER</a></h1>
Copyright 1998-2001, 2004, 2007 by Sean M. Burke and David Hand.
<p class="Pp">This program is free software. It is released under the Artistic
    License 2.0. See &lt;http://opensource.org/licenses/Artistic-2.0&gt;.</p>
<p class="Pp">This program is distributed in the hope that it will be useful,
    but without any warranty; without even the implied warranty of
    merchantability or fitness for a particular purpose.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-02-09</td>
    <td class="foot-os">perl v5.18.2</td>
  </tr>
</table>
</body>
</html>
