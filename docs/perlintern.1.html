<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PERLINTERN(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PERLINTERN(1)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">PERLINTERN(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
perlintern - autogenerated documentation of purely internal 		 Perl functions
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This file is the autogenerated documentation of functions in the Perl
  interpreter that are documented using Perl's internal documentation format but
  are not marked as part of the Perl API. In other words, <b>they are not for
  use in extensions</b>!
</section>
<section class="Sh">
<h1 class="Sh" id="Compile-time_scope_hooks"><a class="permalink" href="#Compile-time_scope_hooks">Compile-time
  scope hooks</a></h1>
<dl class="Bl-tag">
  <dt>BhkENTRY</dt>
  <dd>Return an entry from the BHK structure. <i>which</i> is a preprocessor
      token indicating which entry to return. If the appropriate flag is not set
      this will return NULL. The type of the return value depends on which entry
      you ask for.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void *  BhkENTRY(BHK *hk, which)
    </pre>
  </dd>
  <dt>BhkFLAGS</dt>
  <dd>Return the BHK's flags.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     BhkFLAGS(BHK *hk)
    </pre>
  </dd>
  <dt>CALL_BLOCK_HOOKS </dt>
  <dd>Call all the registered block hooks for type <i>which</i>. <i>which</i> is
      a preprocessing token; the type of <i>arg</i> depends on <i>which</i>.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    CALL_BLOCK_HOOKS(which, arg)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="CV_reference_counts_and_CvOUTSIDE"><a class="permalink" href="#CV_reference_counts_and_CvOUTSIDE">CV
  reference counts and CvOUTSIDE</a></h1>
<dl class="Bl-tag">
  <dt>CvWEAKOUTSIDE</dt>
  <dd>Each CV has a pointer, <span class="Li">&quot;CvOUTSIDE()&quot;</span>, to
      its lexically enclosing CV (if any). Because pointers to anonymous sub
      prototypes are stored in <span class="Li">&quot;&amp;&quot;</span> pad
      slots, it is a possible to get a circular reference, with the parent
      pointing to the child and vice-versa. To avoid the ensuing memory leak, we
      do not increment the reference count of the CV pointed to by
      <span class="Li">&quot;CvOUTSIDE&quot;</span> in the <i>one specific
      instance</i> that the parent has a
      <span class="Li">&quot;&amp;&quot;</span> pad slot pointing back to us. In
      this case, we set the <span class="Li">&quot;CvWEAKOUTSIDE&quot;</span>
      flag in the child. This allows us to determine under what circumstances we
      should decrement the refcount of the parent when freeing the child.
    <p class="Pp">There is a further complication with non-closure anonymous
        subs (i.e. those that do not refer to any lexicals outside that sub). In
        this case, the anonymous prototype is shared rather than being cloned.
        This has the consequence that the parent may be freed while there are
        still active children, eg</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    BEGIN { $a = sub { eval '$x' } }
    </pre>
    <p class="Pp">In this case, the BEGIN is freed immediately after execution
        since there are no active references to it: the anon sub prototype has
        <span class="Li">&quot;CvWEAKOUTSIDE&quot;</span> set since it's not a
        closure, and <span class="Li">$a</span> points to the same CV, so it
        doesn't contribute to BEGIN's refcount either. When
        <span class="Li">$a</span> is executed, the <span class="Li">&quot;eval
        '$x'&quot;</span> causes the chain of
        <span class="Li">&quot;CvOUTSIDE&quot;</span>s to be followed, and the
        freed BEGIN is accessed.</p>
    <p class="Pp">To avoid this, whenever a CV and its associated pad is freed,
        any <span class="Li">&quot;&amp;&quot;</span> entries in the pad are
        explicitly removed from the pad, and if the refcount of the pointed-to
        anon sub is still positive, then that child's
        <span class="Li">&quot;CvOUTSIDE&quot;</span> is set to point to its
        grandparent. This will only occur in the single specific case of a
        non-closure anon prototype having one or more active references (such as
        <span class="Li">$a</span> above).</p>
    <p class="Pp">One other thing to consider is that a CV may be merely
        undefined rather than freed, eg <span class="Li">&quot;undef
        &amp;foo&quot;</span>. In this case, its refcount may not have reached
        zero, but we still delete its pad and its
        <span class="Li">&quot;CvROOT&quot;</span> etc. Since various children
        may still have their <span class="Li">&quot;CvOUTSIDE&quot;</span>
        pointing at this undefined CV, we keep its own
        <span class="Li">&quot;CvOUTSIDE&quot;</span> for the time being, so
        that the chain of lexical scopes is unbroken. For example, the following
        should print 123:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my $x = 123;
    sub tmp { sub { eval '$x' } }
    my $a = tmp();
    undef &amp;tmp;
    print  $a-&gt;();

        bool    CvWEAKOUTSIDE(CV *cv)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Embedding_Functions"><a class="permalink" href="#Embedding_Functions">Embedding
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>cv_dump</dt>
  <dd>dump the contents of a CV
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    cv_dump(CV *cv, const char *title)
    </pre>
  </dd>
  <dt>cv_forget_slab</dt>
  <dd>When a CV has a reference count on its slab (CvSLABBED), it is responsible
      for making sure it is freed. (Hence, no two CVs should ever have a
      reference count on the same slab.) The CV only needs to reference the slab
      during compilation. Once it is compiled and CvROOT attached, it has
      finished its job, so it can forget the slab.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    cv_forget_slab(CV *cv)
    </pre>
  </dd>
  <dt>do_dump_pad</dt>
  <dd>Dump the contents of a padlist
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    do_dump_pad(I32 level, PerlIO *file,
                            PADLIST *padlist, int full)
    </pre>
  </dd>
  <dt>intro_my</dt>
  <dd>&quot;Introduce&quot; my variables to visible status. This is called
      during parsing at the end of each statement to make lexical variables
      visible to subsequent statements.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     intro_my()
    </pre>
  </dd>
  <dt>padlist_dup</dt>
  <dd>Duplicates a pad.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADLIST * padlist_dup(PADLIST *srcpad,
                              CLONE_PARAMS *param)
    </pre>
  </dd>
  <dt>pad_alloc_name</dt>
  <dd>Allocates a place in the currently-compiling pad (via
      &quot;pad_alloc&quot; in perlapi) and then stores a name for that entry.
      <i>namesv</i> is adopted and becomes the name entry; it must already
      contain the name string and be sufficiently upgraded. <i>typestash</i> and
      <i>ourstash</i> and the <span class="Li">&quot;padadd_STATE&quot;</span>
      flag get added to <i>namesv</i>. None of the other processing of
      &quot;pad_add_name_pvn&quot; in perlapi is done. Returns the offset of the
      allocated pad slot.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_alloc_name(SV *namesv, U32 flags,
                                 HV *typestash, HV *ourstash)
    </pre>
  </dd>
  <dt>pad_block_start</dt>
  <dd>Update the pad compilation state variables on entry to a new block.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    pad_block_start(int full)
    </pre>
  </dd>
  <dt>pad_check_dup</dt>
  <dd>Check for duplicate declarations: report any of:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
     * a my in the current scope with the same name;
     * an our (anywhere in the pad) with the same name and the
       same stash as C&lt;ourstash&gt;
    </pre>
    <p class="Pp"><span class="Li">&quot;is_our&quot;</span> indicates that the
        name to check is an 'our' declaration.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    pad_check_dup(SV *name, U32 flags,
                              const HV *ourstash)
    </pre>
  </dd>
  <dt>pad_findlex</dt>
  <dd>Find a named lexical anywhere in a chain of nested pads. Add fake entries
      in the inner pads if it's found in an outer one.
    <p class="Pp">Returns the offset in the bottom pad of the lex or the fake
        lex. cv is the CV in which to start the search, and seq is the current
        cop_seq to match against. If warn is true, print appropriate warnings.
        The out_* vars return values, and so are pointers to where the returned
        values should be stored. out_capture, if non-null, requests that the
        innermost instance of the lexical is captured; out_name_sv is set to the
        innermost matched namesv or fake namesv; out_flags returns the flags
        normally associated with the IVX field of a fake namesv.</p>
    <p class="Pp">Note that <i>pad_findlex()</i> is recursive; it recurses up
        the chain of CVs, then comes back down, adding fake entries as it goes.
        It has to be this way because fake namesvs in anon protoypes have to
        store in xlow the index into the parent pad.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PADOFFSET pad_findlex(const char *namepv,
                              STRLEN namelen, U32 flags,
                              const CV* cv, U32 seq, int warn,
                              SV** out_capture,
                              SV** out_name_sv, int *out_flags)
    </pre>
  </dd>
  <dt>pad_fixup_inner_anons</dt>
  <dd>For any anon CVs in the pad, change CvOUTSIDE of that CV from old_cv to
      new_cv if necessary. Needed when a newly-compiled CV has to be moved to a
      pre-existing CV struct.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    pad_fixup_inner_anons(PADLIST *padlist,
                                      CV *old_cv, CV *new_cv)
    </pre>
  </dd>
  <dt>pad_free</dt>
  <dd>Free the SV at offset po in the current pad.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    pad_free(PADOFFSET po)
    </pre>
  </dd>
  <dt>pad_leavemy</dt>
  <dd>Cleanup at end of scope during compilation: set the max seq number for
      lexicals in this scope and warn of any lexicals that never got introduced.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    pad_leavemy()
    </pre>
  </dd>
  <dt>pad_push</dt>
  <dd>Push a new pad frame onto the padlist, unless there's already a pad at
      this depth, in which case don't bother creating a new one. Then give the
      new pad an <span class="Li">@_</span> in slot zero.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    pad_push(PADLIST *padlist, int depth)
    </pre>
  </dd>
  <dt>pad_reset</dt>
  <dd>Mark all the current temporaries for reuse
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    pad_reset()
    </pre>
  </dd>
  <dt>pad_swipe</dt>
  <dd>Abandon the tmp in the current pad at offset po and replace with a new
      one.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    pad_swipe(PADOFFSET po, bool refadjust)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Functions_in_file_op.c"><a class="permalink" href="#Functions_in_file_op.c">Functions
  in file op.c</a></h1>
<dl class="Bl-tag">
  <dt>core_prototype</dt>
  <dd>This function assigns the prototype of the named core function to
      <span class="Li">&quot;sv&quot;</span>, or to a new mortal SV if
      <span class="Li">&quot;sv&quot;</span> is NULL. It returns the modified
      <span class="Li">&quot;sv&quot;</span>, or NULL if the core function has
      no prototype. <span class="Li">&quot;code&quot;</span> is a code as
      returned by <span class="Li">&quot;keyword()&quot;</span>. It must not be
      equal to 0 or -KEY_CORE.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    core_prototype(SV *sv, const char *name,
                               const int code,
                               int * const opnum)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Functions_in_file_pp_ctl.c"><a class="permalink" href="#Functions_in_file_pp_ctl.c">Functions
  in file pp_ctl.c</a></h1>
<dl class="Bl-tag">
  <dt>docatch</dt>
  <dd>Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval
      context.
    <p class="Pp">0 is used as continue inside eval,</p>
    <p class="Pp">3 is used for a die caught by an inner eval - continue inner
        loop</p>
    <p class="Pp">See cop.h: je_mustcatch, when set at any runlevel to TRUE,
        means eval ops must establish a local jmpenv to handle exception
      traps.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        OP*     docatch(OP *o)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="GV_Functions"><a class="permalink" href="#GV_Functions">GV
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>gv_try_downgrade</dt>
  <dd>If the typeglob <span class="Li">&quot;gv&quot;</span> can be expressed
      more succinctly, by having something other than a real GV in its place in
      the stash, replace it with the optimised form. Basic requirements for this
      are that <span class="Li">&quot;gv&quot;</span> is a real typeglob, is
      sufficiently ordinary, and is only referenced from its package. This
      function is meant to be used when a GV has been looked up in part to see
      what was there, causing upgrading, but based on what was found it turns
      out that the real GV isn't required after all.
    <p class="Pp">If <span class="Li">&quot;gv&quot;</span> is a completely
        empty typeglob, it is deleted from the stash.</p>
    <p class="Pp">If <span class="Li">&quot;gv&quot;</span> is a typeglob
        containing only a sufficiently-ordinary constant sub, the typeglob is
        replaced with a scalar-reference placeholder that more compactly
        represents the same thing.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    gv_try_downgrade(GV* gv)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Hash_Manipulation_Functions"><a class="permalink" href="#Hash_Manipulation_Functions">Hash
  Manipulation Functions</a></h1>
<dl class="Bl-tag">
  <dt>hv_ename_add</dt>
  <dd>Adds a name to a stash's internal list of effective names. See
      <span class="Li">&quot;hv_ename_delete&quot;</span>.
    <p class="Pp">This is called when a stash is assigned to a new location in
        the symbol table.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    hv_ename_add(HV *hv, const char *name, U32 len,
                             U32 flags)
    </pre>
  </dd>
  <dt>hv_ename_delete</dt>
  <dd>Removes a name from a stash's internal list of effective names. If this is
      the name returned by <span class="Li">&quot;HvENAME&quot;</span>, then
      another name in the list will take its place
      (<span class="Li">&quot;HvENAME&quot;</span> will use it).
    <p class="Pp">This is called when a stash is deleted from the symbol
      table.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    hv_ename_delete(HV *hv, const char *name,
                                U32 len, U32 flags)
    </pre>
  </dd>
  <dt>refcounted_he_chain_2hv</dt>
  <dd>Generates and returns a <span class="Li">&quot;HV *&quot;</span>
      representing the content of a
      <span class="Li">&quot;refcounted_he&quot;</span> chain. <i>flags</i> is
      currently unused and must be zero.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV *    refcounted_he_chain_2hv(
                    const struct refcounted_he *c, U32 flags
                )
    </pre>
  </dd>
  <dt>refcounted_he_fetch_pv</dt>
  <dd>Like &quot;refcounted_he_fetch_pvn&quot;, but takes a nul-terminated
      string instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    refcounted_he_fetch_pv(
                    const struct refcounted_he *chain,
                    const char *key, U32 hash, U32 flags
                )
    </pre>
  </dd>
  <dt>refcounted_he_fetch_pvn</dt>
  <dd>Search along a <span class="Li">&quot;refcounted_he&quot;</span> chain for
      an entry with the key specified by <i>keypv</i> and <i>keylen</i>. If
      <i>flags</i> has the
      <span class="Li">&quot;REFCOUNTED_HE_KEY_UTF8&quot;</span> bit set, the
      key octets are interpreted as UTF-8, otherwise they are interpreted as
      Latin-1. <i>hash</i> is a precomputed hash of the key string, or zero if
      it has not been precomputed. Returns a mortal scalar representing the
      value associated with the key, or
      <span class="Li">&amp;PL_sv_placeholder</span> if there is no value
      associated with the key.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    refcounted_he_fetch_pvn(
                    const struct refcounted_he *chain,
                    const char *keypv, STRLEN keylen, U32 hash,
                    U32 flags
                )
    </pre>
  </dd>
  <dt>refcounted_he_fetch_pvs</dt>
  <dd>Like &quot;refcounted_he_fetch_pvn&quot;, but takes a literal string
      instead of a string/length pair, and no precomputed hash.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    refcounted_he_fetch_pvs(
                    const struct refcounted_he *chain,
                    const char *key, U32 flags
                )
    </pre>
  </dd>
  <dt>refcounted_he_fetch_sv</dt>
  <dd>Like &quot;refcounted_he_fetch_pvn&quot;, but takes a Perl scalar instead
      of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    refcounted_he_fetch_sv(
                    const struct refcounted_he *chain, SV *key,
                    U32 hash, U32 flags
                )
    </pre>
  </dd>
  <dt>refcounted_he_free</dt>
  <dd>Decrements the reference count of a
      <span class="Li">&quot;refcounted_he&quot;</span> by one. If the reference
      count reaches zero the structure's memory is freed, which (recursively)
      causes a reduction of its parent
      <span class="Li">&quot;refcounted_he&quot;</span>'s reference count. It is
      safe to pass a null pointer to this function: no action occurs in this
      case.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    refcounted_he_free(struct refcounted_he *he)
    </pre>
  </dd>
  <dt>refcounted_he_inc</dt>
  <dd>Increment the reference count of a
      <span class="Li">&quot;refcounted_he&quot;</span>. The pointer to the
      <span class="Li">&quot;refcounted_he&quot;</span> is also returned. It is
      safe to pass a null pointer to this function: no action occurs and a null
      pointer is returned.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        struct refcounted_he * refcounted_he_inc(
                                   struct refcounted_he *he
                               )
    </pre>
  </dd>
  <dt>refcounted_he_new_pv</dt>
  <dd>Like &quot;refcounted_he_new_pvn&quot;, but takes a nul-terminated string
      instead of a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        struct refcounted_he * refcounted_he_new_pv(
                                   struct refcounted_he *parent,
                                   const char *key, U32 hash,
                                   SV *value, U32 flags
                               )
    </pre>
  </dd>
  <dt>refcounted_he_new_pvn</dt>
  <dd>Creates a new <span class="Li">&quot;refcounted_he&quot;</span>. This
      consists of a single key/value pair and a reference to an existing
      <span class="Li">&quot;refcounted_he&quot;</span> chain (which may be
      empty), and thus forms a longer chain. When using the longer chain, the
      new key/value pair takes precedence over any entry for the same key
      further along the chain.
    <p class="Pp">The new key is specified by <i>keypv</i> and <i>keylen</i>. If
        <i>flags</i> has the
        <span class="Li">&quot;REFCOUNTED_HE_KEY_UTF8&quot;</span> bit set, the
        key octets are interpreted as UTF-8, otherwise they are interpreted as
        Latin-1. <i>hash</i> is a precomputed hash of the key string, or zero if
        it has not been precomputed.</p>
    <p class="Pp"><i>value</i> is the scalar value to store for this key.
        <i>value</i> is copied by this function, which thus does not take
        ownership of any reference to it, and later changes to the scalar will
        not be reflected in the value visible in the
        <span class="Li">&quot;refcounted_he&quot;</span>. Complex types of
        scalar will not be stored with referential integrity, but will be
        coerced to strings. <i>value</i> may be either null or
        <span class="Li">&amp;PL_sv_placeholder</span> to indicate that no value
        is to be associated with the key; this, as with any non-null value,
        takes precedence over the existence of a value for the key further along
        the chain.</p>
    <p class="Pp"><i>parent</i> points to the rest of the
        <span class="Li">&quot;refcounted_he&quot;</span> chain to be attached
        to the new <span class="Li">&quot;refcounted_he&quot;</span>. This
        function takes ownership of one reference to <i>parent</i>, and returns
        one reference to the new
        <span class="Li">&quot;refcounted_he&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        struct refcounted_he * refcounted_he_new_pvn(
                                   struct refcounted_he *parent,
                                   const char *keypv,
                                   STRLEN keylen, U32 hash,
                                   SV *value, U32 flags
                               )
    </pre>
  </dd>
  <dt>refcounted_he_new_pvs</dt>
  <dd>Like &quot;refcounted_he_new_pvn&quot;, but takes a literal string instead
      of a string/length pair, and no precomputed hash.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        struct refcounted_he * refcounted_he_new_pvs(
                                   struct refcounted_he *parent,
                                   const char *key, SV *value,
                                   U32 flags
                               )
    </pre>
  </dd>
  <dt>refcounted_he_new_sv</dt>
  <dd>Like &quot;refcounted_he_new_pvn&quot;, but takes a Perl scalar instead of
      a string/length pair.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        struct refcounted_he * refcounted_he_new_sv(
                                   struct refcounted_he *parent,
                                   SV *key, U32 hash, SV *value,
                                   U32 flags
                               )
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="IO_Functions"><a class="permalink" href="#IO_Functions">IO
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>start_glob</dt>
  <dd>Function called by <span class="Li">&quot;do_readline&quot;</span> to
      spawn a glob (or do the glob inside perl on VMS). This code used to be
      inline, but now perl uses <span class="Li">&quot;File::Glob&quot;</span>
      this glob starter is only used by miniperl during the build process.
      Moving it away shrinks pp_hot.c; shrinking pp_hot.c helps speed perl up.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        PerlIO* start_glob(SV *tmpglob, IO *io)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Magical_Functions"><a class="permalink" href="#Magical_Functions">Magical
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>magic_clearhint</dt>
  <dd>Triggered by a delete from %^H, records the key to
      <span class="Li">&quot;PL_compiling.cop_hints_hash&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     magic_clearhint(SV* sv, MAGIC* mg)
    </pre>
  </dd>
  <dt>magic_clearhints</dt>
  <dd>Triggered by clearing %^H, resets
      <span class="Li">&quot;PL_compiling.cop_hints_hash&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     magic_clearhints(SV* sv, MAGIC* mg)
    </pre>
  </dd>
  <dt>magic_methcall</dt>
  <dd>Invoke a magic method (like FETCH).
    <p class="Pp"><span class="Li">&quot;sv&quot;</span> and
        <span class="Li">&quot;mg&quot;</span> are the tied thingy and the tie
        magic.</p>
    <p class="Pp"><span class="Li">&quot;meth&quot;</span> is the name of the
        method to call.</p>
    <p class="Pp"><span class="Li">&quot;argc&quot;</span> is the number of args
        (in addition to <span class="Li">$self</span>) to pass to the
      method.</p>
    <p class="Pp">The <span class="Li">&quot;flags&quot;</span> can be:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    G_DISCARD     invoke method with G_DISCARD flag and don't
                  return a value
    G_UNDEF_FILL  fill the stack with argc pointers to
                  PL_sv_undef
    </pre>
    <p class="Pp">The arguments themselves are any values following the
        <span class="Li">&quot;flags&quot;</span> argument.</p>
    <p class="Pp">Returns the SV (if any) returned by the method, or NULL on
        failure.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     magic_methcall(SV *sv, const MAGIC *mg,
                               const char *meth, U32 flags,
                               U32 argc, ...)
    </pre>
  </dd>
  <dt>magic_sethint</dt>
  <dd>Triggered by a store to %^H, records the key/value pair to
      <span class="Li">&quot;PL_compiling.cop_hints_hash&quot;</span>. It is
      assumed that hints aren't storing anything that would need a deep copy.
      Maybe we should warn if we find a reference.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        int     magic_sethint(SV* sv, MAGIC* mg)
    </pre>
  </dd>
  <dt>mg_localize</dt>
  <dd>Copy some of the magic from an existing SV to new localized version of
      that SV. Container magic (eg <span class="Li">%ENV</span>,
      <span class="Li">$1</span>, tie) gets copied, value magic doesn't (eg
      taint, pos).
    <p class="Pp">If setmagic is false then no set magic will be called on the
        new (empty) SV. This typically means that assignment will soon follow
        (e.g. 'local <span class="Li">$x</span> = <span class="Li">$y</span>'),
        and that will handle the magic.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mg_localize(SV* sv, SV* nsv, bool setmagic)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="MRO_Functions"><a class="permalink" href="#MRO_Functions">MRO
  Functions</a></h1>
<dl class="Bl-tag">
  <dt>mro_get_linear_isa_dfs</dt>
  <dd>Returns the Depth-First Search linearization of
      <span class="Li">@ISA</span> the given stash. The return value is a
      read-only AV*. <span class="Li">&quot;level&quot;</span> should be 0 (it
      is used internally in this function's recursion).
    <p class="Pp">You are responsible for
        <span class="Li">&quot;SvREFCNT_inc()&quot;</span> on the return value
        if you plan to store it anywhere semi-permanently (otherwise it might be
        deleted out from under you the next time the cache is invalidated).</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        AV*     mro_get_linear_isa_dfs(HV* stash, U32 level)
    </pre>
  </dd>
  <dt>mro_isa_changed_in</dt>
  <dd>Takes the necessary steps (cache invalidations, mostly) when the
      <span class="Li">@ISA</span> of the given package has changed. Invoked by
      the <span class="Li">&quot;setisa&quot;</span> magic, should not need to
      invoke directly.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mro_isa_changed_in(HV* stash)
    </pre>
  </dd>
  <dt>mro_package_moved</dt>
  <dd>Call this function to signal to a stash that it has been assigned to
      another spot in the stash hierarchy.
      <span class="Li">&quot;stash&quot;</span> is the stash that has been
      assigned. <span class="Li">&quot;oldstash&quot;</span> is the stash it
      replaces, if any. <span class="Li">&quot;gv&quot;</span> is the glob that
      is actually being assigned to.
    <p class="Pp">This can also be called with a null first argument to indicate
        that <span class="Li">&quot;oldstash&quot;</span> has been deleted.</p>
    <p class="Pp">This function invalidates isa caches on the old stash, on all
        subpackages nested inside it, and on the subclasses of all those,
        including non-existent packages that have corresponding entries in
        <span class="Li">&quot;stash&quot;</span>.</p>
    <p class="Pp">It also sets the effective names
        (<span class="Li">&quot;HvENAME&quot;</span>) on all the stashes as
        appropriate.</p>
    <p class="Pp">If the <span class="Li">&quot;gv&quot;</span> is present and
        is not in the symbol table, then this function simply returns. This
        checked will be skipped if <span class="Li">&quot;flags &amp;
        1&quot;</span>.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    mro_package_moved(HV * const stash,
                                  HV * const oldstash,
                                  const GV * const gv,
                                  U32 flags)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Optree_Manipulation_Functions"><a class="permalink" href="#Optree_Manipulation_Functions">Optree
  Manipulation Functions</a></h1>
<dl class="Bl-tag">
  <dt>finalize_optree</dt>
  <dd>This function finalizes the optree. Should be called directly after the
      complete optree is built. It does some additional checking which can't be
      done in the normal ck_xxx functions and makes the tree thread-safe.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    finalize_optree(OP* o)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Pad_Data_Structures"><a class="permalink" href="#Pad_Data_Structures">Pad
  Data Structures</a></h1>
<dl class="Bl-tag">
  <dt>CX_CURPAD_SAVE </dt>
  <dd>Save the current pad in the given context block structure.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    CX_CURPAD_SAVE(struct context)
    </pre>
  </dd>
  <dt>CX_CURPAD_SV </dt>
  <dd>Access the SV at offset po in the saved current pad in the given context
      block structure (can be used as an lvalue).
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    CX_CURPAD_SV(struct context, PADOFFSET po)
    </pre>
  </dd>
  <dt>PadnameIsOUR</dt>
  <dd>Whether this is an &quot;our&quot; variable.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    PadnameIsOUR(PADNAME pn)
    </pre>
  </dd>
  <dt>PadnameIsSTATE</dt>
  <dd>Whether this is a &quot;state&quot; variable.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    PadnameIsSTATE(PADNAME pn)
    </pre>
  </dd>
  <dt>PadnameOURSTASH</dt>
  <dd>The stash in which this &quot;our&quot; variable was declared.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV *    PadnameOURSTASH()
    </pre>
  </dd>
  <dt>PadnameOUTER</dt>
  <dd>Whether this entry belongs to an outer pad.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    PadnameOUTER(PADNAME pn)
    </pre>
  </dd>
  <dt>PadnameTYPE</dt>
  <dd>The stash associated with a typed lexical. This returns the
      <span class="Li">%Foo::</span> hash for <span class="Li">&quot;my Foo
      $bar&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV *    PadnameTYPE(PADNAME pn)
    </pre>
  </dd>
  <dt>PAD_BASE_SV </dt>
  <dd>Get the value from slot <span class="Li">&quot;po&quot;</span> in the base
      (DEPTH=1) pad of a padlist
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    PAD_BASE_SV(PADLIST padlist, PADOFFSET po)
    </pre>
  </dd>
  <dt>PAD_CLONE_VARS </dt>
  <dd>Clone the state variables associated with running and compiling pads.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PAD_CLONE_VARS(PerlInterpreter *proto_perl,
                               CLONE_PARAMS* param)
    </pre>
  </dd>
  <dt>PAD_COMPNAME_FLAGS </dt>
  <dd>Return the flags for the current compiling pad name at offset
      <span class="Li">&quot;po&quot;</span>. Assumes a valid slot entry.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     PAD_COMPNAME_FLAGS(PADOFFSET po)
    </pre>
  </dd>
  <dt>PAD_COMPNAME_GEN </dt>
  <dd>The generation number of the name at offset
      <span class="Li">&quot;po&quot;</span> in the current compiling pad
      (lvalue). Note that <span class="Li">&quot;SvUVX&quot;</span> is hijacked
      for this purpose.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  PAD_COMPNAME_GEN(PADOFFSET po)
    </pre>
  </dd>
  <dt>PAD_COMPNAME_GEN_set</dt>
  <dd>Sets the generation number of the name at offset
      <span class="Li">&quot;po&quot;</span> in the current ling pad (lvalue) to
      <span class="Li">&quot;gen&quot;</span>. Note that
      <span class="Li">&quot;SvUV_set&quot;</span> is hijacked for this purpose.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        STRLEN  PAD_COMPNAME_GEN_set(PADOFFSET po, int gen)
    </pre>
  </dd>
  <dt>PAD_COMPNAME_OURSTASH </dt>
  <dd>Return the stash associated with an
      <span class="Li">&quot;our&quot;</span> variable. Assumes the slot entry
      is a valid <span class="Li">&quot;our&quot;</span> lexical.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV *    PAD_COMPNAME_OURSTASH(PADOFFSET po)
    </pre>
  </dd>
  <dt>PAD_COMPNAME_PV </dt>
  <dd>Return the name of the current compiling pad name at offset
      <span class="Li">&quot;po&quot;</span>. Assumes a valid slot entry.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        char *  PAD_COMPNAME_PV(PADOFFSET po)
    </pre>
  </dd>
  <dt>PAD_COMPNAME_TYPE </dt>
  <dd>Return the type (stash) of the current compiling pad name at offset
      <span class="Li">&quot;po&quot;</span>. Must be a valid name. Returns null
      if not typed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        HV *    PAD_COMPNAME_TYPE(PADOFFSET po)
    </pre>
  </dd>
  <dt>pad_peg</dt>
  <dd>When PERL_MAD is enabled, this is a small no-op function that gets called
      at the start of each pad-related function. It can be breakpointed to track
      all pad operations. The parameter is a string indicating the type of pad
      operation being performed.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    pad_peg(const char *s)
    </pre>
  </dd>
  <dt>PAD_RESTORE_LOCAL </dt>
  <dd>Restore the old pad saved into the local variable opad by
      <i>PAD_SAVE_LOCAL()</i>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PAD_RESTORE_LOCAL(PAD *opad)
    </pre>
  </dd>
  <dt>PAD_SAVE_LOCAL </dt>
  <dd>Save the current pad to the local variable opad, then make the current pad
      equal to npad
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PAD_SAVE_LOCAL(PAD *opad, PAD *npad)
    </pre>
  </dd>
  <dt>PAD_SAVE_SETNULLPAD </dt>
  <dd>Save the current pad then set it to null.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PAD_SAVE_SETNULLPAD()
    </pre>
  </dd>
  <dt>PAD_SETSV </dt>
  <dd>Set the slot at offset <span class="Li">&quot;po&quot;</span> in the
      current pad to <span class="Li">&quot;sv&quot;</span>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    PAD_SETSV(PADOFFSET po, SV* sv)
    </pre>
  </dd>
  <dt>PAD_SET_CUR </dt>
  <dd>Set the current pad to be pad <span class="Li">&quot;n&quot;</span> in the
      padlist, saving the previous current pad. NB currently this macro expands
      to a string too long for some compilers, so it's best to replace it with
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    SAVECOMPPAD();
    PAD_SET_CUR_NOSAVE(padlist,n);


        void    PAD_SET_CUR(PADLIST padlist, I32 n)
    </pre>
  </dd>
  <dt>PAD_SET_CUR_NOSAVE </dt>
  <dd>like PAD_SET_CUR, but without the save
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PAD_SET_CUR_NOSAVE(PADLIST padlist, I32 n)
    </pre>
  </dd>
  <dt>PAD_SV </dt>
  <dd>Get the value at offset <span class="Li">&quot;po&quot;</span> in the
      current pad
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    PAD_SV(PADOFFSET po)
    </pre>
  </dd>
  <dt>PAD_SVl</dt>
  <dd>Lightweight and lvalue version of
      <span class="Li">&quot;PAD_SV&quot;</span>. Get or set the value at offset
      <span class="Li">&quot;po&quot;</span> in the current pad. Unlike
      <span class="Li">&quot;PAD_SV&quot;</span>, does not print diagnostics
      with -DX. For internal use only.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    PAD_SVl(PADOFFSET po)
    </pre>
  </dd>
  <dt>SAVECLEARSV </dt>
  <dd>Clear the pointed to pad value on scope exit. (i.e. the runtime action of
      'my')
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SAVECLEARSV(SV **svp)
    </pre>
  </dd>
  <dt>SAVECOMPPAD </dt>
  <dd>save PL_comppad and PL_curpad
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    SAVECOMPPAD()
    </pre>
  </dd>
  <dt>SAVEPADSV </dt>
  <dd>Save a pad slot (used to restore after an iteration)
    <p class="Pp">XXX DAPM it would make more sense to make the arg a PADOFFSET
        	void	SAVEPADSV(PADOFFSET po)</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Per-Interpreter_Variables"><a class="permalink" href="#Per-Interpreter_Variables">Per-Interpreter
  Variables</a></h1>
<dl class="Bl-tag">
  <dt>PL_DBsingle</dt>
  <dd>When Perl is run in debugging mode, with the <b>-d</b> switch, this SV is
      a boolean which indicates whether subs are being single-stepped.
      Single-stepping is automatically turned on after every step. This is the C
      variable which corresponds to Perl's <span class="Li">$DB::single</span>
      variable. See <span class="Li">&quot;PL_DBsub&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    PL_DBsingle
    </pre>
  </dd>
  <dt>PL_DBsub</dt>
  <dd>When Perl is run in debugging mode, with the <b>-d</b> switch, this GV
      contains the SV which holds the name of the sub being debugged. This is
      the C variable which corresponds to Perl's
      <span class="Li">$DB::sub</span> variable. See
      <span class="Li">&quot;PL_DBsingle&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV *    PL_DBsub
    </pre>
  </dd>
  <dt>PL_DBtrace</dt>
  <dd>Trace variable used when Perl is run in debugging mode, with the <b>-d</b>
      switch. This is the C variable which corresponds to Perl's
      <span class="Li">$DB::trace</span> variable. See
      <span class="Li">&quot;PL_DBsingle&quot;</span>.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV *    PL_DBtrace
    </pre>
  </dd>
  <dt>PL_dowarn</dt>
  <dd>The C variable which corresponds to Perl's $^W warning variable.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        bool    PL_dowarn
    </pre>
  </dd>
  <dt>PL_last_in_gv</dt>
  <dd>The GV which was last used for a filehandle input operation.
      (<span class="Li">&quot;&lt;FH&gt;&quot;</span>)
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     PL_last_in_gv
    </pre>
  </dd>
  <dt>PL_ofsgv</dt>
  <dd>The glob containing the output field separator -
      <span class="Li">&quot;*,&quot;</span> in Perl space.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        GV*     PL_ofsgv
    </pre>
  </dd>
  <dt>PL_rs</dt>
  <dd>The input record separator - <span class="Li">$/</span> in Perl space.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     PL_rs
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Stack_Manipulation_Macros"><a class="permalink" href="#Stack_Manipulation_Macros">Stack
  Manipulation Macros</a></h1>
<dl class="Bl-tag">
  <dt>djSP</dt>
  <dd>Declare Just <span class="Li">&quot;SP&quot;</span>. This is actually
      identical to <span class="Li">&quot;dSP&quot;</span>, and declares a local
      copy of perl's stack pointer, available via the
      <span class="Li">&quot;SP&quot;</span> macro. See
      <span class="Li">&quot;SP&quot;</span>. (Available for backward source
      code compatibility with the old (Perl 5.005) thread model.)
    <p class="Pp"><span class="Li"></span></p>
    <pre>
                djSP;
    </pre>
  </dd>
  <dt>LVRET </dt>
  <dd>True if this op will be the return value of an lvalue subroutine</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SV_Manipulation_Functions"><a class="permalink" href="#SV_Manipulation_Functions">SV
  Manipulation Functions</a></h1>
<dl class="Bl-tag">
  <dt>SvTHINKFIRST</dt>
  <dd>A quick flag check to see whether an sv should be passed to
      sv_force_normal to be &quot;downgraded&quot; before SvIVX or SvPVX can be
      modified directly.
    <p class="Pp">For example, if your scalar is a reference and you want to
        modify the SvIVX slot, you can't just do SvROK_off, as that will leak
        the referent.</p>
    <p class="Pp">This is used internally by various sv-modifying functions,
        such as sv_setsv, sv_setiv and sv_pvn_force.</p>
    <p class="Pp">One case that this does not handle is a gv without SvFAKE set.
        After</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    if (SvTHINKFIRST(gv)) sv_force_normal(gv);
    </pre>
    <p class="Pp">it will still be a gv.</p>
    <p class="Pp">SvTHINKFIRST sometimes produces false positives. In those
        cases sv_force_normal does nothing.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        U32     SvTHINKFIRST(SV *sv)
    </pre>
  </dd>
  <dt>sv_add_arena</dt>
  <dd>Given a chunk of memory, link it to the head of the list of arenas, and
      split it into a list of free SVs.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_add_arena(char *const ptr, const U32 size,
                             const U32 flags)
    </pre>
  </dd>
  <dt>sv_clean_all</dt>
  <dd>Decrement the refcnt of each remaining SV, possibly triggering a cleanup.
      This function may have to be called multiple times to free SVs which are
      in complex self-referential hierarchies.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        I32     sv_clean_all()
    </pre>
  </dd>
  <dt>sv_clean_objs</dt>
  <dd>Attempt to destroy all objects not yet freed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_clean_objs()
    </pre>
  </dd>
  <dt>sv_free_arenas</dt>
  <dd>Deallocate the memory used by all arenas. Note that all the individual SV
      heads and bodies within the arenas must already have been freed.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_free_arenas()
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="SV-Body_Allocation"><a class="permalink" href="#SV-Body_Allocation">SV-Body
  Allocation</a></h1>
<dl class="Bl-tag">
  <dt>sv_2num</dt>
  <dd>Return an SV with the numeric value of the source SV, doing any necessary
      reference or overload conversion. You must use the
      <span class="Li">&quot;SvNUM(sv)&quot;</span> macro to access this
      function.
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_2num(SV *const sv)
    </pre>
  </dd>
  <dt>sv_copypv</dt>
  <dd>Copies a stringified representation of the source SV into the destination
      SV. Automatically performs any necessary mg_get and coercion of numeric
      values into strings. Guaranteed to preserve UTF8 flag even from overloaded
      objects. Similar in nature to sv_2pv[_flags] but operates directly on an
      SV instead of just the string. Mostly uses sv_2pv_flags to do its work,
      except when that would lose the UTF-8'ness of the PV.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    sv_copypv(SV *const dsv, SV *const ssv)
    </pre>
  </dd>
  <dt>sv_ref</dt>
  <dd>Returns a SV describing what the SV passed in is a reference to.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     sv_ref(SV *dst, const SV *const sv,
                       const int ob)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Unicode_Support"><a class="permalink" href="#Unicode_Support">Unicode
  Support</a></h1>
<dl class="Bl-tag">
  <dt>find_uninit_var</dt>
  <dd>Find the name of the undefined variable (if any) that caused the operator
      to issue a &quot;Use of uninitialized value&quot; warning. If match is
      true, only return a name if its value matches uninit_sv. So roughly
      speaking, if a unary operator (such as OP_COS) generates a warning, then
      following the direct child of the op may yield an OP_PADSV or OP_GV that
      gives the name of the undefined variable. On the other hand, with OP_ADD
      there are two branches to follow, so we only print the variable name if we
      get an exact match.
    <p class="Pp">The name is returned as a mortal SV.</p>
    <p class="Pp">Assumes that PL_op is the op that originally triggered the
        error, and that PL_comppad/PL_curpad points to the currently executing
        pad.</p>
    <p class="Pp">NOTE: this function is experimental and may change or be
        removed without notice.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        SV*     find_uninit_var(const OP *const obase,
                                const SV *const uninit_sv,
                                bool top)
    </pre>
  </dd>
  <dt>report_uninit</dt>
  <dd>Print appropriate &quot;Use of uninitialized variable&quot; warning.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
        void    report_uninit(const SV *uninit_sv)
    </pre>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="Undocumented_functions"><a class="permalink" href="#Undocumented_functions">Undocumented
  functions</a></h1>
The following functions are currently undocumented. If you use one of them, you
  may wish to consider creating and submitting documentation for it.
<dl class="Bl-tag">
  <dt>Perl_croak_memory_wrap</dt>
  <dd></dd>
  <dt>Slab_Alloc</dt>
  <dd></dd>
  <dt>Slab_Free</dt>
  <dd></dd>
  <dt>Slab_to_ro</dt>
  <dd></dd>
  <dt>Slab_to_rw</dt>
  <dd></dd>
  <dt>_add_range_to_invlist</dt>
  <dd></dd>
  <dt>_core_swash_init</dt>
  <dd></dd>
  <dt>_get_invlist_len_addr</dt>
  <dd></dd>
  <dt>_get_swash_invlist</dt>
  <dd></dd>
  <dt>_invlist_array_init</dt>
  <dd></dd>
  <dt>_invlist_contains_cp</dt>
  <dd></dd>
  <dt>_invlist_contents</dt>
  <dd></dd>
  <dt>_invlist_intersection</dt>
  <dd></dd>
  <dt>_invlist_intersection_maybe_complement_2nd</dt>
  <dd></dd>
  <dt>_invlist_invert</dt>
  <dd></dd>
  <dt>_invlist_invert_prop</dt>
  <dd></dd>
  <dt>_invlist_len</dt>
  <dd></dd>
  <dt>_invlist_populate_swatch</dt>
  <dd></dd>
  <dt>_invlist_search</dt>
  <dd></dd>
  <dt>_invlist_subtract</dt>
  <dd></dd>
  <dt>_invlist_union</dt>
  <dd></dd>
  <dt>_invlist_union_maybe_complement_2nd</dt>
  <dd></dd>
  <dt>_new_invlist</dt>
  <dd></dd>
  <dt>_swash_inversion_hash</dt>
  <dd></dd>
  <dt>_swash_to_invlist</dt>
  <dd></dd>
  <dt>_to_fold_latin1</dt>
  <dd></dd>
  <dt>_to_upper_title_latin1</dt>
  <dd></dd>
  <dt>aassign_common_vars</dt>
  <dd></dd>
  <dt>add_cp_to_invlist</dt>
  <dd></dd>
  <dt>addmad</dt>
  <dd></dd>
  <dt>alloc_maybe_populate_EXACT</dt>
  <dd></dd>
  <dt>allocmy</dt>
  <dd></dd>
  <dt>amagic_is_enabled</dt>
  <dd></dd>
  <dt>append_madprops</dt>
  <dd></dd>
  <dt>apply</dt>
  <dd></dd>
  <dt>av_extend_guts</dt>
  <dd></dd>
  <dt>av_reify</dt>
  <dd></dd>
  <dt>bind_match</dt>
  <dd></dd>
  <dt>block_end</dt>
  <dd></dd>
  <dt>block_start</dt>
  <dd></dd>
  <dt>boot_core_PerlIO</dt>
  <dd></dd>
  <dt>boot_core_UNIVERSAL</dt>
  <dd></dd>
  <dt>boot_core_mro</dt>
  <dd></dd>
  <dt>cando</dt>
  <dd></dd>
  <dt>check_utf8_print</dt>
  <dd></dd>
  <dt>ck_entersub_args_core</dt>
  <dd></dd>
  <dt>compute_EXACTish</dt>
  <dd></dd>
  <dt>convert</dt>
  <dd></dd>
  <dt>coresub_op</dt>
  <dd></dd>
  <dt>create_eval_scope</dt>
  <dd></dd>
  <dt>croak_no_mem</dt>
  <dd></dd>
  <dt>croak_popstack</dt>
  <dd></dd>
  <dt>current_re_engine</dt>
  <dd></dd>
  <dt>cv_ckproto_len_flags</dt>
  <dd></dd>
  <dt>cv_clone_into</dt>
  <dd></dd>
  <dt>cvgv_set</dt>
  <dd></dd>
  <dt>cvstash_set</dt>
  <dd></dd>
  <dt>deb_stack_all</dt>
  <dd></dd>
  <dt>delete_eval_scope</dt>
  <dd></dd>
  <dt>die_unwind</dt>
  <dd></dd>
  <dt>do_aexec</dt>
  <dd></dd>
  <dt>do_aexec5</dt>
  <dd></dd>
  <dt>do_eof</dt>
  <dd></dd>
  <dt>do_exec</dt>
  <dd></dd>
  <dt>do_exec3</dt>
  <dd></dd>
  <dt>do_execfree</dt>
  <dd></dd>
  <dt>do_ipcctl</dt>
  <dd></dd>
  <dt>do_ipcget</dt>
  <dd></dd>
  <dt>do_msgrcv</dt>
  <dd></dd>
  <dt>do_msgsnd</dt>
  <dd></dd>
  <dt>do_ncmp</dt>
  <dd></dd>
  <dt>do_op_xmldump</dt>
  <dd></dd>
  <dt>do_pmop_xmldump</dt>
  <dd></dd>
  <dt>do_print</dt>
  <dd></dd>
  <dt>do_readline</dt>
  <dd></dd>
  <dt>do_seek</dt>
  <dd></dd>
  <dt>do_semop</dt>
  <dd></dd>
  <dt>do_shmio</dt>
  <dd></dd>
  <dt>do_sysseek</dt>
  <dd></dd>
  <dt>do_tell</dt>
  <dd></dd>
  <dt>do_trans</dt>
  <dd></dd>
  <dt>do_vecget</dt>
  <dd></dd>
  <dt>do_vecset</dt>
  <dd></dd>
  <dt>do_vop</dt>
  <dd></dd>
  <dt>dofile</dt>
  <dd></dd>
  <dt>dump_all_perl</dt>
  <dd></dd>
  <dt>dump_packsubs_perl</dt>
  <dd></dd>
  <dt>dump_sub_perl</dt>
  <dd></dd>
  <dt>dump_sv_child</dt>
  <dd></dd>
  <dt>emulate_cop_io</dt>
  <dd></dd>
  <dt>feature_is_enabled</dt>
  <dd></dd>
  <dt>find_lexical_cv</dt>
  <dd></dd>
  <dt>find_runcv_where</dt>
  <dd></dd>
  <dt>find_rundefsv2</dt>
  <dd></dd>
  <dt>find_script</dt>
  <dd></dd>
  <dt>free_tied_hv_pool</dt>
  <dd></dd>
  <dt>get_and_check_backslash_N_name</dt>
  <dd></dd>
  <dt>get_db_sub</dt>
  <dd></dd>
  <dt>get_debug_opts</dt>
  <dd></dd>
  <dt>get_hash_seed</dt>
  <dd></dd>
  <dt>get_invlist_iter_addr</dt>
  <dd></dd>
  <dt>get_invlist_previous_index_addr</dt>
  <dd></dd>
  <dt>get_invlist_version_id_addr</dt>
  <dd></dd>
  <dt>get_invlist_zero_addr</dt>
  <dd></dd>
  <dt>get_no_modify</dt>
  <dd></dd>
  <dt>get_opargs</dt>
  <dd></dd>
  <dt>get_re_arg</dt>
  <dd></dd>
  <dt>getenv_len</dt>
  <dd></dd>
  <dt>grok_bslash_x</dt>
  <dd></dd>
  <dt>hfree_next_entry</dt>
  <dd></dd>
  <dt>hv_backreferences_p</dt>
  <dd></dd>
  <dt>hv_kill_backrefs</dt>
  <dd></dd>
  <dt>hv_undef_flags</dt>
  <dd></dd>
  <dt>init_argv_symbols</dt>
  <dd></dd>
  <dt>init_constants</dt>
  <dd></dd>
  <dt>init_dbargs</dt>
  <dd></dd>
  <dt>init_debugger</dt>
  <dd></dd>
  <dt>invert</dt>
  <dd></dd>
  <dt>invlist_array</dt>
  <dd></dd>
  <dt>invlist_clone</dt>
  <dd></dd>
  <dt>invlist_highest</dt>
  <dd></dd>
  <dt>invlist_is_iterating</dt>
  <dd></dd>
  <dt>invlist_iterfinish</dt>
  <dd></dd>
  <dt>invlist_iterinit</dt>
  <dd></dd>
  <dt>invlist_max</dt>
  <dd></dd>
  <dt>invlist_previous_index</dt>
  <dd></dd>
  <dt>invlist_set_len</dt>
  <dd></dd>
  <dt>invlist_set_previous_index</dt>
  <dd></dd>
  <dt>invlist_trim</dt>
  <dd></dd>
  <dt>io_close</dt>
  <dd></dd>
  <dt>isALNUM_lazy</dt>
  <dd></dd>
  <dt>isIDFIRST_lazy</dt>
  <dd></dd>
  <dt>is_utf8_char_slow</dt>
  <dd></dd>
  <dt>is_utf8_common</dt>
  <dd></dd>
  <dt>jmaybe</dt>
  <dd></dd>
  <dt>keyword</dt>
  <dd></dd>
  <dt>keyword_plugin_standard</dt>
  <dd></dd>
  <dt>list</dt>
  <dd></dd>
  <dt>localize</dt>
  <dd></dd>
  <dt>mad_free</dt>
  <dd></dd>
  <dt>madlex</dt>
  <dd></dd>
  <dt>madparse</dt>
  <dd></dd>
  <dt>magic_clear_all_env</dt>
  <dd></dd>
  <dt>magic_cleararylen_p</dt>
  <dd></dd>
  <dt>magic_clearenv</dt>
  <dd></dd>
  <dt>magic_clearisa</dt>
  <dd></dd>
  <dt>magic_clearpack</dt>
  <dd></dd>
  <dt>magic_clearsig</dt>
  <dd></dd>
  <dt>magic_copycallchecker</dt>
  <dd></dd>
  <dt>magic_existspack</dt>
  <dd></dd>
  <dt>magic_freearylen_p</dt>
  <dd></dd>
  <dt>magic_freeovrld</dt>
  <dd></dd>
  <dt>magic_get</dt>
  <dd></dd>
  <dt>magic_getarylen</dt>
  <dd></dd>
  <dt>magic_getdefelem</dt>
  <dd></dd>
  <dt>magic_getnkeys</dt>
  <dd></dd>
  <dt>magic_getpack</dt>
  <dd></dd>
  <dt>magic_getpos</dt>
  <dd></dd>
  <dt>magic_getsig</dt>
  <dd></dd>
  <dt>magic_getsubstr</dt>
  <dd></dd>
  <dt>magic_gettaint</dt>
  <dd></dd>
  <dt>magic_getuvar</dt>
  <dd></dd>
  <dt>magic_getvec</dt>
  <dd></dd>
  <dt>magic_killbackrefs</dt>
  <dd></dd>
  <dt>magic_nextpack</dt>
  <dd></dd>
  <dt>magic_regdata_cnt</dt>
  <dd></dd>
  <dt>magic_regdatum_get</dt>
  <dd></dd>
  <dt>magic_regdatum_set</dt>
  <dd></dd>
  <dt>magic_scalarpack</dt>
  <dd></dd>
  <dt>magic_set</dt>
  <dd></dd>
  <dt>magic_set_all_env</dt>
  <dd></dd>
  <dt>magic_setarylen</dt>
  <dd></dd>
  <dt>magic_setcollxfrm</dt>
  <dd></dd>
  <dt>magic_setdbline</dt>
  <dd></dd>
  <dt>magic_setdefelem</dt>
  <dd></dd>
  <dt>magic_setenv</dt>
  <dd></dd>
  <dt>magic_setisa</dt>
  <dd></dd>
  <dt>magic_setmglob</dt>
  <dd></dd>
  <dt>magic_setnkeys</dt>
  <dd></dd>
  <dt>magic_setpack</dt>
  <dd></dd>
  <dt>magic_setpos</dt>
  <dd></dd>
  <dt>magic_setregexp</dt>
  <dd></dd>
  <dt>magic_setsig</dt>
  <dd></dd>
  <dt>magic_setsubstr</dt>
  <dd></dd>
  <dt>magic_settaint</dt>
  <dd></dd>
  <dt>magic_setutf8</dt>
  <dd></dd>
  <dt>magic_setuvar</dt>
  <dd></dd>
  <dt>magic_setvec</dt>
  <dd></dd>
  <dt>magic_sizepack</dt>
  <dd></dd>
  <dt>magic_wipepack</dt>
  <dd></dd>
  <dt>malloc_good_size</dt>
  <dd></dd>
  <dt>malloced_size</dt>
  <dd></dd>
  <dt>mem_collxfrm</dt>
  <dd></dd>
  <dt>mode_from_discipline</dt>
  <dd></dd>
  <dt>more_bodies</dt>
  <dd></dd>
  <dt>mro_meta_dup</dt>
  <dd></dd>
  <dt>mro_meta_init</dt>
  <dd></dd>
  <dt>my_attrs</dt>
  <dd></dd>
  <dt>my_betoh16</dt>
  <dd></dd>
  <dt>my_betoh32</dt>
  <dd></dd>
  <dt>my_betoh64</dt>
  <dd></dd>
  <dt>my_betohi</dt>
  <dd></dd>
  <dt>my_betohl</dt>
  <dd></dd>
  <dt>my_betohs</dt>
  <dd></dd>
  <dt>my_clearenv</dt>
  <dd></dd>
  <dt>my_htobe16</dt>
  <dd></dd>
  <dt>my_htobe32</dt>
  <dd></dd>
  <dt>my_htobe64</dt>
  <dd></dd>
  <dt>my_htobei</dt>
  <dd></dd>
  <dt>my_htobel</dt>
  <dd></dd>
  <dt>my_htobes</dt>
  <dd></dd>
  <dt>my_htole16</dt>
  <dd></dd>
  <dt>my_htole32</dt>
  <dd></dd>
  <dt>my_htole64</dt>
  <dd></dd>
  <dt>my_htolei</dt>
  <dd></dd>
  <dt>my_htolel</dt>
  <dd></dd>
  <dt>my_htoles</dt>
  <dd></dd>
  <dt>my_letoh16</dt>
  <dd></dd>
  <dt>my_letoh32</dt>
  <dd></dd>
  <dt>my_letoh64</dt>
  <dd></dd>
  <dt>my_letohi</dt>
  <dd></dd>
  <dt>my_letohl</dt>
  <dd></dd>
  <dt>my_letohs</dt>
  <dd></dd>
  <dt>my_lstat_flags</dt>
  <dd></dd>
  <dt>my_stat_flags</dt>
  <dd></dd>
  <dt>my_swabn</dt>
  <dd></dd>
  <dt>my_unexec</dt>
  <dd></dd>
  <dt>newATTRSUB_flags</dt>
  <dd></dd>
  <dt>newGP</dt>
  <dd></dd>
  <dt>newMADPROP</dt>
  <dd></dd>
  <dt>newMADsv</dt>
  <dd></dd>
  <dt>newSTUB</dt>
  <dd></dd>
  <dt>newTOKEN</dt>
  <dd></dd>
  <dt>newXS_len_flags</dt>
  <dd></dd>
  <dt>new_warnings_bitfield</dt>
  <dd></dd>
  <dt>nextargv</dt>
  <dd></dd>
  <dt>oopsAV</dt>
  <dd></dd>
  <dt>oopsHV</dt>
  <dd></dd>
  <dt>op_clear</dt>
  <dd></dd>
  <dt>op_const_sv</dt>
  <dd></dd>
  <dt>op_getmad</dt>
  <dd></dd>
  <dt>op_getmad_weak</dt>
  <dd></dd>
  <dt>op_integerize</dt>
  <dd></dd>
  <dt>op_lvalue_flags</dt>
  <dd></dd>
  <dt>op_refcnt_dec</dt>
  <dd></dd>
  <dt>op_refcnt_inc</dt>
  <dd></dd>
  <dt>op_std_init</dt>
  <dd></dd>
  <dt>op_unscope</dt>
  <dd></dd>
  <dt>op_xmldump</dt>
  <dd></dd>
  <dt>opslab_force_free</dt>
  <dd></dd>
  <dt>opslab_free</dt>
  <dd></dd>
  <dt>opslab_free_nopad</dt>
  <dd></dd>
  <dt>package</dt>
  <dd></dd>
  <dt>package_version</dt>
  <dd></dd>
  <dt>padlist_store</dt>
  <dd></dd>
  <dt>parse_unicode_opts</dt>
  <dd></dd>
  <dt>parser_free</dt>
  <dd></dd>
  <dt>parser_free_nexttoke_ops</dt>
  <dd></dd>
  <dt>peep</dt>
  <dd></dd>
  <dt>pmop_xmldump</dt>
  <dd></dd>
  <dt>pmruntime</dt>
  <dd></dd>
  <dt>populate_isa</dt>
  <dd></dd>
  <dt>prepend_madprops</dt>
  <dd></dd>
  <dt>qerror</dt>
  <dd></dd>
  <dt>re_op_compile</dt>
  <dd></dd>
  <dt>reg_named_buff</dt>
  <dd></dd>
  <dt>reg_named_buff_iter</dt>
  <dd></dd>
  <dt>reg_numbered_buff_fetch</dt>
  <dd></dd>
  <dt>reg_numbered_buff_length</dt>
  <dd></dd>
  <dt>reg_numbered_buff_store</dt>
  <dd></dd>
  <dt>reg_qr_package</dt>
  <dd></dd>
  <dt>reg_temp_copy</dt>
  <dd></dd>
  <dt>regcurly</dt>
  <dd></dd>
  <dt>regpposixcc</dt>
  <dd></dd>
  <dt>regprop</dt>
  <dd></dd>
  <dt>report_evil_fh</dt>
  <dd></dd>
  <dt>report_redefined_cv</dt>
  <dd></dd>
  <dt>report_wrongway_fh</dt>
  <dd></dd>
  <dt>rpeep</dt>
  <dd></dd>
  <dt>rsignal_restore</dt>
  <dd></dd>
  <dt>rsignal_save</dt>
  <dd></dd>
  <dt>rxres_save</dt>
  <dd></dd>
  <dt>same_dirent</dt>
  <dd></dd>
  <dt>sawparens</dt>
  <dd></dd>
  <dt>scalar</dt>
  <dd></dd>
  <dt>scalarvoid</dt>
  <dd></dd>
  <dt>sighandler</dt>
  <dd></dd>
  <dt>softref2xv</dt>
  <dd></dd>
  <dt>sub_crush_depth</dt>
  <dd></dd>
  <dt>sv_add_backref</dt>
  <dd></dd>
  <dt>sv_catxmlpv</dt>
  <dd></dd>
  <dt>sv_catxmlpvn</dt>
  <dd></dd>
  <dt>sv_catxmlsv</dt>
  <dd></dd>
  <dt>sv_del_backref</dt>
  <dd></dd>
  <dt>sv_free2</dt>
  <dd></dd>
  <dt>sv_kill_backrefs</dt>
  <dd></dd>
  <dt>sv_len_utf8_nomg</dt>
  <dd></dd>
  <dt>sv_mortalcopy_flags</dt>
  <dd></dd>
  <dt>sv_resetpvn</dt>
  <dd></dd>
  <dt>sv_sethek</dt>
  <dd></dd>
  <dt>sv_setsv_cow</dt>
  <dd></dd>
  <dt>sv_unglob</dt>
  <dd></dd>
  <dt>sv_xmlpeek</dt>
  <dd></dd>
  <dt>tied_method</dt>
  <dd></dd>
  <dt>token_free</dt>
  <dd></dd>
  <dt>token_getmad</dt>
  <dd></dd>
  <dt>translate_substr_offsets</dt>
  <dd></dd>
  <dt>try_amagic_bin</dt>
  <dd></dd>
  <dt>try_amagic_un</dt>
  <dd></dd>
  <dt>unshare_hek</dt>
  <dd></dd>
  <dt>utilize</dt>
  <dd></dd>
  <dt>varname</dt>
  <dd></dd>
  <dt>vivify_defelem</dt>
  <dd></dd>
  <dt>vivify_ref</dt>
  <dd></dd>
  <dt>wait4pid</dt>
  <dd></dd>
  <dt>was_lvalue_sub</dt>
  <dd></dd>
  <dt>watch</dt>
  <dd></dd>
  <dt>win32_croak_not_implemented</dt>
  <dd></dd>
  <dt>write_to_stderr</dt>
  <dd></dd>
  <dt>xmldump_all</dt>
  <dd></dd>
  <dt>xmldump_all_perl</dt>
  <dd></dd>
  <dt>xmldump_eval</dt>
  <dd></dd>
  <dt>xmldump_form</dt>
  <dd></dd>
  <dt>xmldump_indent</dt>
  <dd></dd>
  <dt>xmldump_packsubs</dt>
  <dd></dd>
  <dt>xmldump_packsubs_perl</dt>
  <dd></dd>
  <dt>xmldump_sub</dt>
  <dd></dd>
  <dt>xmldump_sub_perl</dt>
  <dd></dd>
  <dt>xmldump_vindent</dt>
  <dd></dd>
  <dt>xs_apiversion_bootcheck</dt>
  <dd></dd>
  <dt>xs_version_bootcheck</dt>
  <dd></dd>
  <dt>yyerror</dt>
  <dd></dd>
  <dt>yyerror_pv</dt>
  <dd></dd>
  <dt>yyerror_pvn</dt>
  <dd></dd>
  <dt>yylex</dt>
  <dd></dd>
  <dt>yyparse</dt>
  <dd></dd>
  <dt>yyunlex</dt>
  <dd></dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
The autodocumentation system was originally added to the Perl core by Benjamin
  Stuhl. Documentation is by whoever was kind enough to document their
  functions.
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
perlguts, perlapi
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-06-05</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
