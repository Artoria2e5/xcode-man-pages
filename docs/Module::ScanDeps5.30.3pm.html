<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Module::ScanDeps(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Module::ScanDeps(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Module::ScanDeps(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Module::ScanDeps - Recursively scan Perl code for dependencies
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
Via the command-line program scandeps.pl:
<p class="Pp"><span class="Li"></span></p>
<pre>
    % scandeps.pl *.pm          # Print PREREQ_PM section for *.pm
    % scandeps.pl -e &quot;use utf8&quot; # Read script from command line
    % scandeps.pl -B *.pm       # Include core modules
    % scandeps.pl -V *.pm       # Show autoload/shared/data files
</pre>
<p class="Pp">Used in a program;</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Module::ScanDeps;

    # standard usage
    my $hash_ref = scan_deps(
        files   =&gt; [ 'a.pl', 'b.pl' ],
        recurse =&gt; 1,
    );

    # shorthand; assume recurse == 1
    my $hash_ref = scan_deps( 'a.pl', 'b.pl' );

    # App::Packer::Frontend compatible interface
    # see App::Packer::Frontend for the structure returned by get_files
    my $scan = Module::ScanDeps-&gt;new;
    $scan-&gt;set_file( 'a.pl' );
    $scan-&gt;set_options( add_modules =&gt; [ 'Test::More' ] );
    $scan-&gt;calculate_info;
    my $files = $scan-&gt;get_files;
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module scans potential modules used by perl programs, and returns a hash
  reference; its keys are the module names as appears in
  <span class="Li">%INC</span> (e.g.
  <span class="Li">&quot;Test/More.pm&quot;</span>); the values are hash
  references with this structure:
<p class="Pp"><span class="Li"></span></p>
<pre>
    {
        file    =&gt; '/usr/local/lib/perl5/5.8.0/Test/More.pm',
        key     =&gt; 'Test/More.pm',
        type    =&gt; 'module',    # or 'autoload', 'data', 'shared'
        used_by =&gt; [ 'Test/Simple.pm', ... ],
        uses    =&gt; [ 'Test/Other.pm', ... ],
    }
</pre>
<p class="Pp">One function, <span class="Li">&quot;scan_deps&quot;</span>, is
    exported by default. Other functions such as
    (<span class="Li">&quot;scan_line&quot;</span>,
    <span class="Li">&quot;scan_chunk&quot;</span>,
    <span class="Li">&quot;add_deps&quot;</span>,
    <span class="Li">&quot;path_to_inc_name&quot;</span>) are exported upon
    request.</p>
<p class="Pp">Users of <b>App::Packer</b> may also use this module as the
    dependency-checking frontend, by tweaking their <i>p2e.pl</i> like
  below:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use Module::ScanDeps;
    ...
    my $packer = App::Packer-&gt;new( frontend =&gt; 'Module::ScanDeps' );
    ...
</pre>
<p class="Pp">Please see App::Packer::Frontend for detailed explanation on the
    structure returned by <span class="Li">&quot;get_files&quot;</span>.</p>
<section class="Ss">
<h2 class="Ss" id="_fBscan_deps_fP"><a class="permalink" href="#_fBscan_deps_fP"><b>scan_deps</b></a></h2>
<span class="Li"></span>
<pre>
    $rv_ref = scan_deps(
        files      =&gt; \@files,     recurse =&gt; $recurse,
        rv         =&gt; \%rv,        skip    =&gt; \%skip,
        compile    =&gt; $compile,    execute =&gt; $execute,
    );
    $rv_ref = scan_deps(@files); # shorthand, with recurse =&gt; 1
</pre>
<p class="Pp">This function scans each file in <span class="Li">@files</span>,
    registering their dependencies into <span class="Li">%rv</span>, and returns
    a reference to the updated <span class="Li">%rv</span>. The meaning of keys
    and values are explained above.</p>
<p class="Pp">If <span class="Li">$recurse</span> is true,
    <span class="Li">&quot;scan_deps&quot;</span> will call itself recursively,
    to perform a breadth-first search on text files (as defined by the -T
    operator) found in <span class="Li">%rv</span>.</p>
<p class="Pp">If the <span class="Li">&quot;\%skip&quot;</span> is specified,
    files that exists as its keys are skipped. This is used internally to avoid
    infinite recursion.</p>
<p class="Pp">If <span class="Li">$compile</span> or
    <span class="Li">$execute</span> is true, runs
    <span class="Li">&quot;files&quot;</span> in either compile-only or normal
    mode, then inspects their <span class="Li">%INC</span> after termination to
    determine additional runtime dependencies.</p>
<p class="Pp">If <span class="Li">$execute</span> is an array reference, passes
    <span class="Li">@$execute</span> as arguments to each file in
    <span class="Li">@files</span> when it is run.</p>
<p class="Pp">If performance of the scanning process is a concern,
    <span class="Li">&quot;cache_file&quot;</span> can be set to a filename. The
    scanning results will be cached and written to the file. This will speed up
    the scanning process on subsequent runs.</p>
<p class="Pp">Additionally, an option
    <span class="Li">&quot;warn_missing&quot;</span> is recognized. If set to
    true, <span class="Li">&quot;scan_deps&quot;</span> issues a warning to
    STDERR for every module file that the scanned code depends but that wasn't
    found. Please note that this may also report numerous false positives. That
    is why by default, the heuristic silently drops all dependencies it cannot
    find.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBscan_deps_runtime_fP"><a class="permalink" href="#_fBscan_deps_runtime_fP"><b>scan_deps_runtime</b></a></h2>
Like <b>scan_deps</b>, but skips the static scanning part.
</section>
<section class="Ss">
<h2 class="Ss" id="_fBscan_line_fP"><a class="permalink" href="#_fBscan_line_fP"><b>scan_line</b></a></h2>
<span class="Li"></span>
<pre>
    @modules = scan_line($line);
</pre>
<p class="Pp">Splits a line into chunks (currently with the semicolon
    characters), and return the union of
    <span class="Li">&quot;scan_chunk&quot;</span> calls of them.</p>
<p class="Pp">If the line is <span class="Li">&quot;__END__&quot;</span> or
    <span class="Li">&quot;__DATA__&quot;</span>, a single
    <span class="Li">&quot;__END__&quot;</span> element is returned to signify
    the end of the program.</p>
<p class="Pp">Similarly, it returns a single
    <span class="Li">&quot;__POD__&quot;</span> if the line matches
    <span class="Li">&quot;/^=\w/&quot;</span>; the caller is responsible for
    skipping appropriate number of lines until
    <span class="Li">&quot;=cut&quot;</span>, before calling
    <span class="Li">&quot;scan_line&quot;</span> again.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBscan_chunk_fP"><a class="permalink" href="#_fBscan_chunk_fP"><b>scan_chunk</b></a></h2>
<span class="Li"></span>
<pre>
    $module = scan_chunk($chunk);
    @modules = scan_chunk($chunk);
</pre>
<p class="Pp">Apply various heuristics to <span class="Li">$chunk</span> to find
    and return the module name(s) it contains. In scalar context, returns only
    the first module or <span class="Li">&quot;undef&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBadd_deps_fP"><a class="permalink" href="#_fBadd_deps_fP"><b>add_deps</b></a></h2>
<span class="Li"></span>
<pre>
    $rv_ref = add_deps( rv =&gt; \%rv, modules =&gt; \@modules );
    $rv_ref = add_deps( @modules ); # shorthand, without rv
</pre>
<p class="Pp">Resolves a list of module names to its actual on-disk location, by
    finding in <span class="Li">@INC</span> and
    <span class="Li">@Module::ScanDeps::IncludeLibs</span>; modules that cannot
    be found are skipped.</p>
<p class="Pp">This function populates the <span class="Li">%rv</span> hash with
    module/filename pairs, and returns a reference to it.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_fBpath_to_inc_name_fP"><a class="permalink" href="#_fBpath_to_inc_name_fP"><b>path_to_inc_name</b></a></h2>
<span class="Li"></span>
<pre>
    $perl_name = path_to_inc_name($path, $warn)
</pre>
<p class="Pp">Assumes <span class="Li">$path</span> refers to a perl file and
    does it's best to return the name as it would appear in
    <span class="Li">%INC</span>. Returns undef if no match was found and a
    prints a warning to STDERR if <span class="Li">$warn</span> is true.</p>
<p class="Pp">E.g. if <span class="Li">$path</span> =
    perl/site/lib/Module/ScanDeps.pm then <span class="Li">$perl_name</span>
    will be Module/ScanDeps.pm.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_f(CB@Module::ScanDeps::IncludeLibs_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(CB@Module::ScanDeps::IncludeLibs_fP_fB_fP"><b></b><b>@Module::ScanDeps::IncludeLibs</b><b></b></a></h2>
You can set this global variable to specify additional directories in which to
  search modules without modifying <span class="Li">@INC</span> itself.
</section>
<section class="Ss">
<h2 class="Ss" id="_fB_fP_f(CB$Module::ScanDeps::ScanFileRE_fP_fB_fP"><a class="permalink" href="#_fB_fP_f(CB$Module::ScanDeps::ScanFileRE_fP_fB_fP"><b></b><b>$Module::ScanDeps::ScanFileRE</b><b></b></a></h2>
You can set this global variable to specify a regular expression to identify
  what files to scan. By default it includes all files of the following types:
  .pm, .pl, .t and .al. Additionally, all files without a suffix are considered.
<p class="Pp">For instance, if you want to scan all files then use the
    following:</p>
<p class="Pp"><span class="Li">&quot;$Module::ScanDeps::ScanFileRE =
    qr/./&quot;</span></p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
This module intentionally ignores the <b>BSDPAN</b> hack on FreeBSD -- the
  additional directory is removed from <span class="Li">@INC</span> altogether.
<p class="Pp">The static-scanning heuristic is not likely to be 100% accurate,
    especially on modules that dynamically load other modules.</p>
<p class="Pp">Chunks that span multiple lines are not handled correctly. For
    example, this one works:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use base 'Foo::Bar';
</pre>
<p class="Pp">But this one does not:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use base
        'Foo::Bar';
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
scandeps.pl is a bundled utility that writes
  <span class="Li">&quot;PREREQ_PM&quot;</span> section for a number of files.
<p class="Pp">An application of <b>Module::ScanDeps</b> is to generate
    executables from scripts that contains prerequisite modules; this module
    supports two such projects, PAR and App::Packer. Please see their respective
    documentations on CPAN for further information.</p>
<p class="Pp">Other modules which accomplish the same goal with different
    approach: Module::ExtractUse, Perl::PrereqScanner,
    Perl::PrereqScanner::Lite, Perl::PrereqScanner::NotQuiteLite.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Audrey Tang &lt;cpan@audreyt.org&gt;
<p class="Pp">To a lesser degree: Steffen Mueller &lt;smueller@cpan.org&gt;</p>
<p class="Pp">Parts of heuristics were deduced from:</p>
<ul class="Bl-bullet">
  <li><b>PerlApp</b> by ActiveState Tools Corp
      &lt;http://www.activestate.com/&gt;</li>
  <li><b>Perl2Exe</b> by IndigoStar, Inc &lt;http://www.indigostar.com/&gt;</li>
</ul>
<p class="Pp">The <b>scan_deps_runtime</b> function is contributed by Edward S.
    Peschko.</p>
<p class="Pp">You can write to the mailing list at &lt;par@perl.org&gt;, or send
    an empty mail to &lt;par-subscribe@perl.org&gt; to participate in the
    discussion.</p>
<p class="Pp">Please submit bug reports to
    &lt;bug-Module-ScanDeps@rt.cpan.org&gt;.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright 2002-2008 by Audrey Tang &lt;cpan@audreyt.org&gt;; 2005-2010 by
  Steffen Mueller &lt;smueller@cpan.org&gt;.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">See &lt;http://www.perl.com/perl/misc/Artistic.html&gt;</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2019-01-15</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
