<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::RequestRec(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::RequestRec(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">install::TempContent::Objects::mod_perl-2.0.9::docs::api::Apache2::RequestRec(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Apache2::RequestRec - Perl API for Apache request record accessors
</section>
<section class="Sh">
<h1 class="Sh" id="Synopsis"><a class="permalink" href="#Synopsis">Synopsis</a></h1>
<span class="Li"></span>
<pre>
  use Apache2::RequestRec ();
  
  # set supported by the handler HTTP methods
  $allowed = $r-&gt;allowed();
  
  # auth type
  $auth_type = $r-&gt;ap_auth_type();
  
  # QUERY_STRING
  $args = $r-&gt;args();
  
  # non-parsed-headers handler
  $status = $r-&gt;assbackwards();
  
  # how many bytes were sent
  $bytes_sent = $r-&gt;bytes_sent();
  
  # client connection record
  $c = $r-&gt;connection();
  
  # &quot;Content-Encoding&quot; HTTP response header
  $r-&gt;content_encoding(&quot;gzip&quot;);
  
  # the languages of the content
  $languages = $r-&gt;content_languages();
  
  # &quot;Content-Encoding&quot; HTTP response header
  $r-&gt;content_type('text/plain');
  
  # special response headers table
  $err_headers_out = $r-&gt;err_headers_out();
  
  # request mapped filename
  $filename = $r-&gt;filename();
  
  # request finfo
  $finfo = $r-&gt;finfo();
  
  # 'SetHandler perl-script' equivalent
  $r-&gt;handler('perl-script');
  
  # was it a HEAD request?
  $status = $r-&gt;header_only();
  
  # request input headers table
  $headers_in = $r-&gt;headers_in();
  
  # request output headers table
  $headers_out = $r-&gt;headers_out();
  
  # hostname
  $hostname = $r-&gt;hostname();
  
  # input filters stack
  $input_filters = $r-&gt;input_filters();
  
  # get the main request obj in a sub-request
  $main_r = $r-&gt;main();
  
  # what's the current request (GET/POST/etc)?
  $method = $r-&gt;method();
  
  # what's the current method number?
  $methnum = $r-&gt;method_number();
  
  # current resource last modified time
  $mtime = $r-&gt;mtime();
  
  # next request object (in redirect)
  $next_r = $r-&gt;next();
  
  # there is no local copy
  $r-&gt;no_local_copy();
  
  # Apache ascii notes table
  $notes = $r-&gt;notes();
  
  # output filters stack
  $output_filters = $r-&gt;output_filters();
  
  # PATH_INFO
  $path_info = $r-&gt;path_info();
  
  # used in configuration directives modules
  $per_dir_config = $r-&gt;per_dir_config();
  
  # pool with life span of the current request
  $p = $r-&gt;pool();
  
  # previous request object in the internal redirect
  $prev_r = $r-&gt;prev();
  
  # connection level input filters stack
  $proto_input_filters = $r-&gt;proto_input_filters();
  
  # HTTP protocol version number
  $proto_num = $r-&gt;proto_num();
  
  # connection level output filters stack
  $proto_output_filters = $r-&gt;proto_output_filters();
  
  # the protocol, the client speaks: &quot;HTTP/1.0&quot;, &quot;HTTP/1.1&quot;, etc.
  $protocol = $r-&gt;protocol();
  
  # is it a proxy request
  $status = $r-&gt;proxyreq($val);
  
  # Time when the request started
  $request_time = $r-&gt;request_time();
  
  # server object
  $s = $r-&gt;server();
  
  # response status
  $status = $r-&gt;status();
  
  # response status line
  $status_line = $r-&gt;status_line();
  
  # manipulate %ENV of the subprocess
  $r-&gt;subprocess_env;
  $r-&gt;subprocess_env($key =&gt; $val);
  
  # first HTTP request header
  $request = $r-&gt;the_request();
  
  # the URI without any parsing performed
  $unparsed_uri = $r-&gt;unparsed_uri();
  
  # The path portion of the URI
  $uri = $r-&gt;uri();
  
  # auth username
  $user = $r-&gt;user();
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="Description"><a class="permalink" href="#Description">Description</a></h1>
<span class="Li">&quot;Apache2::RequestRec&quot;</span> provides the Perl API
  for Apache request_rec object.
<p class="Pp">The following packages extend the
    <span class="Li">&quot;Apache2::RequestRec&quot;</span> functionality:
    <span class="Li">&quot;Apache2::Access&quot;</span>,
    <span class="Li">&quot;Apache2::Log&quot;</span>,
    <span class="Li">&quot;Apache2::RequestIO&quot;</span>,
    <span class="Li">&quot;Apache2::RequestUtil&quot;</span>,
    <span class="Li">&quot;Apache2::Response&quot;</span>,
    <span class="Li">&quot;Apache2::SubRequest&quot;</span> and
    <span class="Li">&quot;Apache2::URI&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="API"><a class="permalink" href="#API">API</a></h1>
<span class="Li">&quot;Apache2::RequestRec&quot;</span> provides the following
  functions and/or methods:
<section class="Ss">
<h2 class="Ss" id="_allowed_"><a class="permalink" href="#_allowed_">&quot;allowed&quot;</a></h2>
Get/set the allowed methods bitmask.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $allowed      = $r-&gt;allowed();
  $prev_allowed = $r-&gt;allowed($new_allowed);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_allowed ( bitmask )</dt>
  <dd>Set the bitvector.</dd>
  <dt>ret: $allowed ( bitmask )</dt>
  <dd>returns <span class="Li">$allowed</span>, which is a bitvector of the
      allowed methods.
    <p class="Pp">If the <span class="Li">$new_allowed</span> argument is
        passed, the value before the change is returned.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">A handler must ensure that the request method is one that it is
    capable of handling. Generally modules should
    <span class="Li">&quot;Apache2::DECLINE&quot;</span> any request methods
    they do not handle. Prior to aborting the handler like this the handler
    should set <span class="Li">&quot;$r-&gt;allowed&quot;</span> to the list of
    methods that it is willing to handle. This bitvector is used to construct
    the <span class="Li">&quot;Allow:&quot;</span> header required for
    <span class="Li">&quot;OPTIONS&quot;</span> requests, and
    <span class="Li">&quot;Apache2::Const::HTTP_METHOD_NOT_ALLOWED&quot;</span>
    (405) and
    <span class="Li">&quot;Apache2::Const::HTTP_NOT_IMPLEMENTED&quot;</span>
    (501) status codes.</p>
<p class="Pp">Since the default Apache handler deals with the
    <span class="Li">&quot;OPTIONS&quot;</span> method, all response handlers
    can usually decline to deal with
    <span class="Li">&quot;OPTIONS&quot;</span>. For example if the response
    handler handles only <span class="Li">&quot;GET&quot;</span> and
    <span class="Li">&quot;POST&quot;</span> methods, and not
    <span class="Li">&quot;OPTIONS&quot;</span>, it may want to say:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   use Apache2::Const -compile =&gt; qw(OK DECLINED M_GET M_POST M_OPTIONS);
   if ($r-&gt;method_number == Apache2::Const::M_OPTIONS) {
       $r-&gt;allowed($r-&gt;allowed | (1&lt;&lt;Apache2::Const::M_GET) | (1&lt;&lt;Apache2::Const::M_POST));
       return Apache2::Const::DECLINED;
   }
</pre>
<p class="Pp"><span class="Li">&quot;TRACE&quot;</span> is always allowed,
    modules don't need to set it explicitly.</p>
<p class="Pp">Since the default_handler will always handle a
    <span class="Li">&quot;GET&quot;</span>, a module which does *not* implement
    <span class="Li">&quot;GET&quot;</span> should probably return
    <span class="Li">&quot;Apache2::Const::HTTP_METHOD_NOT_ALLOWED&quot;</span>.
    Unfortunately this means that a script
    <span class="Li">&quot;GET&quot;</span> handler can't be installed by
    mod_actions.</p>
<p class="Pp">For example, if the module can handle only POST method it could
    start with:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   use Apache2::Const -compile =&gt; qw(M_POST HTTP_METHOD_NOT_ALLOWED);
   unless ($r-&gt;method_number == Apache2::Const::M_POST) {
       $r-&gt;allowed($r-&gt;allowed | (1&lt;&lt;Apache2::Const::M_POST));
       return Apache2::Const::HTTP_METHOD_NOT_ALLOWED;
   }
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_ap_auth_type_"><a class="permalink" href="#_ap_auth_type_">&quot;ap_auth_type&quot;</a></h2>
If an authentication check was made, get or set the <i>ap_auth_type</i> slot in
  the request record
<p class="Pp"><span class="Li"></span></p>
<pre>
  $auth_type = $r-&gt;ap_auth_type();
  $r-&gt;ap_auth_type($newval);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $newval (string)</dt>
  <dd>If this argument is passed then a new auth type is assigned. For example:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $r-&gt;auth_type('Basic');
    </pre>
  </dd>
  <dt>ret: $auth_type (string)</dt>
  <dd>If <span class="Li">$newval</span> is passed, nothing is returned.
      Otherwise the current auth type is returned.</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp"><i>ap_auth_type</i> holds the authentication type that has been
    negotiated between the client and server during the actual request.
    Generally, <i>ap_auth_type</i> is populated automatically when you call
    <span class="Li">&quot;$r-&gt;get_basic_auth_pw&quot;</span> so you don't
    really need to worry too much about it, but if you want to roll your own
    authentication mechanism then you will have to populate <i>ap_auth_type</i>
    yourself.</p>
<p class="Pp">Note that <span class="Li">&quot;$r-&gt;ap_auth_type&quot;</span>
    was <span class="Li">&quot;$r-&gt;connection-&gt;auth_type&quot;</span> in
    the mod_perl 1.0 API.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_args_"><a class="permalink" href="#_args_">&quot;args&quot;</a></h2>
Get/set the request QUERY string
<p class="Pp"><span class="Li"></span></p>
<pre>
  $args      = $r-&gt;args();
  $prev_args = $r-&gt;args($new_args);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_args ( string )</dt>
  <dd>Optionally set the new QUERY string</dd>
  <dt>ret: $args ( string )</dt>
  <dd>The current QUERY string
    <p class="Pp">If <span class="Li">$new_args</span> was passed, returns the
        value before the change.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_assbackwards_"><a class="permalink" href="#_assbackwards_">&quot;assbackwards&quot;</a></h2>
When set to a true value, Apache won't send any HTTP response headers allowing
  you to send any headers.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $status      = $r-&gt;assbackwards();
  $prev_status = $r-&gt;assbackwards($newval);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $newval (integer)</dt>
  <dd>assign a new state.</dd>
  <dt>ret: $status (integer)</dt>
  <dd>current state.</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">If you send your own set of headers, which includes the
    <span class="Li">&quot;Keep-Alive&quot;</span> HTTP response header, you
    must make sure to increment the number of requests served over this
    connection (which is normally done by the core connection output filter
    <span class="Li">&quot;ap_http_header_filter&quot;</span>, but skipped when
    <span class="Li">&quot;assbackwards&quot;</span> is enabled).</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r-&gt;connection-&gt;keepalives($r-&gt;connection-&gt;keepalives + 1);
</pre>
<p class="Pp">otherwise code relying on the value of
    <span class="Li">&quot;$r-&gt;connection-&gt;keepalives&quot;</span> may
    malfunction. For example, this counter is used to tell when a new request is
    coming in over the same connection to a filter that wants to parse only HTTP
    headers (like
    <span class="Li">&quot;Apache2::Filter::HTTPHeadersFixup&quot;</span>). Of
    course you will need to set
    <span class="Li">&quot;$r-&gt;connection-&gt;keepalive(1)&quot;</span> ) as
    well.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_bytes_sent_"><a class="permalink" href="#_bytes_sent_">&quot;bytes_sent&quot;</a></h2>
The number of bytes sent to the client, handy for logging, etc.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $bytes_sent = $r-&gt;bytes_sent();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $bytes_sent (integer)</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Though as of this writing in Apache 2.0 it doesn't really do what
    it did in Apache 1.3. It's just set to the size of the response body. The
    issue is that buckets from one request may get buffered and not sent during
    the lifetime of the request, so it's not easy to give a truly accurate count
    of &quot;bytes sent to the network for this response&quot;.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_connection_"><a class="permalink" href="#_connection_">&quot;connection&quot;</a></h2>
Get the client connection record
<p class="Pp"><span class="Li"></span></p>
<pre>
  $c = $r-&gt;connection();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $c ( &quot;Apache2::Connection object&quot; )</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_content_encoding_"><a class="permalink" href="#_content_encoding_">&quot;content_encoding&quot;</a></h2>
Get/set content encoding (the &quot;Content-Encoding&quot; HTTP header). Content
  encodings are string like <i>&quot;gzip&quot;</i> or
  <i>&quot;compress&quot;</i>.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ce      = $r-&gt;content_encoding();
  $prev_ce = $r-&gt;content_encoding($new_ce);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_ce ( string )</dt>
  <dd>If passed, sets the content encoding to a new value. It must be a
      lowercased string.</dd>
  <dt>ret: $ce ( string )</dt>
  <dd>The current content encoding.
    <p class="Pp">If <span class="Li">$new_ce</span> is passed, then the
        previous value is returned.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">For example, here is how to send a gzip'ed response:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  require Compress::Zlib;
  $r-&gt;content_type(&quot;text/plain&quot;);
  $r-&gt;content_encoding(&quot;gzip&quot;);
  $r-&gt;print(Compress::Zlib::memGzip(&quot;some text to be gzipped));
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_content_languages_"><a class="permalink" href="#_content_languages_">&quot;content_languages&quot;</a></h2>
Get/set content languages (the
  <span class="Li">&quot;Content-Language&quot;</span> HTTP header). Content
  languages are string like <i>&quot;en&quot;</i> or <i>&quot;fr&quot;</i>.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $languages = $r-&gt;content_languages();
  $prev_lang = $r-&gt;content_languages($nev_lang);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_lang ( ARRAY ref )</dt>
  <dd>If passed, sets the content languages to new values. It must be an ARRAY
      reference of language names, like <i>&quot;en&quot;</i> or
      <i>&quot;fr&quot;</i></dd>
  <dt>ret: $languages ( ARRAY ref )</dt>
  <dd>The current list of content languages, as an ARRAY reference.
    <p class="Pp">If <span class="Li">$new_lang</span> is passed, then the
        previous value is returned.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_content_type_"><a class="permalink" href="#_content_type_">&quot;content_type&quot;</a></h2>
Get/set the HTTP response <i>Content-type</i> header value.
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $content_type      = $r-&gt;content_type();
  my $prev_content_type = $r-&gt;content_type($new_content_type);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_content_type (MIME type string)</dt>
  <dd>Assign a new HTTP response content-type. It will affect the response only
      if HTTP headers weren't sent yet.</dd>
  <dt>ret: $content_type</dt>
  <dd>The current content-type value.
    <p class="Pp">If <span class="Li">$new_content_type</span> was passed, the
        previous value is returned instead.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">For example, set the
    <span class="Li">&quot;Content-type&quot;</span> header to
    <i>text/plain</i>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r-&gt;content_type('text/plain');
</pre>
<p class="Pp">If you set this header via the
    <span class="Li">&quot;headers_out&quot;</span> table directly, it will be
    ignored by Apache. So do not do that.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_err_headers_out_"><a class="permalink" href="#_err_headers_out_">&quot;err_headers_out&quot;</a></h2>
Get/set MIME response headers, printed even on errors and persist across
  internal redirects.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $err_headers_out = $r-&gt;err_headers_out();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $err_headers_out ( &quot;APR::Table object&quot; )</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">The difference between
    <span class="Li">&quot;headers_out&quot;</span> and
    <span class="Li">&quot;err_headers_out&quot;</span>, is that the latter are
    printed even on error, and persist across internal redirects (so the headers
    printed for <span class="Li">&quot;ErrorDocument&quot;</span> handlers will
    have them).</p>
<p class="Pp">For example, if a handler wants to return a 404 response, but
    nevertheless to set a cookie, it has to be:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r-&gt;err_headers_out-&gt;add('Set-Cookie' =&gt; $cookie);
  return Apache2::Const::NOT_FOUND;
</pre>
<p class="Pp">If the handler does:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r-&gt;headers_out-&gt;add('Set-Cookie' =&gt; $cookie);
  return Apache2::Const::NOT_FOUND;
</pre>
<p class="Pp">the <span class="Li">&quot;Set-Cookie&quot;</span> header won't be
    sent.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_filename_"><a class="permalink" href="#_filename_">&quot;filename&quot;</a></h2>
Get/set the filename on disk corresponding to this response (the result of the
  <i>URI --&gt; filename</i> translation).
<p class="Pp"><span class="Li"></span></p>
<pre>
  $filename      = $r-&gt;filename();
  $prev_filename = $r-&gt;filename($new_filename);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_filename ( string )</dt>
  <dd>new value</dd>
  <dt>ret: $filename ( string )</dt>
  <dd>the current filename, or the previous value if the optional
      <span class="Li">$new_filename</span> argument was passed</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Note that if you change the filename after the
    <span class="Li">&quot;PerlMapToStorageHandler&quot;</span> phase was run
    and expect Apache to serve it, you need to update its
    <span class="Li">&quot;stat&quot;</span> record, like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use Apache2::RequestRec ();
  use APR::Finfo ();
  use APR::Const -compile =&gt; qw(FINFO_NORM);
  $r-&gt;filename($newfile);
  $r-&gt;finfo(APR::Finfo::stat($newfile, APR::Const::FINFO_NORM, $r-&gt;pool));
</pre>
<p class="Pp">if you don't, Apache will still try to use the previously cached
    information about the previously set value of the filename.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_finfo_"><a class="permalink" href="#_finfo_">&quot;finfo&quot;</a></h2>
Get and set the <i>finfo</i> request record member:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $finfo = $r-&gt;finfo();
  $r-&gt;finfo($finfo);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $finfo ( &quot;APR::Finfo object&quot; )</dt>
  <dd></dd>
  <dt>ret: $finfo ( &quot;APR::Finfo object&quot; )</dt>
  <dd>Always returns the current object.
    <p class="Pp">Due to the internal Apache implementation it's not possible to
        have two different objects originating from
        <span class="Li">&quot;$r-&gt;finfo&quot;</span> at the same time.
        Whenever <span class="Li">&quot;$r-&gt;finfo&quot;</span> is updated all
        objects will be updated too to the latest value.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Most of the time, this method is used to get the
    <span class="Li">&quot;finfo&quot;</span> member. The only reason you may
    want to set it is you need to use it before the Apache's default
    map_to_storage phase is called.</p>
<p class="Pp">Examples:</p>
<ul class="Bl-bullet">
  <li>What Apache thinks is the current request filename (post the
      <span class="Li">&quot;PerlMapToStorageHandler&quot;</span> phase):
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  use Apache2::RequestRec ();
  use APR::Finfo ();
  print $r-&gt;finfo-&gt;fname;
    </pre>
  </li>
  <li>Populate the <span class="Li">&quot;finfo&quot;</span> member (normally,
      before the <span class="Li">&quot;PerlMapToStorageHandler&quot;</span>
      phase):
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  use APR::Finfo ();
  use APR::Const -compile =&gt; qw(FINFO_NORM);
  
  my $finfo = APR::Finfo::stat(__FILE__, APR::Const::FINFO_NORM, $r-&gt;pool);
  $r-&gt;finfo($finfo);
    </pre>
  </li>
</ul>
</section>
<section class="Ss">
<h2 class="Ss" id="_handler_"><a class="permalink" href="#_handler_">&quot;handler&quot;</a></h2>
Get/set the equivalent of the <span class="Li">&quot;SetHandler&quot;</span>
  directive.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $handler      = $r-&gt;handler();
  $prev_handler = $r-&gt;handler($new_handler);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_handler ( string )</dt>
  <dd>the new handler.</dd>
  <dt>ret: $handler ( string )</dt>
  <dd>the current handler.
    <p class="Pp">If <span class="Li">$new_handler</span> is passed, the
        previous value is returned.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_header_only_"><a class="permalink" href="#_header_only_">&quot;header_only&quot;</a></h2>
Did the client has asked for headers only? e.g. if the request method was
  <b>HEAD</b>.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $status = $r-&gt;header_only();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $status ( boolean )</dt>
  <dd>Returns true if the client is asking for headers only, false
    otherwise</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_headers_in_"><a class="permalink" href="#_headers_in_">&quot;headers_in&quot;</a></h2>
Get/set the request MIME headers:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $headers_in = $r-&gt;headers_in();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $headers_in ( &quot;APR::Table object&quot; )</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">This table is available starting from the
    <span class="Li">&quot;PerlHeaderParserHandler&quot;</span> phase.</p>
<p class="Pp">For example you can use it to retrieve the cookie value sent by
    the client, in the <span class="Li">&quot;Cookie:&quot;</span> header:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my $cookie = $r-&gt;headers_in-&gt;{Cookie} || '';
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_headers_out_"><a class="permalink" href="#_headers_out_">&quot;headers_out&quot;</a></h2>
Get/set MIME response headers, printed only on 2xx responses.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $headers_out = $r-&gt;headers_out();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $headers_out ( &quot;APR::Table object&quot; )</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">See also <span class="Li">&quot;err_headers_out&quot;</span>,
    which allows to set headers for non-2xx responses and persist across
    internal redirects.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_hostname_"><a class="permalink" href="#_hostname_">&quot;hostname&quot;</a></h2>
Host, as set by full URI or Host:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $hostname = $r-&gt;hostname();
  $prev_hostname = $r-&gt;hostname($new_hostname);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_hostname ( string )</dt>
  <dd>new value</dd>
  <dt>ret: $hostname ( string )</dt>
  <dd>the current hostname, or the previous value if the optional
      <span class="Li">$new_hostname</span> argument was passed</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_input_filters_"><a class="permalink" href="#_input_filters_">&quot;input_filters&quot;</a></h2>
Get/set the first filter in a linked list of request level input filters:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $input_filters      = $r-&gt;input_filters();
  $prev_input_filters = $r-&gt;input_filters($new_input_filters);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_input_filters</dt>
  <dd>Set a new value</dd>
  <dt>ret: $input_filters ( &quot;Apache2::Filter object&quot; )</dt>
  <dd>The first filter in the request level input filters chain.
    <p class="Pp">If <span class="Li">$new_input_filters</span> was passed,
        returns the previous value.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">For example instead of using
    <span class="Li">&quot;$r-&gt;read()&quot;</span> to read the POST data, one
    could use an explicit walk through incoming bucket brigades to get that
    data. The following function <span class="Li">&quot;read_post()&quot;</span>
    does just that (in fact that's what
    <span class="Li">&quot;$r-&gt;read()&quot;</span> does behind the
  scenes):</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use APR::Brigade ();
  use APR::Bucket ();
  use Apache2::Filter ();
  
  use Apache2::Const -compile =&gt; qw(MODE_READBYTES);
  use APR::Const    -compile =&gt; qw(SUCCESS BLOCK_READ);
  
  use constant IOBUFSIZE =&gt; 8192;
  
  sub read_post {
      my $r = shift;
  
      my $bb = APR::Brigade-&gt;new($r-&gt;pool,
                                 $r-&gt;connection-&gt;bucket_alloc);
  
      my $data = '';
      my $seen_eos = 0;
      do {
          $r-&gt;input_filters-&gt;get_brigade($bb, Apache2::Const::MODE_READBYTES,
                                         APR::Const::BLOCK_READ, IOBUFSIZE);
  
          for (my $b = $bb-&gt;first; $b; $b = $bb-&gt;next($b)) {
              if ($b-&gt;is_eos) {
                  $seen_eos++;
                  last;
              }
  
              if ($b-&gt;read(my $buf)) {
                  $data .= $buf;
              }
  
              $b-&gt;remove; # optimization to reuse memory
          }
  
      } while (!$seen_eos);
  
      $bb-&gt;destroy;
  
      return $data;
  }
</pre>
<p class="Pp">As you can see
    <span class="Li">&quot;$r-&gt;input_filters&quot;</span> gives us a pointer
    to the last of the top of the incoming filters stack.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_main_"><a class="permalink" href="#_main_">&quot;main&quot;</a></h2>
Get the main request record
<p class="Pp"><span class="Li"></span></p>
<pre>
  $main_r = $r-&gt;main();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $main_r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd>If the current request is a sub-request, this method returns a blessed
      reference to the main request structure. If the current request is the
      main request, then this method returns
      <span class="Li">&quot;undef&quot;</span>.
    <p class="Pp">To figure out whether you are inside a main request or a
        sub-request/internal redirect, use
        <span class="Li">&quot;$r-&gt;is_initial_req&quot;</span>.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_method_"><a class="permalink" href="#_method_">&quot;method&quot;</a></h2>
Get/set the current request method (e.g.
  <span class="Li">&quot;GET&quot;</span>,
  <span class="Li">&quot;HEAD&quot;</span>,
  <span class="Li">&quot;POST&quot;</span>, etc.):
<p class="Pp"><span class="Li"></span></p>
<pre>
  $method     = $r-&gt;method();
  $pre_method = $r-&gt;method($new_method);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_method ( string )</dt>
  <dd>a new value</dd>
  <dt>ret: $method ( string )</dt>
  <dd>The current method as a string
    <p class="Pp">if <span class="Li">$new_method</span> was passed the previous
        value is returned.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_method_number_"><a class="permalink" href="#_method_number_">&quot;method_number&quot;</a></h2>
Get/set the HTTP method, issued by the client
  (<span class="Li">&quot;Apache2::Const::M_GET&quot;</span>,
  <span class="Li">&quot;Apache2::Const::M_POST&quot;</span>, etc.)
<p class="Pp"><span class="Li"></span></p>
<pre>
  $methnum      = $r-&gt;method_number();
  $prev_methnum = $r-&gt;method_number($new_methnum);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_methnum ( &quot;Apache2::Const :methods constant&quot;
    )</dt>
  <dd>a new value</dd>
  <dt>ret: $methnum ( &quot;Apache2::Const :methods constant&quot; )</dt>
  <dd>The current method as a number
    <p class="Pp">if <span class="Li">$new_methnum</span> was passed the
        previous value is returned.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">See the <span class="Li">&quot;$r-&gt;allowed&quot;</span> entry
    for examples.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_mtime_"><a class="permalink" href="#_mtime_">&quot;mtime&quot;</a></h2>
Last modified time of the requested resource
<p class="Pp"><span class="Li"></span></p>
<pre>
  $mtime      = $r-&gt;mtime();
  $prev_mtime = $r-&gt;mtime($new_mtime);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_mtime (epoch seconds).</dt>
  <dd>a new value</dd>
  <dt>ret: $mtime (epoch seconds).</dt>
  <dd>the current value
    <p class="Pp">if <span class="Li">$new_mtime</span> was passed the previous
        value is returned.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_next_"><a class="permalink" href="#_next_">&quot;next&quot;</a></h2>
Pointer to the redirected request if this is an external redirect
<p class="Pp"><span class="Li"></span></p>
<pre>
  $next_r = $r-&gt;next();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $next_r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd>returns a blessed reference to the next (internal) request structure or
      <span class="Li">&quot;undef&quot;</span> if there is no next
    request.</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_no_local_copy_"><a class="permalink" href="#_no_local_copy_">&quot;no_local_copy&quot;</a></h2>
There is no local copy of this response
<p class="Pp"><span class="Li"></span></p>
<pre>
  $status = $r-&gt;no_local_copy();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $status (integer)</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Used internally in certain sub-requests to prevent sending
    <span class="Li">&quot;Apache2::Const::HTTP_NOT_MODIFIED&quot;</span> for a
    fragment or error documents. For example see the implementation in
    <i>modules/filters/mod_include.c</i>.</p>
<p class="Pp">Also used internally in
    <span class="Li">&quot;$r-&gt;meets_conditions&quot;</span> -- if set to a
    true value, the conditions are always met.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_notes_"><a class="permalink" href="#_notes_">&quot;notes&quot;</a></h2>
Get/set text notes for the duration of this request. These notes can be passed
  from one module to another (not only mod_perl, but modules in any other
  language):
<p class="Pp"><span class="Li"></span></p>
<pre>
  $notes      = $r-&gt;notes();
  $prev_notes = $r-&gt;notes($new_notes);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_notes ( &quot;APR::Table object&quot; )</dt>
  <dd></dd>
  <dt>ret: $notes ( &quot;APR::Table object&quot; )</dt>
  <dd>the current notes table.
    <p class="Pp">if the <span class="Li">$new_notes</span> argument was passed,
        returns the previous value.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">If you want to pass Perl structures, you can use
    <span class="Li">&quot;$r-&gt;pnotes&quot;</span>.</p>
<p class="Pp">Also see <span class="Li">&quot;$c-&gt;notes&quot;</span></p>
</section>
<section class="Ss">
<h2 class="Ss" id="_output_filters_"><a class="permalink" href="#_output_filters_">&quot;output_filters&quot;</a></h2>
Get the first filter in a linked list of request level output filters:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $output_filters      = $r-&gt;output_filters();
  $prev_output_filters = $r-&gt;output_filters($new_output_filters);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_output_filters</dt>
  <dd>Set a new value</dd>
  <dt>ret: $output_filters ( &quot;Apache2::Filter object&quot; )</dt>
  <dd>The first filter in the request level output filters chain.
    <p class="Pp">If <span class="Li">$new_output_filters</span> was passed,
        returns the previous value.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">For example instead of using
    <span class="Li">&quot;$r-&gt;print()&quot;</span> to send the response
    body, one could send the data directly to the first output filter. The
    following function <span class="Li">&quot;send_response_body()&quot;</span>
    does just that:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  use APR::Brigade ();
  use APR::Bucket ();
  use Apache2::Filter ();
  
  sub send_response_body {
      my ($r, $data) = @_;
  
      my $bb = APR::Brigade-&gt;new($r-&gt;pool,
                                 $r-&gt;connection-&gt;bucket_alloc);
  
      my $b = APR::Bucket-&gt;new($bb-&gt;bucket_alloc, $data);
      $bb-&gt;insert_tail($b);
      $r-&gt;output_filters-&gt;fflush($bb);
      $bb-&gt;destroy;
  }
</pre>
<p class="Pp">In fact that's what
    <span class="Li">&quot;$r-&gt;read()&quot;</span> does behind the scenes.
    But it also knows to parse HTTP headers passed together with the data and it
    also implements buffering, which the above function does not.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_path_info_"><a class="permalink" href="#_path_info_">&quot;path_info&quot;</a></h2>
Get/set the <span class="Li">&quot;PATH_INFO&quot;</span>, what is left in the
  path after the <i>URI</i> <i>--&gt; filename</i> translation:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $path_info      = $r-&gt;path_info();
  $prev_path_info = $r-&gt;path_info($path_info);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $path_info ( string )</dt>
  <dd>Set a new value</dd>
  <dt>ret: $path_info ( string )</dt>
  <dd>Return the current value.
    <p class="Pp">If the optional argument <span class="Li">$path_info</span> is
        passed, the previous value is returned.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_per_dir_config_"><a class="permalink" href="#_per_dir_config_">&quot;per_dir_config&quot;</a></h2>
Get the dir config vector:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $per_dir_config = $r-&gt;per_dir_config();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $per_dir_config ( &quot;Apache2::ConfVector object&quot; )</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">For an indepth discussion, refer to the Apache Server
    Configuration Customization in Perl chapter.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_pool_"><a class="permalink" href="#_pool_">&quot;pool&quot;</a></h2>
The pool associated with the request
<p class="Pp"><span class="Li"></span></p>
<pre>
  $p = $r-&gt;pool();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $p ( &quot;APR::Pool object&quot; )</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_prev_"><a class="permalink" href="#_prev_">&quot;prev&quot;</a></h2>
Pointer to the previous request if this is an internal redirect
<p class="Pp"><span class="Li"></span></p>
<pre>
  $prev_r = $r-&gt;prev();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $prev_r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd>a blessed reference to the previous (internal) request structure or
      <span class="Li">&quot;undef&quot;</span> if there is no previous
    request.</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_proto_input_filters_"><a class="permalink" href="#_proto_input_filters_">&quot;proto_input_filters&quot;</a></h2>
Get the first filter in a linked list of protocol level input filters:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $proto_input_filters      = $r-&gt;proto_input_filters();
  $prev_proto_input_filters = $r-&gt;proto_input_filters($new_proto_input_filters);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_proto_input_filters</dt>
  <dd>Set a new value</dd>
  <dt>ret: $proto_input_filters ( &quot;Apache2::Filter object&quot; )</dt>
  <dd>The first filter in the protocol level input filters chain.
    <p class="Pp">If <span class="Li">$new_proto_input_filters</span> was
        passed, returns the previous value.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li">&quot;$r-&gt;proto_input_filters&quot;</span>
    points to the same filter as
    <span class="Li">&quot;$r-&gt;connection-&gt;input_filters&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_proto_num_"><a class="permalink" href="#_proto_num_">&quot;proto_num&quot;</a></h2>
Get current request's HTTP protocol version number
<p class="Pp"><span class="Li"></span></p>
<pre>
  $proto_num = $r-&gt;proto_num();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $proto_num (integer)</dt>
  <dd>current request's HTTP protocol version number, e.g.: HTTP/1.0 == 1000,
      HTTP/1.1 = 1001</dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_proto_output_filters_"><a class="permalink" href="#_proto_output_filters_">&quot;proto_output_filters&quot;</a></h2>
Get the first filter in a linked list of protocol level output filters:
<p class="Pp"><span class="Li"></span></p>
<pre>
  $proto_output_filters      = $r-&gt;proto_output_filters();
  $prev_proto_output_filters = $r-&gt;proto_output_filters($new_proto_output_filters);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_proto_output_filters</dt>
  <dd>Set a new value</dd>
  <dt>ret: $proto_output_filters ( &quot;Apache2::Filter object&quot; )</dt>
  <dd>The first filter in the protocol level output filters chain.
    <p class="Pp">If <span class="Li">$new_proto_output_filters</span> was
        passed, returns the previous value.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp"><span class="Li">&quot;$r-&gt;proto_output_filters&quot;</span>
    points to the same filter as
    <span class="Li">&quot;$r-&gt;connection-&gt;output_filters&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_protocol_"><a class="permalink" href="#_protocol_">&quot;protocol&quot;</a></h2>
Get a string identifying the protocol that the client speaks.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $protocol = $r-&gt;protocol();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $protocl ( string )</dt>
  <dd>Typical values are <span class="Li">&quot;HTTP/1.0&quot;</span> or
      <span class="Li">&quot;HTTP/1.1&quot;</span>.
    <p class="Pp">If the client didn't specify the protocol version, the default
        is <span class="Li">&quot;HTTP/0.9&quot;</span></p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_proxyreq_"><a class="permalink" href="#_proxyreq_">&quot;proxyreq&quot;</a></h2>
Get/set the <i>proxyrec</i> request record member and optionally adjust other
  related fields.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $status = $r-&gt;proxyreq($val);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $val ( integer )</dt>
  <dd>PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE, PROXYREQ_RESPONSE</dd>
  <dt>ret: $status ( integer )</dt>
  <dd>If <span class="Li">$val</span> is defined the <i>proxyrec</i> member will
      be set to that value and previous value will be returned.
    <p class="Pp">If <span class="Li">$val</span> is not passed, and
        <span class="Li">&quot;$r-&gt;proxyreq&quot;</span> is not true, and the
        proxy request is matching the current vhost (scheme, hostname and port),
        the <i>proxyrec</i> member will be set to PROXYREQ_PROXY and that value
        will be returned. In addition
        <span class="Li">&quot;$r-&gt;uri&quot;</span> is set to
        <span class="Li">&quot;$r-&gt;unparsed_uri&quot;</span> and
        <span class="Li">&quot;$r-&gt;filename&quot;</span> is set to
        <span class="Li">&quot;&quot;modperl-proxy:&quot;.$r-&gt;uri&quot;</span>.
        If those conditions aren't true 0 is returned.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">For example to turn a normal request into a proxy request to be
    handled on the same server in the
    <span class="Li">&quot;PerlTransHandler&quot;</span> phase run:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my $real_url = $r-&gt;unparsed_uri;
  $r-&gt;proxyreq(Apache2::Const::PROXYREQ_PROXY);
  $r-&gt;uri($real_url);
  $r-&gt;filename(&quot;proxy:$real_url&quot;);
  $r-&gt;handler('proxy-server');
</pre>
<p class="Pp">Also remember that if you want to turn a proxy request into a
    non-proxy request, it's not enough to call:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r-&gt;proxyreq(Apache2::Const::PROXYREQ_NONE);
</pre>
<p class="Pp">You need to adjust <span class="Li">&quot;$r-&gt;uri&quot;</span>
    and <span class="Li">&quot;$r-&gt;filename&quot;</span> as well if you run
    that code in <span class="Li">&quot;PerlPostReadRequestHandler&quot;</span>
    phase, since if you don't -- <span class="Li">&quot;mod_proxy&quot;</span>'s
    own post_read_request handler will override your settings (as it will run
    after the mod_perl handler).</p>
<p class="Pp">And you may also want to add</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r-&gt;set_handlers(PerlResponseHandler =&gt; []);
</pre>
<p class="Pp">so that any response handlers which match apache directives will
    not run in addition to the mod_proxy content handler.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_request_time_"><a class="permalink" href="#_request_time_">&quot;request_time&quot;</a></h2>
Time when the request started
<p class="Pp"><span class="Li"></span></p>
<pre>
  $request_time = $r-&gt;request_time();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $request_time (epoch seconds).</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_server_"><a class="permalink" href="#_server_">&quot;server&quot;</a></h2>
Get the <span class="Li">&quot;Apache2::Server&quot;</span> object for the
  server the request <span class="Li">$r</span> is running under.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $s = $r-&gt;server();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $s ( &quot;Apache2::ServerRec object&quot; )</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_status_"><a class="permalink" href="#_status_">&quot;status&quot;</a></h2>
Get/set the reply status for the client request.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $status      = $r-&gt;status();
  $prev_status = $r-&gt;status($new_status);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_status ( integer )</dt>
  <dd>If <span class="Li">$new_status</span> is passed the new status is
      assigned.
    <p class="Pp">Normally you would use some
        <span class="Li">&quot;Apache2::Const</span>
        <span class="Li">constant&quot;</span>, e.g.
        <span class="Li">&quot;Apache2::Const::REDIRECT&quot;</span>.</p>
  </dd>
  <dt>ret: $newval ( integer )</dt>
  <dd>The current value.
    <p class="Pp">If <span class="Li">$new_status</span> is passed the old value
        is returned.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">Usually you will set this value indirectly by returning the status
    code as the handler's function result. However, there are rare instances
    when you want to trick Apache into thinking that the module returned an
    <span class="Li">&quot;Apache2::Const::OK&quot;</span> status code, but
    actually send the browser a non-OK status. This may come handy when
    implementing an HTTP proxy handler. The proxy handler needs to send to the
    client, whatever status code the proxied server has returned, while
    returning <span class="Li">&quot;Apache2::Const::OK&quot;</span> to Apache.
    e.g.:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r-&gt;status($some_code);
  return Apache2::Const::OK
</pre>
<p class="Pp">See also <span class="Li">&quot;$r-&gt;status_line&quot;</span>,
    which. if set, overrides
  <span class="Li">&quot;$r-&gt;status&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_status_line_"><a class="permalink" href="#_status_line_">&quot;status_line&quot;</a></h2>
Get/set the response status line. The status line is a string like &quot;200
  Document follows&quot; and it will take precedence over the value specified
  using the <span class="Li">&quot;$r-&gt;status()&quot;</span> described above.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $status_line      = $r-&gt;status_line();
  $prev_status_line = $r-&gt;status_line($new_status_line);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_status_line ( string )</dt>
  <dd></dd>
  <dt>ret: $status_line ( string )</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">When discussing <span class="Li">&quot;$r-&gt;status&quot;</span>
    we have mentioned that sometimes a handler runs to a successful completion,
    but may need to return a different code, which is the case with the proxy
    server. Assuming that the proxy handler forwards to the client whatever
    response the proxied server has sent, it'll usually use
    <span class="Li">&quot;status_line()&quot;</span>, like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r-&gt;status_line($response-&gt;code() . ' ' . $response-&gt;message());
  return Apache2::Const::OK;
</pre>
<p class="Pp">In this example <span class="Li">$response</span> could be for
    example an <span class="Li">&quot;HTTP::Response&quot;</span> object, if
    <span class="Li">&quot;LWP::UserAgent&quot;</span> was used to implement the
    proxy.</p>
<p class="Pp">This method is also handy when you extend the HTTP protocol and
    add new response codes. For example you could invent a new error code and
    tell Apache to use that in the response like so:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r-&gt;status_line(&quot;499 We have been FooBared&quot;);
  return Apache2::Const::OK;
</pre>
<p class="Pp">Here <span class="Li">499</span> is the new response code, and
    <i>We have been FooBared</i> is the custom response message.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_subprocess_env_"><a class="permalink" href="#_subprocess_env_">&quot;subprocess_env&quot;</a></h2>
Get/set the Apache <span class="Li">&quot;subprocess_env&quot;</span> table, or
  optionally set the value of a named entry.
<p class="Pp"><span class="Li"></span></p>
<pre>
               $r-&gt;subprocess_env;
  $env_table = $r-&gt;subprocess_env;
  
         $r-&gt;subprocess_env($key =&gt; $val);
  $val = $r-&gt;subprocess_env($key);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $key ( string )</dt>
  <dd></dd>
  <dt>opt arg2: $val ( string )</dt>
  <dd></dd>
  <dt>ret: &quot;...&quot;</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">When called in VOID context with no arguments, it populate
    <span class="Li">%ENV</span> with special variables (e.g.
    <span class="Li">$ENV{QUERY_STRING}</span>) like mod_cgi does.</p>
<p class="Pp">When called in a non-VOID context with no arguments, it returns an
    <span class="Li">&quot;APR::Table object&quot;</span>.</p>
<p class="Pp">When the <span class="Li">$key</span> argument (string) is passed,
    it returns the corresponding value (if such exists, or
    <span class="Li">&quot;undef&quot;</span>. The following two lines are
    equivalent:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $val = $r-&gt;subprocess_env($key);
  $val = $r-&gt;subprocess_env-&gt;get($key);
</pre>
<p class="Pp">When the <span class="Li">$key</span> and the
    <span class="Li">$val</span> arguments (strings) are passed, the value is
    set. The following two lines are equivalent:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $r-&gt;subprocess_env($key =&gt; $val);
  $r-&gt;subprocess_env-&gt;set($key =&gt; $val);
</pre>
<p class="Pp">The <span class="Li">&quot;subprocess_env&quot;</span>
    <span class="Li">&quot;table&quot;</span> is used by
    <span class="Li">&quot;Apache2::SubProcess&quot;</span>, to pass environment
    variables to externally spawned processes. It's also used by various Apache
    modules, and you should use this table to pass the environment variables.
    For example if in
    <span class="Li">&quot;PerlHeaderParserHandler&quot;</span> you do:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   $r-&gt;subprocess_env(MyLanguage =&gt; &quot;de&quot;);
</pre>
<p class="Pp">you can then deploy
    <span class="Li">&quot;mod_include&quot;</span> and write in <i>.shtml</i>
    document:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   &lt;!--#if expr=&quot;$MyLanguage = en&quot; --&gt;
   English
   &lt;!--#elif expr=&quot;$MyLanguage = de&quot; --&gt;
   Deutsch
   &lt;!--#else --&gt;
   Sorry
   &lt;!--#endif --&gt;
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_the_request_"><a class="permalink" href="#_the_request_">&quot;the_request&quot;</a></h2>
First HTTP request header
<p class="Pp"><span class="Li"></span></p>
<pre>
  $request = $r-&gt;the_request();
  $old_request = $r-&gt;uri($new_request);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_request ( string )</dt>
  <dd></dd>
  <dt>ret: $request ( string )</dt>
  <dd>For example:
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  GET /foo/bar/my_path_info?args=3 HTTP/1.0
    </pre>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_unparsed_uri_"><a class="permalink" href="#_unparsed_uri_">&quot;unparsed_uri&quot;</a></h2>
The URI without any parsing performed
<p class="Pp"><span class="Li"></span></p>
<pre>
  $unparsed_uri = $r-&gt;unparsed_uri();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $unparsed_uri ( string )</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">If for example the request was:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  GET /foo/bar/my_path_info?args=3 HTTP/1.0
</pre>
<p class="Pp"><span class="Li">&quot;$r-&gt;uri&quot;</span> returns:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  /foo/bar/my_path_info
</pre>
<p class="Pp">whereas <span class="Li">&quot;$r-&gt;unparsed_uri&quot;</span>
    returns:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  /foo/bar/my_path_info?args=3
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="_uri_"><a class="permalink" href="#_uri_">&quot;uri&quot;</a></h2>
The path portion of the URI
<p class="Pp"><span class="Li"></span></p>
<pre>
  $uri         = $r-&gt;uri();
  my $prec_uri = $r-&gt;uri($new_uri);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_uri ( string )</dt>
  <dd></dd>
  <dt>ret: $uri ( string )</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">See the example in the
    <span class="Li">&quot;$r-&gt;unparsed_uri&quot;</span> section.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_user_"><a class="permalink" href="#_user_">&quot;user&quot;</a></h2>
Get the user name, if an authentication process was successful. Or set it.
<p class="Pp"><span class="Li"></span></p>
<pre>
  $user      = $r-&gt;user();
  $prev_user = $r-&gt;user($new_user);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $new_user ( string )</dt>
  <dd>Pass <span class="Li">$new_user</span> to set a new value</dd>
  <dt>ret: $user ( string )</dt>
  <dd>The current username if an authentication process was successful.
    <p class="Pp">If <span class="Li">$new_user</span> was passed, the previous
        value is returned.</p>
  </dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">For example, let's print the username passed by the client:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  my ($res, $sent_pw) = $r-&gt;get_basic_auth_pw;
  return $res if $res != Apache2::Const::OK;
  print &quot;User: &quot;, $r-&gt;user;
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="Unsupported_API"><a class="permalink" href="#Unsupported_API">Unsupported
  API</a></h1>
<span class="Li">&quot;Apache2::RequestRec&quot;</span> also provides
  auto-generated Perl interface for a few other methods which aren't tested at
  the moment and therefore their API is a subject to change. These methods will
  be finalized later as a need arises. If you want to rely on any of the
  following methods please contact the the mod_perl development mailing list so
  we can help each other take the steps necessary to shift the method to an
  officially supported API.
<section class="Ss">
<h2 class="Ss" id="_allowed_methods_"><a class="permalink" href="#_allowed_methods_">&quot;allowed_methods&quot;</a></h2>
META: Autogenerated - needs to be reviewed/completed
<p class="Pp">List of allowed methods</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $list = $r-&gt;allowed_methods();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $list ( &quot;Apache2::MethodList object&quot; )</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">META: Apache2::MethodList is not available at the moment</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_allowed_xmethods_"><a class="permalink" href="#_allowed_xmethods_">&quot;allowed_xmethods&quot;</a></h2>
META: Autogenerated - needs to be reviewed/completed
<p class="Pp">Array of extension methods</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $array = $r-&gt;allowed_xmethods();
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>ret: $array ( &quot;APR::ArrayHeader object&quot; )</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
<p class="Pp">META: APR::ArrayHeader is not available at the moment</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_request_config_"><a class="permalink" href="#_request_config_">&quot;request_config&quot;</a></h2>
Config vector containing pointers to request's per-server config structures
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ret = $r-&gt;request_config($newval);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>opt arg1: $newval ( &quot;Apache2::ConfVector object&quot; )</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_used_path_info_"><a class="permalink" href="#_used_path_info_">&quot;used_path_info&quot;</a></h2>
META: Autogenerated - needs to be reviewed/completed
<p class="Pp">Flag for the handler to accept or reject path_info on the current
    request. All modules should respect the AP_REQ_ACCEPT_PATH_INFO and
    AP_REQ_REJECT_PATH_INFO values, while AP_REQ_DEFAULT_PATH_INFO indicates
    they may follow existing conventions. This is set to the user's preference
    upon HOOK_VERY_FIRST of the fixups.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  $ret = $r-&gt;used_path_info($newval);
</pre>
<dl class="Bl-tag">
  <dt>obj: $r ( &quot;Apache2::RequestRec object&quot; )</dt>
  <dd></dd>
  <dt>arg1: $newval (integer)</dt>
  <dd></dd>
  <dt>since: 2.0.00</dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="See_Also"><a class="permalink" href="#See_Also">See
  Also</a></h1>
mod_perl 2.0 documentation.
</section>
<section class="Sh">
<h1 class="Sh" id="Copyright"><a class="permalink" href="#Copyright">Copyright</a></h1>
mod_perl 2.0 and its core modules are copyrighted under The Apache Software
  License, Version 2.0.
</section>
<section class="Sh">
<h1 class="Sh" id="Authors"><a class="permalink" href="#Authors">Authors</a></h1>
The mod_perl development team and numerous contributors.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2015-06-18</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
