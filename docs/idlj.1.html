<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   t
   @(#)idlj.1 1.20 01/03/10 SMI;
   Copyright 2004 Sun Microsystems, Inc. All rights reserved.
   Copyright 2004 Sun Microsystems, Inc. Tous droits riservis.
   -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>idlj(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">idlj(1)</td>
    <td class="head-vol">General Commands Manual</td>
    <td class="head-rtitle">idlj(1)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
idlj - The IDL-to-Java Compiler (RMI-IIOP version)
<p class="Pp"><b>idlj</b> generates Java bindings from a given IDL file.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<b>idlj</b> [ <i>options</i> ] <i>idl-file</i>
<p class="Pp">where <i>idl-file</i> is the name of a file containing Interface
    Definition Language (IDL) definitions. <i>Options</i> may appear in any
    order, but must precede the <i>idl-file</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The IDL-to-Java Compiler generates the Java bindings for a given IDL file. For
  binding details, see the OMG IDL to Java Language Mapping Specification. Some
  previous releases of the IDL-to-Java compiler were named <b>idltojava</b>.
</section>
<section class="Sh">
<h1 class="Sh" id="Emitting_Client_and_Server_Bindings"><a class="permalink" href="#Emitting_Client_and_Server_Bindings">Emitting
  Client and Server Bindings</a></h1>
To generate Java bindings for an IDL file named <b>My.idl</b>:
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj My.idl
</pre>
</div>
<p class="Pp">This generates the client-side bindings and is equivalent to:</p>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj -fclient My.idl
</pre>
</div>
<p class="Pp">The client-side bindings do not include the server-side skeleton.
    If you want to generate the server-side bindings for the interfaces:</p>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj -fserver My.idl
</pre>
</div>
<p class="Pp">Server-side bindings include the client-side bindings plus the
    skeleton, all of which are POA (that is, Inheritance Model) classes. If you
    want to generate both client and server-side bindings, use one of the
    following (equivalent) commands:</p>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj -fclient -fserver My.idl
<br/>
idlj -fall My.idl
</pre>
</div>
<p class="Pp">There are two possible server-side models: the Inneritance Model
    and the Tie Model.</p>
<p class="Pp">The default server-side model is the <b>Portable Servant
    Inheritance</b> <b>Model</b>. Given an interface My defined in
    <b>My.idl</b>, the file <b>MyPOA.java</b> is generated. You must provide the
    implementation for <b>My</b> and it must inherit from <b>MyPOA</b>.</p>
<p class="Pp"><b>MyPOA.java</b> is a stream-based skeleton that extends
    <b>org.omg.PortableServer.Servant</b> and implements the
    <b>InvokeHandler</b> interface and the operations interface associated with
    the IDL interface the skeleton implements.</p>
<p class="Pp">The <b>PortableServer</b> module for the <b>Portable Object
    Adapter (POA)</b> defines the native Servant type. In the Java programming
    language, the <b>Servant</b> type is mapped to the Java
    <b>org.omg.PortableServer.Servant</b> class. It serves as the base class for
    all POA servant implementations and provides a number of methods that may be
    invoked by the application programmer, as well as methods which are invoked
    by the POA itself and may be overridden by the user to control aspects of
    servant behavior.</p>
<p class="Pp">Another option for the Inheritance Model is to use the
    <b>-oldImplBase</b> flag in order to generate server-side bindings that are
    compatible with older version of the Java programming language (prior to
    J2SE 1.4). To generate server-side bindings that are backwards
  compatible:</p>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj -fclient -fserver -oldImplBase My.idl
<br/>
idlj -fall -oldImplBase My.idl
</pre>
</div>
<p class="Pp">Given an interface <b>My</b> defined in <b>My.idl</b>, the file
    <b>_MyImpleBase.java</b> is generated. You must provide the implementation
    for <b>My</b> and it must inherit from <b>_MyImplBase</b>.</p>
<p class="Pp">The other server-side model is called the Tie Model. This is a
    delegation model. Because it is not possible to generate ties and skeletons
    at the same time, they must be generated separately. The following commands
    generate the bindings for the Tie Model:</p>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj -fall My.idl
<br/>
idlj -fallTIE My.idl
</pre>
</div>
<p class="Pp">For the interface <b>My</b>, the second command generates
    <b>MyPOATie.java</b>. The constructor to <b>MyPOATie</b> takes a delegate.
    You must provide the implementation for delegate, but it does not have to
    inherit from any other class, only the interface <b>MyOperations</b>. But to
    use it with the ORB, you must wrap your implementation within
    <b>MyPOATie</b>. For instance:</p>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
MyImpl myImpl = new MyImpl ();
<br/>
My POATie tie = new MyPOATie (myImpl);
<br/>
orb.connect (tie);
</pre>
</div>
<p class="Pp">You might want to use the Tie model instead of the typical
    Inheritance model if your implementation must inherit from some other
    implementation. Java allows any number of interface inheritance, but there
    is only one slot for class inheritance. If you the inheritance model, that
    slot is used up . By using the Tie Model, that slot is freed up for your own
    use. The drawback is that it introduces a level of indirection: one extra
    method call occurs when invoking a method.</p>
<p class="Pp">To generate server-side, Tie model bindings that are compatible
    with older version of the IDL to Java language mapping in versions of J2SE
    before 1.4.</p>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj -oldImplBase -fall My.idl
<br/>
idlj -oldImplBase -fallTIE My.idl
</pre>
</div>
<p class="Pp">For the interface <b>My</b>, this will generate
    <b>My_Tie.java</b>. The constructor to <b>My_Tie</b> takes a <b>impl</b>.
    You must provide the implementation for <b>impl</b>, but it does not have to
    inherit from any other class, only the interface <b>HelloOperations</b>. But
    to use it with the ORB, you must wrap your implementation within
    <b>My_Tie</b>. For instance:</p>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
MyImpl myImpl = new MyImpl ();
<br/>
My_Tie tie = new My_Tie (myImpl);
<br/>
orb.connect (tie);
</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="Specifying_Alternate_Locations_for_Emitted_Files"><a class="permalink" href="#Specifying_Alternate_Locations_for_Emitted_Files">Specifying
  Alternate Locations for Emitted Files</a></h1>
If you want to direct the emitted files to a directory other than the current
  directory, invoke the compiler as:
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj -td /altdir My.idl
</pre>
</div>
<p class="Pp">For the interface <b>My</b>, the bindings will be emitted to
    <b>/altdir/My.java</b>, etc., instead of <b>./My.java.</b></p>
</section>
<section class="Sh">
<h1 class="Sh" id="Specifying_Alternate_Locations_for_Include_Files"><a class="permalink" href="#Specifying_Alternate_Locations_for_Include_Files">Specifying
  Alternate Locations for Include Files</a></h1>
If <b>My.idl</b> included another idl file, <b>MyOther.idl</b>, the compiler
  assumes that <b>MyOther.idl</b> resides in the local directory. If it resides
  in <b>/includes</b>, for example, then you would invoke the compiler with the
  following command:
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj -i /includes My.idl
</pre>
</div>
<p class="Pp">If <b>My.idl</b> also included <b>Another.idl</b> that resided in
    <b>/moreIncludes</b>, for example, then you would invoke the compiler with
    the following command:</p>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj -i /includes -i /moreIncludes My.idl
</pre>
</div>
<p class="Pp">Since this form of include can become irritatingly long, another
    means of indicating to the compiler where to search for included files is
    provided. This technique is similar to the idea of an environment variable.
    Create a file named <b>idl.config</b> in a directory that is listed in your
    CLASSPATH. Inside of <b>idl.config</b>, provide a line with the following
    form:</p>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
includes=/includes;/moreIncludes
</pre>
</div>
<p class="Pp">The compiler will find this file and read in the includes list.
    Note that in this example the separator character between the two
    directories is a semicolon (;). This separator character is platform
    dependent. On NT it is a semicolon, on Solaris it is a colon, etc. For more
    information on includes, read the CLASSPATH documentation.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Emitting_Bindings_for_Include_Files"><a class="permalink" href="#Emitting_Bindings_for_Include_Files">Emitting
  Bindings for Include Files</a></h1>
By default, only those interfaces, structs, etc, that are defined in the idl
  file on the command line have Java bindings generated for them. The types
  defined in included files are not generated. For example, assume the following
  two idl files:
<dl class="Bl-tag">
  <dt><b>My.idl</b></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<div class="Bd-indent">#include &lt;MyOther.idl&gt;
<br/>
interface My
<br/>
{
<br/>
};</div>
<dl class="Bl-tag">
  <dt><b>MyOther.idl</b></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<div class="Bd-indent">interface MyOther
<br/>
{
<br/>
};</div>
<p class="Pp">The following command will only generate the java bindings for
    <b>My</b>:</p>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj My.idl
</pre>
</div>
<p class="Pp">To generate all of the types in <b>My.idl</b> and all of the types
    in the files that <b>My.idl</b> includes (in this example,
    <b>MyOther.idl</b>), use the following command:</p>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj -emitAll My.idl 
</pre>
</div>
<p class="Pp">There is a caveat to the default rule. <b>#include</b> statements
    which appear at global scope are treated as described. These <b>#include</b>
    statements can be thought of as import statements. <b>#include</b>
    statements which appear within some enclosing scope are treated as true
    <b>#include</b> statements, meaning that the code within the included file
    is treated as if it appeared in the original file and, therefore, Java
    bindings are emitted for it. Here is an example:</p>
<dl class="Bl-tag">
  <dt><b>My.idl</b></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<div class="Bd-indent">#include &lt;MyOther.idl&gt;
<br/>
interface My
<br/>
{
 #include &lt;Embedded.idl&gt;
<br/>
};</div>
<dl class="Bl-tag">
  <dt><b>MyOther.idl</b></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<div class="Bd-indent">interface MyOther
<br/>
{
<br/>
};</div>
<dl class="Bl-tag">
  <dt><b>Embedded.idl</b></dt>
  <dd></dd>
</dl>
<p class="Pp"></p>
<div class="Bd-indent">enum E {one, two, three};</div>
<p class="Pp">Running the following command:</p>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj My.idl
</pre>
</div>
<p class="Pp">will generate the following list of Java files:</p>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
</pre>
</div>
<p class="Pp">Notice that <b>MyOther.java</b> was not generated because it is
    defined in an import-like <b>#include</b>. But <b>E.java</b> was generated
    because it was defined in a true <b>#include</b>. Also notice that since
    <b>Embedded.idl</b> was included within the scope of the interface
    <b>My</b>, it appears within the scope of <b>My</b> (that is,in
    <b>MyPackage</b>).</p>
<p class="Pp">If the <b>-emitAll</b> flag had been used in the previous example,
    then all types in all included files would be emitted.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Inserting_Package_Prefixes"><a class="permalink" href="#Inserting_Package_Prefixes">Inserting
  Package Prefixes</a></h1>
Suppose that you work for a company named ABC that has constructed the following
  IDL file:
<dl class="Bl-tag">
  <dt><b>Widgets. idl</b></dt>
  <dd>module Widgets
    <br/>
    {
     interface W1 {...};
     interface W2 {...};
    <br/>
    };</dd>
</dl>
<p class="Pp">Running this file through the IDL-to-Java compiler will place the
    Java bindings for W1 and W2 within the package Widgets. But there is an
    industry convention that states that a company's packages should reside
    within a package named <b>com.&lt;company</b>name&gt;<b>.</b> The
    <b>Widgets</b> package is not good enough. To follow convention, it should
    be <b>com.abc.Widgets</b>. To place this package prefix onto the
    <b>Widgets</b> module, execute the following:</p>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj -pkgPrefix Widgets com.abc Widgets.idl
</pre>
</div>
<p class="Pp">If you have an IDL file which includes <b>Widgets.idl</b>, the
    <b>-pkgPrefix</b> flag must appear in that command also. If it does not,
    then your IDL file will be looking for a <b>Widgets</b> package rather than
    a <b>com.abc.Widgets</b> package.</p>
<p class="Pp">If you have a number of these packages that require prefixes, it
    might be easier to place them into the <b>idl.config</b> file described
    above. Each package prefix line should be of the form:</p>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
PkgPrefix.&lt;type&gt;=&lt;prefix&gt;
</pre>
</div>
<p class="Pp">So the line for the above example would be:</p>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
PkgPrefix.Widgets=com.abc
</pre>
</div>
<p class="Pp">The use of this options does not affect the Repository ID.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Defining_Symbols_Before_Compilation"><a class="permalink" href="#Defining_Symbols_Before_Compilation">Defining
  Symbols Before Compilation</a></h1>
You may need to define a symbol for compilation that is not defined within the
  IDL file, perhaps to include debugging code in the bindings. The command
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj -d MYDEF My.idl
</pre>
</div>
<p class="Pp">is the equivalent of putting the line <b>#define</b> <b>MYDEF</b>
    inside <b>My.idl</b>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Preserving_Pre_Existing_Bindings"><a class="permalink" href="#Preserving_Pre_Existing_Bindings">Preserving
  Pre-Existing Bindings</a></h1>
If the Java binding files already exist, the <b>-keep</b> flag will keep the
  compiler from overwriting them. The default is to generate all files without
  considering if they already exist. If you've customized those files (which you
  should not do unless you are very comfortable with their contents), then the
  <b>-keep</b> option is very useful. The command
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj -keep My.idl
</pre>
</div>
<p class="Pp">emit all client-side bindings that do not already exist.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Viewing_Progress_of_Compilation"><a class="permalink" href="#Viewing_Progress_of_Compilation">Viewing
  Progress of Compilation</a></h1>
The IDL-to-Java compiler will generate status messages as it progresses through
  its phases of execution. Use the <b>-v</b> option to activate this
  &quot;verbose&quot; mode:
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj -v My.idl
</pre>
</div>
<p class="Pp">By default the compiler does not operate in verbose mode.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Displaying_Version_Information"><a class="permalink" href="#Displaying_Version_Information">Displaying
  Version Information</a></h1>
To display the build version of the IDL-to-Java compiler, specify the
  <b>-version</b> option on the command-line:
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
idlj -version 
</pre>
</div>
<p class="Pp">Version information also appears within the bindings generated by
    the compiler. Any additional options appearing on the command-line are
    ignored.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt><b>-d</b><i> symbol</i></dt>
  <dd>This is equivalent to the following line in an IDL file:</dd>
</dl>
<p class="Pp"></p>
<div class="Bd-indent"><b></b>
<pre>
#define symbol
</pre>
</div>
<dl class="Bl-tag">
  <dt><b>-emitAll</b></dt>
  <dd>Emit all types, including those found in <b>#include</b> files.</dd>
  <dt><b>-fside</b></dt>
  <dd>Defines what bindings to emit. <b>side</b> is one of <b>client,</b>
      <b>server,</b> <b>serverTIE,</b> <b>all,</b> or <b>allTIE.</b>The
      <b>-fserverTIE</b>and <b>-fallTIE</b> options cause delegate model
      skeletons to be emitted. Assumes <b>-fclient</b> if the flag is not
      specified.</dd>
  <dt><b>-i</b><i> include-path</i></dt>
  <dd>By default, the current directory is scanned for included files. This
      option adds another directory.</dd>
  <dt><b>-keep</b></dt>
  <dd>If a file to be generated already exists, do not overwrite it. By default
      it is overwritten.</dd>
  <dt><b>-noWarn</b></dt>
  <dd>Supresses warning messages.</dd>
  <dt><b>-oldImplBase</b></dt>
  <dd>Generates skeletons compatible with old (pre-1.4) JDK ORBs. By default,
      the POA Inheritance Model server-side bindings are generated. This option
      provides backward-compatibility with older versions of the Java
      programming language by generating server-side bindings that are
      <b>ImplBase</b> Inheritance Model classes.</dd>
  <dt><b>-pkgPrefix</b><i> type prefix</i></dt>
  <dd>Wherever <b>type</b> is encountered at file scope, prefix the generated
      Java package name with <b>prefix</b> for all files generated for that
      type. The <b>type</b> is the simple name of either a top-level module, or
      an IDL type defined outside of any module.</dd>
  <dt><b>-pkgTranslate</b><i> type package</i></dt>
  <dd>Wherever the type or module name <b>type</b> is encountered, replace it in
      the with <b>package</b> for all files in the generated Java package. Note
      that <b>pkgPrefix</b> changes are made first. <b>type</b> is the simple
      name of either a top-level module, or an IDL type defined outside of any
      module, and must match the full package name exactly. Also note that the
      following package names cannot be translated:</dd>
</dl>
<p class="Pp"></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&#x2022; org</dt>
  <dd></dd>
  <dt>&#x2022; org.omg or any subpackages of org.omg</dt>
  <dd></dd>
</dl>
<p class="Pp">Any attempt to translate these packages will result in
    uncompilable code, and the use of these packages as the first argument after
    <b>-pkgTranslate</b> will be treated as an error.</p>
</div>
<dl class="Bl-tag">
  <dt><b>-skeletonName</b><i> xxx%yyy</i></dt>
  <dd>Use <b>xxx%yyy</b> as the pattern for naming the skeleton. The defaults
      are</dd>
</dl>
<p class="Pp"></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&#x2022; %POA for the POA base class (</dt>
  <dd><b>-fserver</b> or <b>-fall</b>)</dd>
  <dt>&#x2022; %ImplBase for the oldImplBase class (</dt>
  <dd><b>-oldImplBase</b> and ( <b>-fserver</b> or <b>-fall</b>))</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>-td</b><i> dir</i></dt>
  <dd>Use <b>dir</b> for the output directory instead of the current
    directory.</dd>
  <dt><b>-tieName</b><i> xxx%yyy</i></dt>
  <dd>Name the tie according to the pattern. The defaults are:</dd>
</dl>
<p class="Pp"></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>&#x2022; %POATie for the POA tie base class (</dt>
  <dd><b>-fserverTie</b> or <b>-fallTie</b>)</dd>
  <dt>&#x2022; %_Tie for the</dt>
  <dd><b>oldImplBase</b> tie class ( <b>-oldImplBase</b> and (
      <b>-fserverTie</b> or <b>-fallTie</b>))</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><b>-nowarn</b>,<b>-verbose</b></dt>
  <dd>Verbose mode.</dd>
  <dt><b>-version</b></dt>
  <dd>Display version information and terminate.</dd>
</dl>
<p class="Pp">See the Description section for more option information.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="Restrictions"><a class="permalink" href="#Restrictions">Restrictions</a></h1>
<dl class="Bl-tag">
  <dt>&#x2022; Escaped identifiers in the global scope may not have the</dt>
  <dd>same spelling as IDL primitive types, <b>Object</b>, or <b>ValueBase</b>.
      This is because the symbol table is pre-loaded with these identifiers;
      allowing them to be redefined would overwrite their original definitions.
      (Possible permanent restriction).</dd>
  <dt>&#x2022; The fixed IDL type is not supported.</dt>
  <dd></dd>
</dl>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">10 March 2001</td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
