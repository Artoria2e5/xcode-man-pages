<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>JSON_XS(1)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">JSON_XS(1)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">JSON_XS(1)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
json_xs - JSON::XS commandline utility
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
   json_xs [-v] [-f inputformat] [-t outputformat]
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<i>json_xs</i> converts between some input and output formats (one of them is
  JSON).
<p class="Pp">The default input format is
    <span class="Li">&quot;json&quot;</span> and the default output format is
    <span class="Li">&quot;json-pretty&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<dl class="Bl-tag">
  <dt>-v</dt>
  <dd>Be slightly more verbose.</dd>
  <dt>-f fromformat</dt>
  <dd>Read a file in the given format from STDIN.
    <p class="Pp"><span class="Li">&quot;fromformat&quot;</span> can be one
      of:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>json - a json text encoded, either utf-8, utf16-be/le, utf32-be/le</dt>
  <dd></dd>
  <dt>cbor - CBOR (RFC 7049, CBOR::XS), a kind of binary JSON</dt>
  <dd></dd>
  <dt>storable - a Storable frozen value</dt>
  <dd></dd>
  <dt>storable-file - a Storable file (Storable has two incompatible
    formats)</dt>
  <dd></dd>
  <dt>bencode - use Convert::Bencode, if available (used by torrent files, among
    others)</dt>
  <dd></dd>
  <dt>clzf - Compress::LZF format (requires that module to be installed)</dt>
  <dd></dd>
  <dt>eval - evaluate the given code as (non-utf-8) Perl, basically the reverse
    of &quot;-t dump&quot;</dt>
  <dd></dd>
  <dt>yaml - YAML format (requires that module to be installed)</dt>
  <dd></dd>
  <dt>string - do not attempt to decode the file data</dt>
  <dd></dd>
  <dt>none - nothing is read, creates an &quot;undef&quot; scalar - mainly
    useful with &quot;-e&quot;</dt>
  <dd></dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>-t toformat</dt>
  <dd>Write the file in the given format to STDOUT.
    <p class="Pp"><span class="Li">&quot;toformat&quot;</span> can be one
      of:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>json, json-utf-8 - json, utf-8 encoded</dt>
  <dd></dd>
  <dt>json-pretty - as above, but pretty-printed</dt>
  <dd></dd>
  <dt>json-utf-16le, json-utf-16be - little endian/big endian utf-16</dt>
  <dd></dd>
  <dt>json-utf-32le, json-utf-32be - little endian/big endian utf-32</dt>
  <dd></dd>
  <dt>cbor - CBOR (RFC 7049, CBOR::XS), a kind of binary JSON</dt>
  <dd></dd>
  <dt>cbor-packed - CBOR using extensions to make it smaller</dt>
  <dd></dd>
  <dt>storable - a Storable frozen value in network format</dt>
  <dd></dd>
  <dt>storable-file - a Storable file in network format (Storable has two
    incompatible formats)</dt>
  <dd></dd>
  <dt>bencode - use Convert::Bencode, if available (used by torrent files, among
    others)</dt>
  <dd></dd>
  <dt>clzf - Compress::LZF format</dt>
  <dd></dd>
  <dt>yaml - YAML::XS format</dt>
  <dd></dd>
  <dt>dump - Data::Dump</dt>
  <dd></dd>
  <dt>dumper - Data::Dumper</dt>
  <dd></dd>
  <dt>string - writes the data out as if it were a string</dt>
  <dd></dd>
  <dt>none - nothing gets written, mainly useful together with
    &quot;-e&quot;</dt>
  <dd>Note that Data::Dumper doesn't handle self-referential data structures
      correctly - use &quot;dump&quot; instead.</dd>
</dl>
</div>
<div class="Bd-indent"></div>
<dl class="Bl-tag">
  <dt>-e code</dt>
  <dd>Evaluate perl code after reading the data and before writing it out again
      - can be used to filter, create or extract data. The data that has been
      written is in <span class="Li">$_</span>, and whatever is in there is
      written out afterwards.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<span class="Li"></span>
<pre>
   json_xs -t none &lt;isitreally.json
</pre>
<p class="Pp">&quot;JSON Lint&quot; - tries to parse the file
    <i>isitreally.json</i> as JSON - if it is valid JSON, the command outputs
    nothing, otherwise it will print an error message and exit with non-zero
    exit status.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   &lt;src.json json_xs &gt;pretty.json
</pre>
<p class="Pp">Prettify the JSON file <i>src.json</i> to <i>dst.json</i>.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   json_xs -f storable-file &lt;file
</pre>
<p class="Pp">Read the serialised Storable file <i>file</i> and print a
    human-readable JSON version of it to STDOUT.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   json_xs -f storable-file -t yaml &lt;file
</pre>
<p class="Pp">Same as above, but write YAML instead (not using JSON at all
  :)</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   json_xs -f none -e '$_ = [1, 2, 3]'
</pre>
<p class="Pp">Dump the perl array as UTF-8 encoded JSON text.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   &lt;torrentfile json_xs -f bencode -e '$_ = join &quot;\n&quot;, map @$_, @{$_-&gt;{&quot;announce-list&quot;}}' -t string
</pre>
<p class="Pp">Print the tracker list inside a torrent file.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   lwp-request http://cpantesters.perl.org/show/JSON-XS.json | json_xs
</pre>
<p class="Pp">Fetch the cpan-testers result summary
    <span class="Li">&quot;JSON::XS&quot;</span> and pretty-print it.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Copyright (C) 2008 Marc Lehmann &lt;json@schmorp.de&gt;
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-11-15</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
