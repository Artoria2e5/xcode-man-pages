<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>XML::LibXML::Text(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">XML::LibXML::Text(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">XML::LibXML::Text(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
XML::LibXML::Text - XML::LibXML Class for Text Nodes
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use XML::LibXML;
  # Only methods specific to Text nodes are listed here,
  # see XML::LibXML::Node manpage for other methods

  $text = XML::LibXML::Text-&gt;new( $content );
  $nodedata = $text-&gt;data;
  $text-&gt;setData( $text_content );
  $text-&gt;substringData($offset, $length);
  $text-&gt;appendData( $somedata );
  $text-&gt;insertData($offset, $string);
  $text-&gt;deleteData($offset, $length);
  $text-&gt;deleteDataString($remstring, $all);
  $text-&gt;replaceData($offset, $length, $string);
  $text-&gt;replaceDataString($old, $new, $flag);
  $text-&gt;replaceDataRegEx( $search_cond, $replace_cond, $reflags );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Unlike the DOM specification, XML::LibXML implements the text node as the base
  class of all character data node. Therefore there exists no CharacterData
  class. This allows one to apply methods of text nodes also to Comments and
  CDATA-sections.
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
The class inherits from XML::LibXML::Node. The documentation for Inherited
  methods is not listed here.
<p class="Pp">Many functions listed here are extensively documented in the DOM
    Level 3 specification (&lt;http://www.w3.org/TR/DOM-Level-3-Core/&gt;).
    Please refer to the specification for extensive documentation.</p>
<dl class="Bl-tag">
  <dt>new</dt>
  <dd><span class="Li"></span>
    <pre>
  $text = XML::LibXML::Text-&gt;new( $content );
    </pre>
    <p class="Pp">The constructor of the class. It creates an unbound text
      node.</p>
  </dd>
  <dt>data</dt>
  <dd><span class="Li"></span>
    <pre>
  $nodedata = $text-&gt;data;
    </pre>
    <p class="Pp">Although there exists the
        <span class="Li">&quot;nodeValue&quot;</span> attribute in the Node
        class, the DOM specification defines data as a separate attribute.
        <span class="Li">&quot;XML::LibXML&quot;</span> implements these two
        attributes not as different attributes, but as aliases, such as
        <span class="Li">&quot;libxml2&quot;</span> does. Therefore</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $text-&gt;data;
    </pre>
    <p class="Pp">and</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $text-&gt;nodeValue;
    </pre>
    <p class="Pp">will have the same result and are not different entities.</p>
  </dd>
  <dt>setData($string)</dt>
  <dd><span class="Li"></span>
    <pre>
  $text-&gt;setData( $text_content );
    </pre>
    <p class="Pp">This function sets or replaces text content to a node. The
        node has to be of the type &quot;text&quot;, &quot;cdata&quot; or
        &quot;comment&quot;.</p>
  </dd>
  <dt>substringData($offset,$length)</dt>
  <dd><span class="Li"></span>
    <pre>
  $text-&gt;substringData($offset, $length);
    </pre>
    <p class="Pp">Extracts a range of data from the node. (DOM Spec) This
        function takes the two parameters <span class="Li">$offset</span> and
        <span class="Li">$length</span> and returns the sub-string, if
        available.</p>
    <p class="Pp">If the node contains no data or
        <span class="Li">$offset</span> refers to an non-existing string index,
        this function will return <i>undef</i>. If
        <span class="Li">$length</span> is out of range
        <span class="Li">&quot;substringData&quot;</span> will return the data
        starting at <span class="Li">$offset</span> instead of causing an
      error.</p>
  </dd>
  <dt>appendData($string)</dt>
  <dd><span class="Li"></span>
    <pre>
  $text-&gt;appendData( $somedata );
    </pre>
    <p class="Pp">Appends a string to the end of the existing data. If the
        current text node contains no data, this function has the same effect as
        <span class="Li">&quot;setData&quot;</span>.</p>
  </dd>
  <dt>insertData($offset,$string)</dt>
  <dd><span class="Li"></span>
    <pre>
  $text-&gt;insertData($offset, $string);
    </pre>
    <p class="Pp">Inserts the parameter <span class="Li">$string</span> at the
        given <span class="Li">$offset</span> of the existing data of the node.
        This operation will not remove existing data, but change the order of
        the existing data.</p>
    <p class="Pp">The <span class="Li">$offset</span> has to be a positive
        value. If <span class="Li">$offset</span> is out of range,
        <span class="Li">&quot;insertData&quot;</span> will have the same
        behaviour as <span class="Li">&quot;appendData&quot;</span>.</p>
  </dd>
  <dt>deleteData($offset, $length)</dt>
  <dd><span class="Li"></span>
    <pre>
  $text-&gt;deleteData($offset, $length);
    </pre>
    <p class="Pp">This method removes a chunk from the existing node data at the
        given offset. The <span class="Li">$length</span> parameter tells, how
        many characters should be removed from the string.</p>
  </dd>
  <dt>deleteDataString($string, [$all])</dt>
  <dd><span class="Li"></span>
    <pre>
  $text-&gt;deleteDataString($remstring, $all);
    </pre>
    <p class="Pp">This method removes a chunk from the existing node data. Since
        the DOM spec is quite unhandy if you already know
        <span class="Li">&quot;which&quot;</span> string to remove from a text
        node, this method allows more perlish code :)</p>
    <p class="Pp">The functions takes two parameters:
        <i></i><i>$string</i><i></i> and optional the <i></i><i>$all</i><i></i>
        flag. If <span class="Li">$all</span> is not set, <i>undef</i> or
        <i>0</i>, <span class="Li">&quot;deleteDataString&quot;</span> will
        remove only the first occurrence of <span class="Li">$string</span>. If
        <span class="Li">$all</span> is
        <i>TRUE</i><span class="Li">&quot;deleteDataString&quot;</span> will
        remove all occurrences of <i></i><i>$string</i><i></i> from the node
        data.</p>
  </dd>
  <dt>replaceData($offset, $length, $string)</dt>
  <dd><span class="Li"></span>
    <pre>
  $text-&gt;replaceData($offset, $length, $string);
    </pre>
    <p class="Pp">The DOM style version to replace node data.</p>
  </dd>
  <dt>replaceDataString($oldstring, $newstring, [$all])</dt>
  <dd><span class="Li"></span>
    <pre>
  $text-&gt;replaceDataString($old, $new, $flag);
    </pre>
    <p class="Pp">The more programmer friendly version of <i>replaceData()</i>
        :)</p>
    <p class="Pp">Instead of giving offsets and length one can specify the exact
        string (<i></i><i>$oldstring</i><i></i>) to be replaced. Additionally
        the <i></i><i>$all</i><i></i> flag allows one to replace all occurrences
        of <i></i><i>$oldstring</i><i></i>.</p>
  </dd>
  <dt>replaceDataRegEx( $search_cond, $replace_cond, $reflags )</dt>
  <dd><span class="Li"></span>
    <pre>
  $text-&gt;replaceDataRegEx( $search_cond, $replace_cond, $reflags );
    </pre>
    <p class="Pp">This method replaces the node's data by a
        <span class="Li">&quot;simple&quot;</span> regular expression. Optional,
        this function allows one to pass some flags that will be added as flag
        to the replace statement.</p>
    <p class="Pp"><i>NOTE:</i> This is a shortcut for</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  my $datastr = $node-&gt;getData();
   $datastr =~ s/somecond/replacement/g; # 'g' is just an example for any flag
   $node-&gt;setData( $datastr );
    </pre>
    <p class="Pp">This function can make things easier to read for simple
        replacements. For more complex variants it is recommended to use the
        code snippet above.</p>
  </dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHORS"><a class="permalink" href="#AUTHORS">AUTHORS</a></h1>
Matt Sergeant, Christian Glahn, Petr Pajas
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
2.0110
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
2001-2007, AxKit.com Ltd.
<p class="Pp">2002-2006, Christian Glahn.</p>
<p class="Pp">2006-2009, Petr Pajas.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-02-01</td>
    <td class="foot-os">perl v5.18.2</td>
  </tr>
</table>
</body>
</html>
