<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PPI::Node(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PPI::Node(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">PPI::Node(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
PPI::Node - Abstract PPI Node class, an Element that can contain other Elements
</section>
<section class="Sh">
<h1 class="Sh" id="INHERITANCE"><a class="permalink" href="#INHERITANCE">INHERITANCE</a></h1>
<span class="Li"></span>
<pre>
  PPI::Node
  isa PPI::Element
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  # Create a typical node (a Document in this case)
  my $Node = PPI::Document-&gt;new;
  
  # Add an element to the node( in this case, a token )
  my $Token = PPI::Token::Word-&gt;new('my');
  $Node-&gt;add_element( $Token );
  
  # Get the elements for the Node
  my @elements = $Node-&gt;children;
  
  # Find all the barewords within a Node
  my $barewords = $Node-&gt;find( 'PPI::Token::Word' );
  
  # Find by more complex criteria
  my $my_tokens = $Node-&gt;find( sub { $_[1]-&gt;content eq 'my' } );
  
  # Remove all the whitespace
  $Node-&gt;prune( 'PPI::Token::Whitespace' );
  
  # Remove by more complex criteria
  $Node-&gt;prune( sub { $_[1]-&gt;content eq 'my' } );
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
The <span class="Li">&quot;PPI::Node&quot;</span> class provides an abstract
  base class for the Element classes that are able to contain other elements
  PPI::Document, PPI::Statement, and PPI::Structure.
<p class="Pp">As well as those listed below, all of the methods that apply to
    PPI::Element objects also apply to
    <span class="Li">&quot;PPI::Node&quot;</span> objects.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="scope"><a class="permalink" href="#scope">scope</a></h2>
The <span class="Li">&quot;scope&quot;</span> method returns true if the node
  represents a lexical scope boundary, or false if it does not.
</section>
<section class="Ss">
<h2 class="Ss" id="add_element_$Element"><a class="permalink" href="#add_element_$Element">add_element
  $Element</a></h2>
The <span class="Li">&quot;add_element&quot;</span> method adds a PPI::Element
  object to the end of a <span class="Li">&quot;PPI::Node&quot;</span>. Because
  Elements maintain links to their parent, an Element can only be added to a
  single Node.
<p class="Pp">Returns true if the PPI::Element was added. Returns
    <span class="Li">&quot;undef&quot;</span> if the Element was already within
    another Node, or the method is not passed a PPI::Element object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="elements"><a class="permalink" href="#elements">elements</a></h2>
The <span class="Li">&quot;elements&quot;</span> method accesses all child
  elements <b>structurally</b> within the
  <span class="Li">&quot;PPI::Node&quot;</span> object. Note that in the base of
  the PPI::Structure classes, this <span class="Li">&quot;DOES&quot;</span>
  include the brace tokens at either end of the structure.
<p class="Pp">Returns a list of zero or more PPI::Element objects.</p>
<p class="Pp">Alternatively, if called in the scalar context, the
    <span class="Li">&quot;elements&quot;</span> method returns a count of the
    number of elements.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="first_element"><a class="permalink" href="#first_element">first_element</a></h2>
The <span class="Li">&quot;first_element&quot;</span> method accesses the first
  element structurally within the <span class="Li">&quot;PPI::Node&quot;</span>
  object. As for the <span class="Li">&quot;elements&quot;</span> method, this
  does include the brace tokens for PPI::Structure objects.
<p class="Pp">Returns a PPI::Element object, or
    <span class="Li">&quot;undef&quot;</span> if for some reason the
    <span class="Li">&quot;PPI::Node&quot;</span> object does not contain any
    elements.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="last_element"><a class="permalink" href="#last_element">last_element</a></h2>
The <span class="Li">&quot;last_element&quot;</span> method accesses the last
  element structurally within the <span class="Li">&quot;PPI::Node&quot;</span>
  object. As for the <span class="Li">&quot;elements&quot;</span> method, this
  does include the brace tokens for PPI::Structure objects.
<p class="Pp">Returns a PPI::Element object, or
    <span class="Li">&quot;undef&quot;</span> if for some reason the
    <span class="Li">&quot;PPI::Node&quot;</span> object does not contain any
    elements.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="children"><a class="permalink" href="#children">children</a></h2>
The <span class="Li">&quot;children&quot;</span> method accesses all child
  elements lexically within the <span class="Li">&quot;PPI::Node&quot;</span>
  object. Note that in the case of the PPI::Structure classes, this does
  <b>NOT</b> include the brace tokens at either end of the structure.
<p class="Pp">Returns a list of zero of more PPI::Element objects.</p>
<p class="Pp">Alternatively, if called in the scalar context, the
    <span class="Li">&quot;children&quot;</span> method returns a count of the
    number of lexical children.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="schildren"><a class="permalink" href="#schildren">schildren</a></h2>
The <span class="Li">&quot;schildren&quot;</span> method is really just a
  convenience, the significant-only variation of the normal
  <span class="Li">&quot;children&quot;</span> method.
<p class="Pp">In list context, returns a list of significant children. In scalar
    context, returns the number of significant children.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="child_$index"><a class="permalink" href="#child_$index">child
  $index</a></h2>
The <span class="Li">&quot;child&quot;</span> method accesses a child
  PPI::Element object by its position within the Node.
<p class="Pp">Returns a PPI::Element object, or
    <span class="Li">&quot;undef&quot;</span> if there is no child element at
    that node.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="schild_$index"><a class="permalink" href="#schild_$index">schild
  $index</a></h2>
The lexical structure of the Perl language ignores 'insignificant' items, such
  as whitespace and comments, while PPI treats these items as valid tokens so
  that it can reassemble the file at any time. Because of this, in many
  situations there is a need to find an Element within a Node by index, only
  counting lexically significant Elements.
<p class="Pp">The <span class="Li">&quot;schild&quot;</span> method returns a
    child Element by index, ignoring insignificant Elements. The index of a
    child Element is specified in the same way as for a normal array, with the
    first Element at index 0, and negative indexes used to identify a &quot;from
    the end&quot; position.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="contains_$Element"><a class="permalink" href="#contains_$Element">contains
  $Element</a></h2>
The <span class="Li">&quot;contains&quot;</span> method is used to determine if
  another PPI::Element object is logically &quot;within&quot; a
  <span class="Li">&quot;PPI::Node&quot;</span>. For the special case of the
  brace tokens at either side of a PPI::Structure object, they are generally
  considered &quot;within&quot; a PPI::Structure object, even if they are not
  actually in the elements for the PPI::Structure.
<p class="Pp">Returns true if the PPI::Element is within us, false if not, or
    <span class="Li">&quot;undef&quot;</span> on error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_$class____e&amp;wanted"><a class="permalink" href="#find_$class____e&amp;wanted">find
  $class | \&amp;wanted</a></h2>
The <span class="Li">&quot;find&quot;</span> method is used to search within a
  code tree for PPI::Element objects that meet a particular condition.
<p class="Pp">To specify the condition, the method can be provided with either a
    simple class name (full or shortened), or a
    <span class="Li">&quot;CODE&quot;</span>/function reference.</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  # Find all single quotes in a Document (which is a Node)
  $Document-&gt;find('PPI::Quote::Single');
  
  # The same thing with a shortened class name
  $Document-&gt;find('Quote::Single');
  
  # Anything more elaborate, we so with the sub
  $Document-&gt;find( sub {
        # At the top level of the file...
        $_[1]-&gt;parent == $_[0]
        and (
                # ...find all comments and POD
                $_[1]-&gt;isa('PPI::Token::Pod')
                or
                $_[1]-&gt;isa('PPI::Token::Comment')
        )
  } );
</pre>
<p class="Pp">The function will be passed two arguments, the top-level
    <span class="Li">&quot;PPI::Node&quot;</span> you are searching in and the
    current PPI::Element that the condition is testing.</p>
<p class="Pp">The anonymous function should return one of three values.
    Returning true indicates a condition match, defined-false
    (<span class="Li">0</span> or <span class="Li">''</span>) indicates
    no-match, and <span class="Li">&quot;undef&quot;</span> indicates no-match
    and no-descend.</p>
<p class="Pp">In the last case, the tree walker will skip over anything below
    the <span class="Li">&quot;undef&quot;</span>-returning element and move on
    to the next element at the same level.</p>
<p class="Pp">To halt the entire search and return
    <span class="Li">&quot;undef&quot;</span> immediately, a condition function
    should throw an exception (i.e.
  <span class="Li">&quot;die&quot;</span>).</p>
<p class="Pp">Note that this same wanted logic is used for all methods
    documented to have a <span class="Li">&quot;\&amp;wanted&quot;</span>
    parameter, as this one does.</p>
<p class="Pp">The <span class="Li">&quot;find&quot;</span> method returns a
    reference to an array of PPI::Element objects that match the condition,
    false (but defined) if no Elements match the condition, or
    <span class="Li">&quot;undef&quot;</span> if you provide a bad condition, or
    an error occurs during the search process.</p>
<p class="Pp">In the case of a bad condition, a warning will be emitted as
  well.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_first_$class____e&amp;wanted"><a class="permalink" href="#find_first_$class____e&amp;wanted">find_first
  $class | \&amp;wanted</a></h2>
If the normal <span class="Li">&quot;find&quot;</span> method is like a grep,
  then <span class="Li">&quot;find_first&quot;</span> is equivalent to the
  Scalar::Util <span class="Li">&quot;first&quot;</span> function.
<p class="Pp">Given an element class or a wanted function, it will search
    depth-first through a tree until it finds something that matches the
    condition, returning the first Element that it encounters.</p>
<p class="Pp">See the <span class="Li">&quot;find&quot;</span> method for
    details on the format of the search condition.</p>
<p class="Pp">Returns the first PPI::Element object that matches the condition,
    false if nothing matches the condition, or
    <span class="Li">&quot;undef&quot;</span> if given an invalid condition, or
    an error occurs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="find_any_$class____e&amp;wanted"><a class="permalink" href="#find_any_$class____e&amp;wanted">find_any
  $class | \&amp;wanted</a></h2>
The <span class="Li">&quot;find_any&quot;</span> method is a short-circuiting
  true/false method that behaves like the normal
  <span class="Li">&quot;find&quot;</span> method, but returns true as soon as
  it finds any Elements that match the search condition.
<p class="Pp">See the <span class="Li">&quot;find&quot;</span> method for
    details on the format of the search condition.</p>
<p class="Pp">Returns true if any Elements that match the condition can be
    found, false if not, or <span class="Li">&quot;undef&quot;</span> if given
    an invalid condition, or an error occurs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="remove_child_$Element"><a class="permalink" href="#remove_child_$Element">remove_child
  $Element</a></h2>
If passed a PPI::Element object that is a direct child of the Node, the
  <span class="Li">&quot;remove_element&quot;</span> method will remove the
  <span class="Li">&quot;Element&quot;</span> intact, along with any of its
  children. As such, this method acts essentially as a 'cut' function.
<p class="Pp">If successful, returns the removed element. Otherwise, returns
    <span class="Li">&quot;undef&quot;</span>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="prune_$class____e&amp;wanted"><a class="permalink" href="#prune_$class____e&amp;wanted">prune
  $class | \&amp;wanted</a></h2>
The <span class="Li">&quot;prune&quot;</span> method is used to strip
  PPI::Element objects out of a code tree. The argument is the same as for the
  <span class="Li">&quot;find&quot;</span> method, either a class name, or an
  anonymous subroutine which returns true/false. Any Element that matches the
  class|wanted will be deleted from the code tree, along with any of its
  children.
<p class="Pp">The <span class="Li">&quot;prune&quot;</span> method returns the
    number of <span class="Li">&quot;Element&quot;</span> objects that matched
    and were removed, <b>non-recursively</b>. This might also be zero, so avoid
    a simple true/false test on the return false of the
    <span class="Li">&quot;prune&quot;</span> method. It returns
    <span class="Li">&quot;undef&quot;</span> on error, which you probably
    <b>should</b> test for.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TO_DO"><a class="permalink" href="#TO_DO">TO DO</a></h1>
- Move as much as possible to PPI::XS
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
See the support section in the main module.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Adam Kennedy &lt;adamk@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright 2001 - 2011 Adam Kennedy.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">The full text of the license can be found in the LICENSE file
    included with this module.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2011-02-25</td>
    <td class="foot-os">perl v5.18.2</td>
  </tr>
</table>
</body>
</html>
