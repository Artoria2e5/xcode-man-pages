<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>IO::Pager::Buffered(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IO::Pager::Buffered(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">IO::Pager::Buffered(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
IO::Pager::Buffered - Pipe deferred output to PAGER if destination is a TTY
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  use IO::Pager::Buffered;
  {
    local $token = IO::Pager::Buffered::open local *STDOUT;
    print &lt;&lt;&quot;  HEREDOC&quot; ;
    ...
    A bunch of text later
    HEREDOC
  }

  {
    # You can also use scalar filehandles...
    my $token = IO::Pager::Buffered::open($FH) or warn($!);
    print $FH &quot;No globs or barewords for us thanks!\n&quot; while 1;
  }

  {
    # ...or an object interface
    my $token = new IO::Pager::Buffered;

    $token-&gt;print(&quot;OO shiny...\n&quot;) while 1;
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
IO::Pager subclasses are designed to programmatically decide whether or not to
  pipe a filehandle's output to a program specified in <i>PAGER</i>; determined
  and set by IO::Pager at runtime if not yet defined.
<p class="Pp">This subclass buffers all output for display until execution
    returns to the parent scope or a manual &quot;flush&quot; occurs.* If this
    is not what you want look at another subclass such as IO::Pager::Unbuffered.
    While probably not common, this may be useful in some cases, such as
    buffering all output to STDOUT while the process occurs so that warnings on
    STDERR are more visible, then displaying the less urgent output from STDOUT
    after. Or, alternately, letting output to STDOUT slide by and defer warnings
    for later perusal.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
Class-specific method specifics below, others are inherited from IO::Pager.
<section class="Ss">
<h2 class="Ss" id="open(___s-1FILEHANDLE_s0__)"><a class="permalink" href="#open(___s-1FILEHANDLE_s0__)">open(
  [FILEHANDLE] )</a></h2>
Instantiate a new IO::Pager to paginate FILEHANDLE if necessary. <i>Assign the
  return value to a scoped variable</i>. Output does not occur until the
  filehandle is &quot;flush&quot;ed or &quot;close&quot;d.
</section>
<section class="Ss">
<h2 class="Ss" id="new(___s-1FILEHANDLE_s0__)"><a class="permalink" href="#new(___s-1FILEHANDLE_s0__)">new(
  [FILEHANDLE] )</a></h2>
Almost identical to open, except that you will get an IO::Handle back if there's
  no TTY to allow for IO::Pager agnostic programming.
</section>
<section class="Ss">
<h2 class="Ss" id="close(__s-1FILEHANDLE_s0_)"><a class="permalink" href="#close(__s-1FILEHANDLE_s0_)">close(
  FILEHANDLE )</a></h2>
Flushes the buffer to the pager and closes the filehandle for writing. Normally,
  when using a lexically or locally scoped variable to hold the token supplied
  by &quot;open&quot;, explicit calls to close are unnecessary. However, if you
  are using IO::Pager::Buffered with an unlocalized STDOUT or STDERR you close
  the filehandle to display the buffered content or wait for global garbage
  cleaning upon program termination.
<p class="Pp">Alternatively, you might prefer to use a non-core filehandle with
    IO::Pager, and call &quot;select&quot; in perlfunc to make it the default
    for output.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="tell(__s-1FILEHANDLE_s0_)"><a class="permalink" href="#tell(__s-1FILEHANDLE_s0_)">tell(
  FILEHANDLE )</a></h2>
Returns the size of the buffer in bytes.
</section>
<section class="Ss">
<h2 class="Ss" id="flush(__s-1FILEHANDLE_s0_)"><a class="permalink" href="#flush(__s-1FILEHANDLE_s0_)">flush(
  FILEHANDLE )</a></h2>
Immediately flushes the contents of the buffer.
<p class="Pp">If the last print did not end with a newline, the text from the
    preceding newline to the end of the buffer will be flushed but is unlikely
    to display until a newline is printed and flushed.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
If you mix buffered and unbuffered operations the output order is unspecified,
  and will probably differ for a TTY vs. a file. See perlfunc.
<p class="Pp"><i>$,</i> is used see perlvar.</p>
<p class="Pp">You probably want to do something with SIGPIPE eg;</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
  eval {
    local $SIG{PIPE} = sub { die };
    local $STDOUT = IO::Pager::open(*STDOUT);

    while (1) {
      # Do something
    }
  }

  # Do something else
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
IO::Pager, IO::Pager::Unbuffered, IO::Pager::Page,
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Jerrad Pierce &lt;jpierce@cpan.org&gt;
<p class="Pp">Florent Angly &lt;florent.angly@gmail.com&gt;</p>
<p class="Pp">This module was inspired by Monte Mitzelfelt's IO::Page 0.02</p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT_AND_LICENSE"><a class="permalink" href="#COPYRIGHT_AND_LICENSE">COPYRIGHT
  AND LICENSE</a></h1>
Copyright (C) 2003-2018 Jerrad Pierce
<ul class="Bl-bullet">
  <li>Thou shalt not claim ownership of unmodified materials.</li>
  <li>Thou shalt not claim whole ownership of modified materials.</li>
  <li>Thou shalt grant the indemnity of the provider of materials.</li>
  <li>Thou shalt use and dispense freely without other restrictions.</li>
</ul>
<p class="Pp">Or, if you prefer:</p>
<p class="Pp">This library is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself, either Perl version 5.0 or,
    at your option, any later version of Perl 5 you may have available.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2018-10-13</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
