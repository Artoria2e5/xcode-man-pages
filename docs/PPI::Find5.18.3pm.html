<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>PPI::Find(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">PPI::Find(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">PPI::Find(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
PPI::Find - Object version of the Element-&gt;find method
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  # Create the Find object
  my $Find = PPI::Find-&gt;new( \&amp;wanted );
  
  # Return all matching Elements as a list
  my @found = $Find-&gt;in( $Document );
  
  # Can we find any matching Elements
  if ( $Find-&gt;any_matches($Document) ) {
        print &quot;Found at least one matching Element&quot;;
  }
  
  # Use the object as an iterator
  $Find-&gt;start($Document) or die &quot;Failed to execute search&quot;;
  while ( my $token = $Find-&gt;match ) {
        ...
  }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
PPI::Find is the primary PDOM searching class in the core PPI package.
<section class="Ss">
<h2 class="Ss" id="History"><a class="permalink" href="#History">History</a></h2>
It became quite obvious during the development of PPI that many of the modules
  that would be built on top of it were going to need large numbers of saved,
  storable or easily creatable search objects that could be reused a number of
  times.
<p class="Pp">Although the internal -&gt;find method provides a basic ability to
    search, it is by no means thorough. PPI::Find attempts to resolve this
    problem.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Structure_and_Style"><a class="permalink" href="#Structure_and_Style">Structure
  and Style</a></h2>
PPI::Find provides a similar API to the popular File::Find::Rule module for file
  searching, but without the ability to assemble queries.
<p class="Pp">The implementation of a separate PPI::Find::Rule sub-class that
    does provide this ability is left as an exercise for the reader.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_&amp;wanted_function"><a class="permalink" href="#The_&amp;wanted_function">The
  &amp;wanted function</a></h2>
At the core of each PPI::Find object is a &quot;wanted&quot; function that is
  passed a number of arguments and returns a value which controls the flow of
  the search.
<p class="Pp">As the search executes, each Element will be passed to the wanted
    function in depth-first order.</p>
<p class="Pp">It will be provided with two arguments. The current Element to
    test as <span class="Li">$_</span>[0], and the top-level Element of the
    search as <span class="Li">$_</span>[1].</p>
<p class="Pp">The &amp;wanted function is expected to return 1 (positive) if the
    Element matches the condition, 0 (false) if it does not, and undef
    (undefined) if the condition does not match, and the Find search should not
    descend to any of the current Element's children.</p>
<p class="Pp">Errors should be reported from the &amp;wanted function via die,
    which will be caught by the Find object and returned as an error.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
<section class="Ss">
<h2 class="Ss" id="new_&amp;wanted"><a class="permalink" href="#new_&amp;wanted">new
  &amp;wanted</a></h2>
The <span class="Li">&quot;new&quot;</span> constructor takes a single argument
  of the &amp;wanted function, as described above and creates a new search.
<p class="Pp">Returns a new PPI::Find object, or
    <span class="Li">&quot;undef&quot;</span> if not passed a CODE
  reference.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="clone"><a class="permalink" href="#clone">clone</a></h2>
The <span class="Li">&quot;clone&quot;</span> method creates another instance of
  the same Find object.
<p class="Pp">The cloning is done safely, so if your existing Find object is in
    the middle of an iteration, the cloned Find object will not also be in the
    iteration and can be safely used independently.</p>
<p class="Pp">Returns a duplicate PPI::Find object.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="in_$Document__,_array_ref_=__1__"><a class="permalink" href="#in_$Document__,_array_ref_=__1__">in
  $Document [, array_ref =&gt; 1 ]</a></h2>
The <span class="Li">&quot;in&quot;</span> method starts and completes a full
  run of the search.
<p class="Pp">It takes as argument a single PPI::Element object which will serve
    as the top of the search process.</p>
<p class="Pp">Returns a list of PPI::Element objects that match the condition
    described by the &amp;wanted function, or the null list on error.</p>
<p class="Pp">You should check the -&gt;errstr method for any errors if you are
    returned the null list, which may also mean simply that no Elements were
    found that matched the condition.</p>
<p class="Pp">Because of this need to explicitly check for errors, an
    alternative return value mechanism is provide. If you pass the
    <span class="Li">&quot;array_ref =&quot;</span> 1&gt; parameter to the
    method, it will return the list of matched Elements as a reference to an
    ARRAY. The method will return false if no elements were matched, or
    <span class="Li">&quot;undef&quot;</span> on error.</p>
<p class="Pp">The -&gt;errstr method can still be used to get the error message
    as normal.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="start_$Element"><a class="permalink" href="#start_$Element">start
  $Element</a></h2>
The <span class="Li">&quot;start&quot;</span> method lets the Find object act as
  an iterator. The method is passed the parent PPI::Element object as for the
  <span class="Li">&quot;in&quot;</span> method, but does not accept any
  parameters.
<p class="Pp">To simplify error handling, the entire search is done at once,
    with the results cached and provided as-requested.</p>
<p class="Pp">Returns true if the search completes, and false on error.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="match"><a class="permalink" href="#match">match</a></h2>
The <span class="Li">&quot;match&quot;</span> method returns the next matching
  Element in the iteration.
<p class="Pp">Returns a PPI::Element object, or
    <span class="Li">&quot;undef&quot;</span> if there are no remaining Elements
    to be returned.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="finish"><a class="permalink" href="#finish">finish</a></h2>
The <span class="Li">&quot;finish&quot;</span> method provides a mechanism to
  end iteration if you wish to stop the iteration prematurely. It resets the
  Find object and allows it to be safely reused.
<p class="Pp">A Find object will be automatically finished when
    <span class="Li">&quot;match&quot;</span> returns false. This means you
    should only need to call <span class="Li">&quot;finnish&quot;</span> when
    you stop iterating early.</p>
<p class="Pp">You may safely call this method even when not iterating and it
    will return without failure.</p>
<p class="Pp">Always returns true</p>
</section>
<section class="Ss">
<h2 class="Ss" id="errstr"><a class="permalink" href="#errstr">errstr</a></h2>
The <span class="Li">&quot;errstr&quot;</span> method returns the error messages
  when a given PPI::Find object fails any action.
<p class="Pp">Returns a string, or <span class="Li">&quot;undef&quot;</span> if
    there is no error.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="TO_DO"><a class="permalink" href="#TO_DO">TO DO</a></h1>
- Implement the PPI::Find::Rule class
</section>
<section class="Sh">
<h1 class="Sh" id="SUPPORT"><a class="permalink" href="#SUPPORT">SUPPORT</a></h1>
See the support section in the main module.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Adam Kennedy &lt;adamk@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
Copyright 2001 - 2011 Adam Kennedy.
<p class="Pp">This program is free software; you can redistribute it and/or
    modify it under the same terms as Perl itself.</p>
<p class="Pp">The full text of the license can be found in the LICENSE file
    included with this module.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2011-02-25</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
