<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Serialiser(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Serialiser(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">Serialiser(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Types::Serialiser - simple data types for common serialisation formats
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module provides some extra datatypes that are used by common serialisation
  formats such as JSON or CBOR. The idea is to have a repository of simple/small
  constants and containers that can be shared by different implementations so
  they become interoperable between each other.
</section>
<section class="Sh">
<h1 class="Sh" id="SIMPLE_SCALAR_CONSTANTS"><a class="permalink" href="#SIMPLE_SCALAR_CONSTANTS">SIMPLE
  SCALAR CONSTANTS</a></h1>
Simple scalar constants are values that are overloaded to act like simple Perl
  values, but have (class) type to differentiate them from normal Perl scalars.
  This is necessary because these have different representations in the
  serialisation formats.
<section class="Ss">
<h2 class="Ss" id="_s-1BOOLEANS_s0_(Types::Serialiser::Boolean_class)"><a class="permalink" href="#_s-1BOOLEANS_s0_(Types::Serialiser::Boolean_class)">BOOLEANS
  (Types::Serialiser::Boolean class)</a></h2>
This type has only two instances, true and false. A natural representation for
  these in Perl is <span class="Li">1</span> and <span class="Li">0</span>, but
  serialisation formats need to be able to differentiate between them and mere
  numbers.
<dl class="Bl-tag">
  <dt>$Types::Serialiser::true, Types::Serialiser::true</dt>
  <dd>This value represents the &quot;true&quot; value. In most contexts is acts
      like the number <span class="Li">1</span>. It is up to you whether you use
      the variable form (<span class="Li">$Types::Serialiser::true</span>) or
      the constant form
      (<span class="Li">&quot;Types::Serialiser::true&quot;</span>).
    <p class="Pp">The constant is represented as a reference to a scalar
        containing <span class="Li">1</span> - implementations are allowed to
        directly test for this.</p>
  </dd>
  <dt>$Types::Serialiser::false, Types::Serialiser::false</dt>
  <dd>This value represents the &quot;false&quot; value. In most contexts is
      acts like the number <span class="Li">0</span>. It is up to you whether
      you use the variable form
      (<span class="Li">$Types::Serialiser::false</span>) or the constant form
      (<span class="Li">&quot;Types::Serialiser::false&quot;</span>).
    <p class="Pp">The constant is represented as a reference to a scalar
        containing <span class="Li">0</span> - implementations are allowed to
        directly test for this.</p>
  </dd>
  <dt>$is_bool = Types::Serialiser::is_bool $value</dt>
  <dd>Returns true iff the <span class="Li">$value</span> is either
      <span class="Li">$Types::Serialiser::true</span> or
      <span class="Li">$Types::Serialiser::false</span>.
    <p class="Pp">For example, you could differentiate between a perl true value
        and a <span class="Li">&quot;Types::Serialiser::true&quot;</span> by
        using this:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
   $value &amp;&amp; Types::Serialiser::is_bool $value
    </pre>
  </dd>
  <dt>$is_true = Types::Serialiser::is_true $value</dt>
  <dd>Returns true iff <span class="Li">$value</span> is
      <span class="Li">$Types::Serialiser::true</span>.</dd>
  <dt>$is_false = Types::Serialiser::is_false $value</dt>
  <dd>Returns false iff <span class="Li">$value</span> is
      <span class="Li">$Types::Serialiser::false</span>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1ERROR_s0_(Types::Serialiser::Error_class)"><a class="permalink" href="#_s-1ERROR_s0_(Types::Serialiser::Error_class)">ERROR
  (Types::Serialiser::Error class)</a></h2>
This class has only a single instance,
  <span class="Li">&quot;error&quot;</span>. It is used to signal an encoding or
  decoding error. In CBOR for example, and object that couldn't be encoded will
  be represented by a CBOR undefined value, which is represented by the error
  value in Perl.
<dl class="Bl-tag">
  <dt>$Types::Serialiser::error, Types::Serialiser::error</dt>
  <dd>This value represents the &quot;error&quot; value. Accessing values of
      this type will throw an exception.
    <p class="Pp">The constant is represented as a reference to a scalar
        containing <span class="Li">&quot;undef&quot;</span> - implementations
        are allowed to directly test for this.</p>
  </dd>
  <dt>$is_error = Types::Serialiser::is_error $value</dt>
  <dd>Returns false iff <span class="Li">$value</span> is
      <span class="Li">$Types::Serialiser::error</span>.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES_FOR_XS_USERS"><a class="permalink" href="#NOTES_FOR_XS_USERS">NOTES
  FOR XS USERS</a></h1>
The recommended way to detect whether a scalar is one of these objects is to
  check whether the stash is the
  <span class="Li">&quot;Types::Serialiser::Boolean&quot;</span> or
  <span class="Li">&quot;Types::Serialiser::Error&quot;</span> stash, and then
  follow the scalar reference to see if it's <span class="Li">1</span> (true),
  <span class="Li">0</span> (false) or <span class="Li">&quot;undef&quot;</span>
  (error).
<p class="Pp">While it is possible to use an isa test, directly comparing stash
    pointers is faster and guaranteed to work.</p>
<p class="Pp">For historical reasons, the
    <span class="Li">&quot;Types::Serialiser::Boolean&quot;</span> stash is just
    an alias for <span class="Li">&quot;JSON::PP::Boolean&quot;</span>. When
    printed, the classname with usually be
    <span class="Li">&quot;JSON::PP::Boolean&quot;</span>, but isa tests and
    stash pointer comparison will normally work correctly (i.e.
    Types::Serialiser::true ISA JSON::PP::Boolean, but also ISA
    Types::Serialiser::Boolean).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="A_GENERIC_OBJECT_SERIALIATION_PROTOCOL"><a class="permalink" href="#A_GENERIC_OBJECT_SERIALIATION_PROTOCOL">A
  GENERIC OBJECT SERIALIATION PROTOCOL</a></h1>
This section explains the object serialisation protocol used by CBOR::XS. It is
  meant to be generic enough to support any kind of generic object serialiser.
<p class="Pp">This protocol is called &quot;the Types::Serialiser object
    serialisation protocol&quot;.</p>
<section class="Ss">
<h2 class="Ss" id="_s-1ENCODING_s0"><a class="permalink" href="#_s-1ENCODING_s0">ENCODING</a></h2>
When the encoder encounters an object that it cannot otherwise encode (for
  example, CBOR::XS can encode a few special types itself, and will first
  attempt to use the special <span class="Li">&quot;TO_CBOR&quot;</span>
  serialisation protocol), it will look up the
  <span class="Li">&quot;FREEZE&quot;</span> method on the object.
<p class="Pp">Note that the <span class="Li">&quot;FREEZE&quot;</span> method
    will normally be called <i>during</i> encoding, and <i>MUST NOT</i> change
    the data structure that is being encoded in any way, or it might cause
    memory corruption or worse.</p>
<p class="Pp">If it exists, it will call it with two arguments: the object to
    serialise, and a constant string that indicates the name of the data model.
    For example CBOR::XS uses <span class="Li">&quot;CBOR&quot;</span>, and the
    JSON and JSON::XS modules (or any other JSON serialiser), would use
    <span class="Li">&quot;JSON&quot;</span> as second argument.</p>
<p class="Pp">The <span class="Li">&quot;FREEZE&quot;</span> method can then
    return zero or more values to identify the object instance. The serialiser
    is then supposed to encode the class name and all of these return values
    (which must be encodable in the format) using the relevant form for Perl
    objects. In CBOR for example, there is a registered tag number for encoded
    perl objects.</p>
<p class="Pp">The values that <span class="Li">&quot;FREEZE&quot;</span> returns
    must be serialisable with the serialiser that calls it. Therefore, it is
    recommended to use simple types such as strings and numbers, and maybe array
    references and hashes (basically, the JSON data model). You can always use a
    more complex format for a specific data model by checking the second
    argument, the data model.</p>
<p class="Pp">The &quot;data model&quot; is not the same as the &quot;data
    format&quot; - the data model indicates what types and kinds of return
    values can be returned from <span class="Li">&quot;FREEZE&quot;</span>. For
    example, in <span class="Li">&quot;CBOR&quot;</span> it is permissible to
    return tagged CBOR values, while JSON does not support these at all, so
    <span class="Li">&quot;JSON&quot;</span> would be a valid (but too limited)
    data model name for <span class="Li">&quot;CBOR::XS&quot;</span>. similarly,
    a serialising format that supports more or less the same data model as JSON
    could use <span class="Li">&quot;JSON&quot;</span> as data model without
    losing anything.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1DECODING_s0"><a class="permalink" href="#_s-1DECODING_s0">DECODING</a></h2>
When the decoder then encounters such an encoded perl object, it should look up
  the <span class="Li">&quot;THAW&quot;</span> method on the stored classname,
  and invoke it with the classname, the constant string to identify the data
  model/data format, and all the return values returned by
  <span class="Li">&quot;FREEZE&quot;</span>.
</section>
<section class="Ss">
<h2 class="Ss" id="_s-1EXAMPLES_s0"><a class="permalink" href="#_s-1EXAMPLES_s0">EXAMPLES</a></h2>
See the <span class="Li">&quot;OBJECT SERIALISATION&quot;</span> section in the
  CBOR::XS manpage for more details, an example implementation, and code
  examples.
<p class="Pp">Here is an example
    <span class="Li">&quot;FREEZE&quot;</span>/<span class="Li">&quot;THAW&quot;</span>
    method pair:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
   sub My::Object::FREEZE {
      my ($self, $model) = @_;

      ($self-&gt;{type}, $self-&gt;{id}, $self-&gt;{variant})
   }

   sub My::Object::THAW {
      my ($class, $model, $type, $id, $variant) = @_;

      $class-&gt;new (type =&gt; $type, id =&gt; $id, variant =&gt; $variant)
   }
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
The use of overload makes this module much heavier than it should be (on my
  system, this module: 4kB RSS, overload: 260kB RSS).
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Currently, JSON::XS and CBOR::XS use these types.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<span class="Li"></span>
<pre>
 Marc Lehmann &lt;schmorp@schmorp.de&gt;
 http://home.schmorp.de/
</pre>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2013-11-30</td>
    <td class="foot-os">perl v5.30.2</td>
  </tr>
</table>
</body>
</html>
