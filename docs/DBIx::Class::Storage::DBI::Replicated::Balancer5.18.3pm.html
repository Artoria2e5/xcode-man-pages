<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>DBIx::Class::Storage::DBI::Replicated::Balancer(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">DBIx::Class::Storage::DBI::Replicated::Balancer(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">DBIx::Class::Storage::DBI::Replicated::Balancer(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
DBIx::Class::Storage::DBI::Replicated::Balancer - A Software Load Balancer
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
This role is used internally by DBIx::Class::Storage::DBI::Replicated.
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
Given a pool (DBIx::Class::Storage::DBI::Replicated::Pool) of replicated
  database's (DBIx::Class::Storage::DBI::Replicated::Replicant), defines a
  method by which query load can be spread out across each replicant in the
  pool.
</section>
<section class="Sh">
<h1 class="Sh" id="ATTRIBUTES"><a class="permalink" href="#ATTRIBUTES">ATTRIBUTES</a></h1>
This class defines the following attributes.
<section class="Ss">
<h2 class="Ss" id="auto_validate_every_($seconds)"><a class="permalink" href="#auto_validate_every_($seconds)">auto_validate_every
  ($seconds)</a></h2>
If auto_validate has some sort of value, run &quot;validate_replicants&quot; in
  DBIx::Class::Storage::DBI::Replicated::Pool every
  <span class="Li">$seconds</span>. Be careful with this, because if you set it
  to 0 you will end up validating every query.
</section>
<section class="Ss">
<h2 class="Ss" id="master"><a class="permalink" href="#master">master</a></h2>
The DBIx::Class::Storage::DBI object that is the master database all the
  replicants are trying to follow. The balancer needs to know it since it's the
  ultimate fallback.
</section>
<section class="Ss">
<h2 class="Ss" id="pool"><a class="permalink" href="#pool">pool</a></h2>
The DBIx::Class::Storage::DBI::Replicated::Pool object that we are trying to
  balance.
</section>
<section class="Ss">
<h2 class="Ss" id="current_replicant"><a class="permalink" href="#current_replicant">current_replicant</a></h2>
Replicant storages (slaves) handle all read only traffic. The assumption is that
  your database will become readbound well before it becomes write bound and
  that being able to spread your read only traffic around to multiple databases
  is going to help you to scale traffic.
<p class="Pp">This attribute returns the next slave to handle a read request.
    Your &quot;pool&quot; attribute has methods to help you shuffle through all
    the available replicants via its balancer object.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="METHODS"><a class="permalink" href="#METHODS">METHODS</a></h1>
This class defines the following methods.
<section class="Ss">
<h2 class="Ss" id="_build_current_replicant"><a class="permalink" href="#_build_current_replicant">_build_current_replicant</a></h2>
Lazy builder for the &quot;current_replicant_storage&quot; attribute.
</section>
<section class="Ss">
<h2 class="Ss" id="next_storage"><a class="permalink" href="#next_storage">next_storage</a></h2>
This method should be defined in the class which consumes this role.
<p class="Pp">Given a pool object, return the next replicant that will serve
    queries. The default behavior is to grab the first replicant it finds but
    you can write your own subclasses of
    DBIx::Class::Storage::DBI::Replicated::Balancer to support other balance
    systems.</p>
<p class="Pp">This returns from the pool of active replicants. If there are no
    active replicants, then you should have it return the master as an ultimate
    fallback.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="around:_next_storage"><a class="permalink" href="#around:_next_storage">around:
  next_storage</a></h2>
Advice on next storage to add the autovalidation. We have this broken out so
  that it's easier to break out the auto validation into a role.
<p class="Pp">This also returns the master in the case that none of the
    replicants are active or just forgot to create them :)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="increment_storage"><a class="permalink" href="#increment_storage">increment_storage</a></h2>
Rolls the Storage to whatever is next in the queue, as defined by the Balancer.
</section>
<section class="Ss">
<h2 class="Ss" id="around:_select"><a class="permalink" href="#around:_select">around:
  select</a></h2>
Advice on the select attribute. Each time we use a replicant we need to change
  it via the storage pool algorithm. That way we are spreading the load evenly
  (hopefully) across existing capacity.
</section>
<section class="Ss">
<h2 class="Ss" id="around:_select_single"><a class="permalink" href="#around:_select_single">around:
  select_single</a></h2>
Advice on the select_single attribute. Each time we use a replicant we need to
  change it via the storage pool algorithm. That way we are spreading the load
  evenly (hopefully) across existing capacity.
</section>
<section class="Ss">
<h2 class="Ss" id="before:_columns_info_for"><a class="permalink" href="#before:_columns_info_for">before:
  columns_info_for</a></h2>
Advice on the current_replicant_storage attribute. Each time we use a replicant
  we need to change it via the storage pool algorithm. That way we are spreading
  the load evenly (hopefully) across existing capacity.
</section>
<section class="Ss">
<h2 class="Ss" id="_get_forced_pool_($name)"><a class="permalink" href="#_get_forced_pool_($name)">_get_forced_pool
  ($name)</a></h2>
Given an identifier, find the most correct storage object to handle the query.
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
John Napiorkowski &lt;jjnapiork@cpan.org&gt;
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
You may distribute this code under the same terms as Perl itself.
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-01-05</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
