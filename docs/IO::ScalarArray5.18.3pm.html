<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>IO::ScalarArray(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">IO::ScalarArray(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">IO::ScalarArray(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
IO::ScalarArray - IO:: interface for reading/writing an array of scalars
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
Perform I/O on strings, using the basic OO interface...
<p class="Pp"><span class="Li"></span></p>
<pre>
    use IO::ScalarArray;
    @data = (&quot;My mes&quot;, &quot;sage:\n&quot;);

    ### Open a handle on an array, and append to it:
    $AH = new IO::ScalarArray \@data;
    $AH-&gt;print(&quot;Hello&quot;);       
    $AH-&gt;print(&quot;, world!\nBye now!\n&quot;);  
    print &quot;The array is now: &quot;, @data, &quot;\n&quot;;

    ### Open a handle on an array, read it line-by-line, then close it:
    $AH = new IO::ScalarArray \@data;
    while (defined($_ = $AH-&gt;getline)) { 
        print &quot;Got line: $_&quot;;
    }
    $AH-&gt;close;

    ### Open a handle on an array, and slurp in all the lines:
    $AH = new IO::ScalarArray \@data;
    print &quot;All lines:\n&quot;, $AH-&gt;getlines; 

    ### Get the current position (either of two ways):
    $pos = $AH-&gt;getpos;         
    $offset = $AH-&gt;tell;  

    ### Set the current position (either of two ways):
    $AH-&gt;setpos($pos);        
    $AH-&gt;seek($offset, 0);

    ### Open an anonymous temporary array:
    $AH = new IO::ScalarArray;
    $AH-&gt;print(&quot;Hi there!&quot;);
    print &quot;I printed: &quot;, @{$AH-&gt;aref}, &quot;\n&quot;;      ### get at value
</pre>
<p class="Pp">Don't like OO for your I/O? No problem. Thanks to the magic of an
    invisible <i>tie()</i>, the following now works out of the box, just as it
    does with IO::Handle:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use IO::ScalarArray;
    @data = (&quot;My mes&quot;, &quot;sage:\n&quot;);

    ### Open a handle on an array, and append to it:
    $AH = new IO::ScalarArray \@data;
    print $AH &quot;Hello&quot;;    
    print $AH &quot;, world!\nBye now!\n&quot;;
    print &quot;The array is now: &quot;, @data, &quot;\n&quot;;

    ### Open a handle on a string, read it line-by-line, then close it:
    $AH = new IO::ScalarArray \@data;
    while (&lt;$AH&gt;) {
        print &quot;Got line: $_&quot;;
    }
    close $AH;

    ### Open a handle on a string, and slurp in all the lines:
    $AH = new IO::ScalarArray \@data;
    print &quot;All lines:\n&quot;, &lt;$AH&gt;;

    ### Get the current position (WARNING: requires 5.6):
    $offset = tell $AH;

    ### Set the current position (WARNING: requires 5.6):
    seek $AH, $offset, 0;

    ### Open an anonymous temporary scalar:
    $AH = new IO::ScalarArray;
    print $AH &quot;Hi there!&quot;;
    print &quot;I printed: &quot;, @{$AH-&gt;aref}, &quot;\n&quot;;      ### get at value
</pre>
<p class="Pp">And for you folks with 1.x code out there: the old <i>tie()</i>
    style still works, though this is <i>unnecessary and deprecated</i>:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    use IO::ScalarArray;

    ### Writing to a scalar...
    my @a; 
    tie *OUT, 'IO::ScalarArray', \@a;
    print OUT &quot;line 1\nline 2\n&quot;, &quot;line 3\n&quot;;
    print &quot;Array is now: &quot;, @a, &quot;\n&quot;

    ### Reading and writing an anonymous scalar... 
    tie *OUT, 'IO::ScalarArray';
    print OUT &quot;line 1\nline 2\n&quot;, &quot;line 3\n&quot;;
    tied(OUT)-&gt;seek(0,0);
    while (&lt;OUT&gt;) { 
        print &quot;Got line: &quot;, $_;
    }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This class is part of the IO::Stringy distribution; see IO::Stringy for change
  log and general information.
<p class="Pp">The IO::ScalarArray class implements objects which behave just
    like IO::Handle (or FileHandle) objects, except that you may use them to
    write to (or read from) arrays of scalars. Logically, an array of scalars
    defines an in-core &quot;file&quot; whose contents are the concatenation of
    the scalars in the array. The handles created by this class are
    automatically tiehandle'd (though please see &quot;WARNINGS&quot; for
    information relevant to your Perl version).</p>
<p class="Pp">For writing large amounts of data with individual <i>print()</i>
    statements, this class is likely to be more efficient than IO::Scalar.</p>
<p class="Pp">Basically, this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my @a;
    $AH = new IO::ScalarArray \@a;
    $AH-&gt;print(&quot;Hel&quot;, &quot;lo, &quot;);         ### OO style
    $AH-&gt;print(&quot;world!\n&quot;);            ### ditto
</pre>
<p class="Pp">Or this:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    my @a;
    $AH = new IO::ScalarArray \@a;
    print $AH &quot;Hel&quot;, &quot;lo, &quot;;           ### non-OO style
    print $AH &quot;world!\n&quot;;              ### ditto
</pre>
<p class="Pp">Causes <span class="Li">@a</span> to be set to the following array
    of 3 strings:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    ( &quot;Hel&quot; , 
      &quot;lo, &quot; , 
      &quot;world!\n&quot; )
</pre>
<p class="Pp">See IO::Scalar and compare with this class.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="PUBLIC_INTERFACE"><a class="permalink" href="#PUBLIC_INTERFACE">PUBLIC
  INTERFACE</a></h1>
<section class="Ss">
<h2 class="Ss" id="Construction"><a class="permalink" href="#Construction">Construction</a></h2>
<dl class="Bl-tag">
  <dt>new [ARGS...]</dt>
  <dd><i>Class method.</i> Return a new, unattached array handle. If any
      arguments are given, they're sent to <i>open()</i>.</dd>
  <dt>open [ARRAYREF]</dt>
  <dd><i>Instance method.</i> Open the array handle on a new array, pointed to
      by ARRAYREF. If no ARRAYREF is given, a &quot;private&quot; array is
      created to hold the file data.
    <p class="Pp">Returns the self object on success, undefined on error.</p>
  </dd>
  <dt>opened</dt>
  <dd><i>Instance method.</i> Is the array handle opened on something?</dd>
  <dt>close</dt>
  <dd><i>Instance method.</i> Disassociate the array handle from its underlying
      array. Done automatically on destroy.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Input_and_output"><a class="permalink" href="#Input_and_output">Input
  and output</a></h2>
<dl class="Bl-tag">
  <dt>flush</dt>
  <dd><i>Instance method.</i> No-op, provided for OO compatibility.</dd>
  <dt>getc</dt>
  <dd><i>Instance method.</i> Return the next character, or undef if none
      remain. This does a <i>read</i>(1), which is somewhat costly.</dd>
  <dt>getline</dt>
  <dd><i>Instance method.</i> Return the next line, or undef on end of data. Can
      safely be called in an array context. Currently, lines are delimited by
      &quot;\n&quot;.</dd>
  <dt>getlines</dt>
  <dd><i>Instance method.</i> Get all remaining lines. It will <i>croak()</i> if
      accidentally called in a scalar context.</dd>
  <dt>print ARGS...</dt>
  <dd><i>Instance method.</i> Print ARGS to the underlying array.
    <p class="Pp">Currently, this always causes a &quot;seek to the end of the
        array&quot; and generates a new array entry. This may change in the
        future.</p>
  </dd>
  <dt>read BUF, NBYTES, [OFFSET];</dt>
  <dd><i>Instance method.</i> Read some bytes from the array. Returns the number
      of bytes actually read, 0 on end-of-file, undef on error.</dd>
  <dt>write BUF, NBYTES, [OFFSET];</dt>
  <dd><i>Instance method.</i> Write some bytes into the array.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Seeking/telling_and_other_attributes"><a class="permalink" href="#Seeking/telling_and_other_attributes">Seeking/telling
  and other attributes</a></h2>
<dl class="Bl-tag">
  <dt>autoflush</dt>
  <dd><i>Instance method.</i> No-op, provided for OO compatibility.</dd>
  <dt>binmode</dt>
  <dd><i>Instance method.</i> No-op, provided for OO compatibility.</dd>
  <dt>clearerr</dt>
  <dd><i>Instance method.</i> Clear the error and EOF flags. A no-op.</dd>
  <dt>eof</dt>
  <dd><i>Instance method.</i> Are we at end of file?</dd>
  <dt>seek POS,WHENCE</dt>
  <dd><i>Instance method.</i> Seek to a given position in the stream. Only a
      WHENCE of 0 (SEEK_SET) is supported.</dd>
  <dt>tell</dt>
  <dd><i>Instance method.</i> Return the current position in the stream, as a
      numeric offset.</dd>
  <dt>setpos POS</dt>
  <dd><i>Instance method.</i> Seek to a given position in the array, using the
      opaque <i>getpos()</i> value. Don't expect this to be a number.</dd>
  <dt>getpos</dt>
  <dd><i>Instance method.</i> Return the current position in the array, as an
      opaque value. Don't expect this to be a number.</dd>
  <dt>aref</dt>
  <dd><i>Instance method.</i> Return a reference to the underlying array.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="WARNINGS"><a class="permalink" href="#WARNINGS">WARNINGS</a></h1>
Perl's TIEHANDLE spec was incomplete prior to 5.005_57; it was missing support
  for <span class="Li">&quot;seek()&quot;</span>,
  <span class="Li">&quot;tell()&quot;</span>, and
  <span class="Li">&quot;eof()&quot;</span>. Attempting to use these functions
  with an IO::ScalarArray will not work prior to 5.005_57. IO::ScalarArray will
  not have the relevant methods invoked; and even worse, this kind of bug can
  lie dormant for a while. If you turn warnings on (via
  <span class="Li">$^W</span> or <span class="Li">&quot;perl -w&quot;</span>),
  and you see something like this...
<p class="Pp"><span class="Li"></span></p>
<pre>
    attempt to seek on unopened filehandle
</pre>
<p class="Pp">...then you are probably trying to use one of these functions on
    an IO::ScalarArray with an old Perl. The remedy is to simply use the OO
    version; e.g.:</p>
<p class="Pp"><span class="Li"></span></p>
<pre>
    $AH-&gt;seek(0,0);    ### GOOD: will work on any 5.005
    seek($AH,0,0);     ### WARNING: will only work on 5.005_57 and beyond
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<span class="Li">$Id:</span> ScalarArray.pm,v 1.7 2005/02/10 21:21:53 dfs Exp $
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
<section class="Ss">
<h2 class="Ss" id="Primary_Maintainer"><a class="permalink" href="#Primary_Maintainer">Primary
  Maintainer</a></h2>
David F. Skoll (<i>dfs@roaringpenguin.com</i>).
</section>
<section class="Ss">
<h2 class="Ss" id="Principal_author"><a class="permalink" href="#Principal_author">Principal
  author</a></h2>
Eryq (<i>eryq@zeegee.com</i>). President, ZeeGee Software Inc
  (<i>http://www.zeegee.com</i>).
</section>
<section class="Ss">
<h2 class="Ss" id="Other_contributors"><a class="permalink" href="#Other_contributors">Other
  contributors</a></h2>
Thanks to the following individuals for their invaluable contributions (if I've
  forgotten or misspelled your name, please email me!):
<p class="Pp"><i>Andy Glew,</i> for suggesting
    <span class="Li">&quot;getc()&quot;</span>.</p>
<p class="Pp"><i>Brandon Browning,</i> for suggesting
    <span class="Li">&quot;opened()&quot;</span>.</p>
<p class="Pp"><i>Eric L. Brine,</i> for his offset-using <i>read()</i> and
    <i>write()</i> implementations.</p>
<p class="Pp"><i>Doug Wilson,</i> for the IO::Handle inheritance and automatic
    tie-ing.</p>
</section>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2005-02-10</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
