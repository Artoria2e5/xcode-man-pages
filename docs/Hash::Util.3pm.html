<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>
  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>Hash::Util(3pm)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">Hash::Util(3pm)</td>
    <td class="head-vol">Perl Programmers Reference Guide</td>
    <td class="head-rtitle">Hash::Util(3pm)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
Hash::Util - A selection of general-utility hash subroutines
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
  # Restricted hashes

  use Hash::Util qw(
                     fieldhash fieldhashes

                     all_keys
                     lock_keys unlock_keys
                     lock_value unlock_value
                     lock_hash unlock_hash
                     lock_keys_plus
                     hash_locked hash_unlocked
                     hashref_locked hashref_unlocked
                     hidden_keys legal_keys

                     lock_ref_keys unlock_ref_keys
                     lock_ref_value unlock_ref_value
                     lock_hashref unlock_hashref
                     lock_ref_keys_plus
                     hidden_ref_keys legal_ref_keys

                     hash_seed hash_value hv_store
                     bucket_stats bucket_info bucket_array
                     lock_hash_recurse unlock_hash_recurse

                     hash_traversal_mask
                   );

  %hash = (foo =&gt; 42, bar =&gt; 23);
  # Ways to restrict a hash
  lock_keys(%hash);
  lock_keys(%hash, @keyset);
  lock_keys_plus(%hash, @additional_keys);

  # Ways to inspect the properties of a restricted hash
  my @legal = legal_keys(%hash);
  my @hidden = hidden_keys(%hash);
  my $ref = all_keys(%hash,@keys,@hidden);
  my $is_locked = hash_locked(%hash);

  # Remove restrictions on the hash
  unlock_keys(%hash);

  # Lock individual values in a hash
  lock_value  (%hash, 'foo');
  unlock_value(%hash, 'foo');

  # Ways to change the restrictions on both keys and values
  lock_hash  (%hash);
  unlock_hash(%hash);

  my $hashes_are_randomised = hash_seed() != 0;

  my $int_hash_value = hash_value( 'string' );

  my $mask= hash_traversal_mask(%hash);

  hash_traversal_mask(%hash,1234);
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<span class="Li">&quot;Hash::Util&quot;</span> and
  <span class="Li">&quot;Hash::Util::FieldHash&quot;</span> contain special
  functions for manipulating hashes that don't really warrant a keyword.
<p class="Pp"><span class="Li">&quot;Hash::Util&quot;</span> contains a set of
    functions that support restricted hashes. These are described in this
    document. <span class="Li">&quot;Hash::Util::FieldHash&quot;</span> contains
    an (unrelated) set of functions that support the use of hashes in
    <i>inside-out classes</i>, described in Hash::Util::FieldHash.</p>
<p class="Pp">By default <span class="Li">&quot;Hash::Util&quot;</span> does not
    export anything.</p>
<section class="Ss">
<h2 class="Ss" id="Restricted_hashes"><a class="permalink" href="#Restricted_hashes">Restricted
  hashes</a></h2>
5.8.0 introduces the ability to restrict a hash to a certain set of keys. No
  keys outside of this set can be added. It also introduces the ability to lock
  an individual key so it cannot be deleted and the ability to ensure that an
  individual value cannot be changed.
<p class="Pp">This is intended to largely replace the deprecated
  pseudo-hashes.</p>
<dl class="Bl-tag">
  <dt><b>lock_keys</b></dt>
  <dd></dd>
  <dt><b>unlock_keys</b></dt>
  <dd><span class="Li"></span>
    <pre>
  lock_keys(%hash);
  lock_keys(%hash, @keys);
    </pre>
    <p class="Pp">Restricts the given <span class="Li">%hash</span>'s set of
        keys to <span class="Li">@keys</span>. If <span class="Li">@keys</span>
        is not given it restricts it to its current keyset. No more keys can be
        added. <i>delete()</i> and <i>exists()</i> will still work, but will not
        alter the set of allowed keys. <b>Note</b>: the current implementation
        prevents the hash from being <i>bless()</i>ed while it is in a locked
        state. Any attempt to do so will raise an exception. Of course you can
        still <i>bless()</i> the hash before you call <i>lock_keys()</i> so this
        shouldn't be a problem.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  unlock_keys(%hash);
    </pre>
    <p class="Pp">Removes the restriction on the <span class="Li">%hash</span>'s
        keyset.</p>
    <p class="Pp"><b>Note</b> that if any of the values of the hash have been
        locked they will not be unlocked after this sub executes.</p>
    <p class="Pp">Both routines return a reference to the hash operated on.</p>
  </dd>
  <dt><b>lock_keys_plus</b></dt>
  <dd><span class="Li"></span>
    <pre>
  lock_keys_plus(%hash,@additional_keys)
    </pre>
    <p class="Pp">Similar to <span class="Li">&quot;lock_keys()&quot;</span>,
        with the difference being that the optional key list specifies keys that
        may or may not be already in the hash. Essentially this is an easier way
        to say</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  lock_keys(%hash,@additional_keys,keys %hash);
    </pre>
    <p class="Pp">Returns a reference to <span class="Li">%hash</span></p>
  </dd>
  <dt><b>lock_value</b></dt>
  <dd></dd>
  <dt><b>unlock_value</b></dt>
  <dd><span class="Li"></span>
    <pre>
  lock_value  (%hash, $key);
  unlock_value(%hash, $key);
    </pre>
    <p class="Pp">Locks and unlocks the value for an individual key of a hash.
        The value of a locked key cannot be changed.</p>
    <p class="Pp">Unless <span class="Li">%hash</span> has already been locked
        the key/value could be deleted regardless of this setting.</p>
    <p class="Pp">Returns a reference to the <span class="Li">%hash</span>.</p>
  </dd>
  <dt><b>lock_hash</b></dt>
  <dd></dd>
  <dt><b>unlock_hash</b></dt>
  <dd><span class="Li"></span>
    <pre>
    lock_hash(%hash);
    </pre>
    <p class="Pp"><i>lock_hash()</i> locks an entire hash, making all keys and
        values read-only. No value can be changed, no keys can be added or
        deleted.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    unlock_hash(%hash);
    </pre>
    <p class="Pp"><i>unlock_hash()</i> does the opposite of <i>lock_hash()</i>.
        All keys and values are made writable. All values can be changed and
        keys can be added and deleted.</p>
    <p class="Pp">Returns a reference to the <span class="Li">%hash</span>.</p>
  </dd>
  <dt><b>lock_hash_recurse</b></dt>
  <dd></dd>
  <dt><b>unlock_hash_recurse</b></dt>
  <dd><span class="Li"></span>
    <pre>
    lock_hash_recurse(%hash);
    </pre>
    <p class="Pp"><i>lock_hash()</i> locks an entire hash and any hashes it
        references recursively, making all keys and values read-only. No value
        can be changed, no keys can be added or deleted.</p>
    <p class="Pp">This method <b>only</b> recurses into hashes that are
        referenced by another hash. Thus a Hash of Hashes (HoH) will all be
        restricted, but a Hash of Arrays of Hashes (HoAoH) will only have the
        top hash restricted.</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    unlock_hash_recurse(%hash);
    </pre>
    <p class="Pp"><i>unlock_hash_recurse()</i> does the opposite of
        <i>lock_hash_recurse()</i>. All keys and values are made writable. All
        values can be changed and keys can be added and deleted. Identical
        recursion restrictions apply as to <i>lock_hash_recurse()</i>.</p>
    <p class="Pp">Returns a reference to the <span class="Li">%hash</span>.</p>
  </dd>
  <dt><b>hashref_locked</b></dt>
  <dd></dd>
  <dt><b>hash_locked</b></dt>
  <dd><span class="Li"></span>
    <pre>
  hashref_locked(\%hash) and print &quot;Hash is locked!\n&quot;;
  hash_locked(%hash) and print &quot;Hash is locked!\n&quot;;
    </pre>
    <p class="Pp">Returns true if the hash and its keys are locked.</p>
  </dd>
  <dt><b>hashref_unlocked</b></dt>
  <dd></dd>
  <dt><b>hash_unlocked</b></dt>
  <dd><span class="Li"></span>
    <pre>
  hashref_unlocked(\%hash) and print &quot;Hash is unlocked!\n&quot;;
  hash_unlocked(%hash) and print &quot;Hash is unlocked!\n&quot;;
    </pre>
    <p class="Pp">Returns true if the hash and its keys are unlocked.</p>
  </dd>
  <dt><b>legal_keys</b></dt>
  <dd><span class="Li"></span>
    <pre>
  my @keys = legal_keys(%hash);
    </pre>
    <p class="Pp">Returns the list of the keys that are legal in a restricted
        hash. In the case of an unrestricted hash this is identical to calling
        keys(%hash).</p>
  </dd>
  <dt><b>hidden_keys</b></dt>
  <dd><span class="Li"></span>
    <pre>
  my @keys = hidden_keys(%hash);
    </pre>
    <p class="Pp">Returns the list of the keys that are legal in a restricted
        hash but do not have a value associated to them. Thus if 'foo' is a
        &quot;hidden&quot; key of the <span class="Li">%hash</span> it will
        return false for both <span class="Li">&quot;defined&quot;</span> and
        <span class="Li">&quot;exists&quot;</span> tests.</p>
    <p class="Pp">In the case of an unrestricted hash this will return an empty
        list.</p>
    <p class="Pp"><b>NOTE</b> this is an experimental feature that is heavily
        dependent on the current implementation of restricted hashes. Should the
        implementation change, this routine may become meaningless, in which
        case it will return an empty list.</p>
  </dd>
  <dt><b>all_keys</b></dt>
  <dd><span class="Li"></span>
    <pre>
  all_keys(%hash,@keys,@hidden);
    </pre>
    <p class="Pp">Populates the arrays <span class="Li">@keys</span> with the
        all the keys that would pass an
        <span class="Li">&quot;exists&quot;</span> tests, and populates
        <span class="Li">@hidden</span> with the remaining legal keys that have
        not been utilized.</p>
    <p class="Pp">Returns a reference to the hash.</p>
    <p class="Pp">In the case of an unrestricted hash this will be equivalent
      to</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
  $ref = do {
      @keys = keys %hash;
      @hidden = ();
      \%hash
  };
    </pre>
    <p class="Pp"><b>NOTE</b> this is an experimental feature that is heavily
        dependent on the current implementation of restricted hashes. Should the
        implementation change this routine may become meaningless in which case
        it will behave identically to how it would behave on an unrestricted
        hash.</p>
  </dd>
  <dt><b>hash_seed</b></dt>
  <dd><span class="Li"></span>
    <pre>
    my $hash_seed = hash_seed();
    </pre>
    <p class="Pp"><i>hash_seed()</i> returns the seed bytes used to randomise
        hash ordering.</p>
    <p class="Pp"><b>Note that the hash seed is sensitive information</b>: by
        knowing it one can craft a denial-of-service attack against Perl code,
        even remotely, see &quot;Algorithmic Complexity Attacks&quot; in perlsec
        for more information. <b>Do not disclose the hash seed</b> to people who
        don't need to know it. See also &quot;PERL_HASH_SEED_DEBUG&quot; in
        perlrun.</p>
    <p class="Pp">Prior to Perl 5.17.6 this function returned a UV, it now
        returns a string, which may be of nearly any size as determined by the
        hash function your Perl has been built with. Possible sizes may be but
        are not limited to 4 bytes (for most hash algorithms) and 16 bytes (for
        siphash).</p>
  </dd>
  <dt><b>hash_value</b></dt>
  <dd><span class="Li"></span>
    <pre>
    my $hash_value = hash_value($string);
    </pre>
    <p class="Pp"><i>hash_value()</i> returns the current perl's internal hash
        value for a given string.</p>
    <p class="Pp">Returns a 32 bit integer representing the hash value of the
        string passed in. This value is only reliable for the lifetime of the
        process. It may be different depending on invocation, environment
        variables, perl version, architectures, and build options.</p>
    <p class="Pp"><b>Note that the hash value of a given string is sensitive
        information</b>: by knowing it one can deduce the hash seed which in
        turn can allow one to craft a denial-of-service attack against Perl
        code, even remotely, see &quot;Algorithmic Complexity Attacks&quot; in
        perlsec for more information. <b>Do not disclose the hash value of a
        string</b> to people who don't need to know it. See also
        &quot;PERL_HASH_SEED_DEBUG&quot; in perlrun.</p>
  </dd>
  <dt><b>bucket_info</b></dt>
  <dd>Return a set of basic information about a hash.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my ($keys, $buckets, $used, @length_counts)= bucket_info($hash);
    </pre>
    <p class="Pp">Fields are as follows:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    0: Number of keys in the hash
    1: Number of buckets in the hash
    2: Number of used buckets in the hash
    rest : list of counts, Kth element is the number of buckets
           with K keys in it.
    </pre>
    <p class="Pp">See also <i>bucket_stats()</i> and <i>bucket_array()</i>.</p>
  </dd>
  <dt><b>bucket_stats</b></dt>
  <dd>Returns a list of statistics about a hash.
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    my ($keys, buckets, $used, $utilization_ratio, $collision_pct,
        $mean, $stddev, @length_counts) = bucket_info($hashref);
    </pre>
    <p class="Pp">Fields are as follows:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
    0: Number of keys in the hash
    1: Number of buckets in the hash
    2: Number of used buckets in the hash
    3: Hash Quality Score
    4: Percent of buckets used
    5: Percent of keys which are in collision
    6: Average bucket length
    7: Standard Deviation of bucket lengths.
    rest : list of counts, Kth element is the number of buckets
           with K keys in it.
    </pre>
    <p class="Pp">See also <i>bucket_info()</i> and <i>bucket_array()</i>.</p>
    <p class="Pp">Note that Hash Quality Score would be 1 for an ideal hash,
        numbers close to and below 1 indicate good hashing, and number
        significantly above indicate a poor score. In practice it should be
        around 0.95 to 1.05. It is defined as:</p>
    <p class="Pp"><span class="Li"></span></p>
    <pre>
 $score= sum( $count[$length] * ($length * ($length + 1) / 2) )
            /
            ( ( $keys / 2 * $buckets ) *
              ( $keys + ( 2 * $buckets ) - 1 ) )
    </pre>
    <p class="Pp">The formula is from the Red Dragon book (reformulated to use
        the data available) and is documented at
        &lt;http://www.strchr.com/hash_functions&gt;</p>
  </dd>
  <dt><b>bucket_array</b></dt>
  <dd><span class="Li"></span>
    <pre>
    my $array= bucket_array(\%hash);
    </pre>
    <p class="Pp">Returns a packed representation of the bucket array associated
        with a hash. Each element of the array is either an integer K, in which
        case it represents K empty buckets, or a reference to another array
        which contains the keys that are in that bucket.</p>
    <p class="Pp"><b>Note that the information returned by bucket_array is
        sensitive information</b>: by knowing it one can directly attack perl's
        hash function which in turn may allow one to craft a denial-of-service
        attack against Perl code, even remotely, see &quot;Algorithmic
        Complexity Attacks&quot; in perlsec for more information. <b>Do not
        disclose the output of this function</b> to people who don't need to
        know it. See also &quot;PERL_HASH_SEED_DEBUG&quot; in perlrun. This
        function is provided strictly for debugging and diagnostics purposes
        only, it is hard to imagine a reason why it would be used in production
        code.</p>
  </dd>
  <dt><b>hv_store</b></dt>
  <dd><span class="Li"></span>
    <pre>
  my $sv = 0;
  hv_store(%hash,$key,$sv) or die &quot;Failed to alias!&quot;;
  $hash{$key} = 1;
  print $sv; # prints 1
    </pre>
    <p class="Pp">Stores an alias to a variable in a hash instead of copying the
        value.</p>
  </dd>
  <dt><b>hash_traversal_mask</b></dt>
  <dd>As of Perl 5.18 every hash has its own hash traversal order, and this
      order changes every time a new element is inserted into the hash. This
      functionality is provided by maintaining an unsigned integer mask (U32)
      which is xor'ed with the actual bucket id during a traversal of the hash
      buckets using <i>keys()</i>, <i>values()</i> or <i>each()</i>.
    <p class="Pp">You can use this subroutine to get and set the traversal mask
        for a specific hash. Setting the mask ensures that a given hash will
        produce the same key order. <b>Note</b> that this does <b>not</b>
        guarantee that <b>two</b> hashes will produce the same key order for the
        same hash seed and traversal mask, items that collide into one bucket
        may have different orders regardless of this setting.</p>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Operating_on_references_to_hashes."><a class="permalink" href="#Operating_on_references_to_hashes.">Operating
  on references to hashes.</a></h2>
Most subroutines documented in this module have equivalent versions that operate
  on references to hashes instead of native hashes. The following is a list of
  these subs. They are identical except in name and in that instead of taking a
  <span class="Li">%hash</span> they take a <span class="Li">$hashref</span>,
  and additionally are not prototyped.
<dl class="Bl-tag">
  <dt>lock_ref_keys</dt>
  <dd></dd>
  <dt>unlock_ref_keys</dt>
  <dd></dd>
  <dt>lock_ref_keys_plus</dt>
  <dd></dd>
  <dt>lock_ref_value</dt>
  <dd></dd>
  <dt>unlock_ref_value</dt>
  <dd></dd>
  <dt>lock_hashref</dt>
  <dd></dd>
  <dt>unlock_hashref</dt>
  <dd></dd>
  <dt>lock_hashref_recurse</dt>
  <dd></dd>
  <dt>unlock_hashref_recurse</dt>
  <dd></dd>
  <dt>hash_ref_unlocked</dt>
  <dd></dd>
  <dt>legal_ref_keys</dt>
  <dd></dd>
  <dt>hidden_ref_keys</dt>
  <dd></dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
Note that the trapping of the restricted operations is not atomic: for example
<p class="Pp"><span class="Li"></span></p>
<pre>
    eval { %hash = (illegal_key =&gt; 1) }
</pre>
<p class="Pp">leaves the <span class="Li">%hash</span> empty rather than with
    its original contents.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
The interface exposed by this module is very close to the current implementation
  of restricted hashes. Over time it is expected that this behavior will be
  extended and the interface abstracted further.
</section>
<section class="Sh">
<h1 class="Sh" id="AUTHOR"><a class="permalink" href="#AUTHOR">AUTHOR</a></h1>
Michael G Schwern &lt;schwern@pobox.com&gt; on top of code by Nick Ing-Simmons
  and Jeffrey Friedl.
<p class="Pp"><i>hv_store()</i> is from Array::RefElem, Copyright 2000 Gisle
    Aas.</p>
<p class="Pp">Additional code by Yves Orton.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
Scalar::Util, List::Util and &quot;Algorithmic Complexity Attacks&quot; in
  perlsec.
<p class="Pp">Hash::Util::FieldHash.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2014-09-30</td>
    <td class="foot-os">perl v5.18.4</td>
  </tr>
</table>
</body>
</html>
