<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
  
   Standard preamble:
   ========================================================================
   Vertical space (when we can't use .PP)
   Begin verbatim text
   End verbatim text
   Set up some character translations and predefined strings.  \*(-- will
   give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
   double quote, and \*(R" will give a right double quote.  \*(C+ will
   give a nicer C++.  Capital omega is used to do unbreakable dashes and
   therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
   nothing in troff, for use with C<>.
   diablo 10 pitch
    diablo 12 pitch
 -->
<head>

<style>
@media (prefers-color-scheme: dark) {
  body {
    background: #000;
    color: #d0d0d0;
  }

  a, a:visited {
    color: #1899eb;
  }
}
</style>

  <meta charset="utf-8"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    div.Pp { margin: 1ex 0ex; }
    div.Nd, div.Bf, div.Op { display: inline; }
    span.Pa, span.Ad { font-style: italic; }
    span.Ms { font-weight: bold; }
    dl.Bl-diag > dt { font-weight: bold; }
    code.Nm, code.Fl, code.Cm, code.Ic, code.In, code.Fd, code.Fn,
    code.Cd { font-weight: bold; font-family: inherit; }
  </style>
  <title>LWP::Simple(3)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">LWP::Simple(3)</td>
    <td class="head-vol">User Contributed Perl Documentation</td>
    <td class="head-rtitle">LWP::Simple(3)</td>
  </tr>
</table>
<div class="manual-text">
<br/>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
LWP::Simple - simple procedural interface to LWP
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<span class="Li"></span>
<pre>
 perl -MLWP::Simple -e 'getprint &quot;http://www.sn.no&quot;'

 use LWP::Simple;
 $content = get(&quot;http://www.sn.no/&quot;);
 die &quot;Couldn't get it!&quot; unless defined $content;

 if (mirror(&quot;http://www.sn.no/&quot;, &quot;foo&quot;) == RC_NOT_MODIFIED) {
     ...
 }

 if (is_success(getprint(&quot;http://www.sn.no/&quot;))) {
     ...
 }
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
This module is meant for people who want a simplified view of the libwww-perl
  library. It should also be suitable for one-liners. If you need more control
  or access to the header fields in the requests sent and responses received,
  then you should use the full object-oriented interface provided by the
  LWP::UserAgent module.
<p class="Pp">The module will also export the LWP::UserAgent object as
    <span class="Li">$ua</span> if you ask for it explicitly.</p>
<p class="Pp">The user agent created by this module will identify itself as
    <span class="Li">&quot;LWP::Simple/#.##&quot;</span> and will initialize its
    proxy defaults from the environment (by calling
    <span class="Li">&quot;$ua-&gt;env_proxy&quot;</span>).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUNCTIONS"><a class="permalink" href="#FUNCTIONS">FUNCTIONS</a></h1>
The following functions are provided (and exported) by this module:
<section class="Ss">
<h2 class="Ss" id="get"><a class="permalink" href="#get">get</a></h2>
<span class="Li"></span>
<pre>
    my $res = get($url);
</pre>
<p class="Pp">The <b>get()</b> function will fetch the document identified by
    the given URL and return it. It returns
    <span class="Li">&quot;undef&quot;</span> if it fails. The
    <span class="Li">$url</span> argument can be either a string or a reference
    to a URI object.</p>
<p class="Pp">You will not be able to examine the response code or response
    headers (like <span class="Li">&quot;Content-Type&quot;</span>) when you are
    accessing the web using this function. If you need that information you
    should use the full OO interface (see LWP::UserAgent).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="head"><a class="permalink" href="#head">head</a></h2>
<span class="Li"></span>
<pre>
    my $res = head($url);
</pre>
<p class="Pp">Get document headers. Returns the following 5 values if
    successful: ($content_type, <span class="Li">$document_length</span>,
    <span class="Li">$modified_time</span>, <span class="Li">$expires</span>,
    <span class="Li">$server</span>)</p>
<p class="Pp">Returns an empty list if it fails. In scalar context returns TRUE
    if successful.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="getprint"><a class="permalink" href="#getprint">getprint</a></h2>
<span class="Li"></span>
<pre>
    my $code = getprint($url);
</pre>
<p class="Pp">Get and print a document identified by a URL. The document is
    printed to the selected default filehandle for output (normally STDOUT) as
    data is received from the network. If the request fails, then the status
    code and message are printed on STDERR. The return value is the HTTP
    response code.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="getstore"><a class="permalink" href="#getstore">getstore</a></h2>
<span class="Li"></span>
<pre>
    my $code = getstore($url, $file)
</pre>
<p class="Pp">Gets a document identified by a URL and stores it in the file. The
    return value is the HTTP response code.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="mirror"><a class="permalink" href="#mirror">mirror</a></h2>
<span class="Li"></span>
<pre>
    my $code = mirror($url, $file);
</pre>
<p class="Pp">Get and store a document identified by a URL, using
    <i>If-modified-since</i>, and checking the <i>Content-Length</i>. Returns
    the HTTP response code.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="STATUS_CONSTANTS"><a class="permalink" href="#STATUS_CONSTANTS">STATUS
  CONSTANTS</a></h1>
This module also exports the HTTP::Status constants and procedures. You can use
  them when you check the response code from &quot;getprint&quot; in
  LWP::Simple, &quot;getstore&quot; in LWP::Simple or &quot;mirror&quot; in
  LWP::Simple. The constants are:
<p class="Pp"><span class="Li"></span></p>
<pre>
   RC_CONTINUE
   RC_SWITCHING_PROTOCOLS
   RC_OK
   RC_CREATED
   RC_ACCEPTED
   RC_NON_AUTHORITATIVE_INFORMATION
   RC_NO_CONTENT
   RC_RESET_CONTENT
   RC_PARTIAL_CONTENT
   RC_MULTIPLE_CHOICES
   RC_MOVED_PERMANENTLY
   RC_MOVED_TEMPORARILY
   RC_SEE_OTHER
   RC_NOT_MODIFIED
   RC_USE_PROXY
   RC_BAD_REQUEST
   RC_UNAUTHORIZED
   RC_PAYMENT_REQUIRED
   RC_FORBIDDEN
   RC_NOT_FOUND
   RC_METHOD_NOT_ALLOWED
   RC_NOT_ACCEPTABLE
   RC_PROXY_AUTHENTICATION_REQUIRED
   RC_REQUEST_TIMEOUT
   RC_CONFLICT
   RC_GONE
   RC_LENGTH_REQUIRED
   RC_PRECONDITION_FAILED
   RC_REQUEST_ENTITY_TOO_LARGE
   RC_REQUEST_URI_TOO_LARGE
   RC_UNSUPPORTED_MEDIA_TYPE
   RC_INTERNAL_SERVER_ERROR
   RC_NOT_IMPLEMENTED
   RC_BAD_GATEWAY
   RC_SERVICE_UNAVAILABLE
   RC_GATEWAY_TIMEOUT
   RC_HTTP_VERSION_NOT_SUPPORTED
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="CLASSIFICATION_FUNCTIONS"><a class="permalink" href="#CLASSIFICATION_FUNCTIONS">CLASSIFICATION
  FUNCTIONS</a></h1>
The HTTP::Status classification functions are:
<section class="Ss">
<h2 class="Ss" id="is_success"><a class="permalink" href="#is_success">is_success</a></h2>
<span class="Li"></span>
<pre>
    my $bool = is_success($rc);
</pre>
<p class="Pp">True if response code indicated a successful request.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="is_error"><a class="permalink" href="#is_error">is_error</a></h2>
<span class="Li"></span>
<pre>
    my $bool = is_error($rc)
</pre>
<p class="Pp">True if response code indicated that an error occurred.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEAT"><a class="permalink" href="#CAVEAT">CAVEAT</a></h1>
Note that if you are using both LWP::Simple and the very popular CGI module, you
  may be importing a <span class="Li">&quot;head&quot;</span> function from each
  module, producing a warning like <span class="Li">&quot;Prototype mismatch:
  sub main::head ($) vs none&quot;</span>. Get around this problem by just not
  importing LWP::Simple's <span class="Li">&quot;head&quot;</span> function,
  like so:
<p class="Pp"><span class="Li"></span></p>
<pre>
        use LWP::Simple qw(!head);
        use CGI qw(:standard);  # then only CGI.pm defines a head()
</pre>
<p class="Pp">Then if you do need LWP::Simple's
    <span class="Li">&quot;head&quot;</span> function, you can just call it as
    <span class="Li">&quot;LWP::Simple::head($url)&quot;</span>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
LWP, lwpcook, LWP::UserAgent, HTTP::Status, lwp-request, lwp-mirror
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">2020-04-14</td>
    <td class="foot-os">perl v5.28.2</td>
  </tr>
</table>
</body>
</html>
